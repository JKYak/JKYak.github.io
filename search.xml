<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字符串入门</title>
      <link href="/2024/04/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/04/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串入门"><a href="#字符串入门" class="headerlink" title="字符串入门"></a>字符串入门</h2><h3 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h3><p>DFA，即确定有限状态自动机。用于判断输入的字符串是否符合要求。所有的字符串算法都是构造 DFA，结构有点像图灵机。</p><p>先给点定义：</p><ul><li>状态集 $Q$（有限）：若将自动机看成图，那么状态是顶点。</li><li>字符集 $\sum$：满足自动机要求的字符集。</li><li>可接受状态集 $F\subseteq Q$：是满足要求的状态。</li><li>初始状态 $q_0\in Q$：是初始空状态。</li><li>转移函数 $\delta$：$\delta\times \sum\rightarrow Q$ 是转移函数。</li></ul><p>整个算法流程就是，从初始状态 $q_0$ 出发，每次输入字符 $c$，并通过转移函数 $\delta$ 转移。最后若状态为 $F$，那么字符串符合要求。</p><h5 id="例题1：构造判断二进制数奇偶的-DFA"><a href="#例题1：构造判断二进制数奇偶的-DFA" class="headerlink" title="例题1：构造判断二进制数奇偶的 DFA"></a>例题1：构造判断二进制数奇偶的 DFA</h5><p>因为二进制数的奇偶性只与最后一位数是 $0$ 还是 $1$ 有关。所以这里构造的 DFA 用 $q$ 表示当前二进制数的奇偶性，每次输入的字符判断，如果是与当前 $q$ 相同就不变，否则转移到另一个。</p><p><img src="/../../../../img/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="看个图"></p><h5 id="例题2：构造"><a href="#例题2：构造" class="headerlink" title="例题2：构造"></a>例题2：构造</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF161D</title>
      <link href="/2024/04/01/CF161D/"/>
      <url>/2024/04/01/CF161D/</url>
      
        <content type="html"><![CDATA[<h3 id="CF161D"><a href="#CF161D" class="headerlink" title="CF161D"></a>CF161D</h3><p>点分&#x2F;长链剖分&#x2F;dsu 随便过。</p><p>但注意到数据范围不强，考虑 $O(nk)$ 的复杂度，可以树形DP。设 $f_{u,i}$ 表示以 $u$ 为根，子树中离 $u$ 路径长度为 $i$ 的点数。</p><p>统计答案时考虑每个的贡献是 $f_{u,j}\times f_{v,k-i-j}$（$0\le j&lt;k$）。然后再转移 $f_{u,j+1}&#x3D;\sum_{v\in u}f_{v,j}$。</p><p>这样的正确性在于，每次统计答案时都是新的和当前的统计，再把新的更新，不重不漏，有点像枚举两点时 $j$ 从 $i+1$ 开始枚举。第一遍没过就是这里没考虑好，shaber 了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i) ans+=(f[u][i]*f[v][k-i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i) f[u][i+<span class="number">1</span>]+=f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟赛2024-3-28</title>
      <link href="/2024/04/01/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-3-28/"/>
      <url>/2024/04/01/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-3-28/</url>
      
        <content type="html"><![CDATA[<h2 id="校内模拟-2024-3-28"><a href="#校内模拟-2024-3-28" class="headerlink" title="校内模拟-2024-3-28"></a>校内模拟-2024-3-28</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><a href="https://codeforces.com/contest/161/problem/D">原题链接</a></p><p>【题意】</p><p>求树上距离（无边权）为 $k$ 的无序点对数。</p><p>$1\le n\le 5\times 10^4,1\le k\le 500$。</p><p>【解析】</p><p>这题我做过（惊恐）于是场上秒了。</p><p>可以左转<a href="https://jkyak.github.io/2024/04/01/CF161D/">我的题解</a>。</p><p>我的做法是 DP，复杂度 $O(nk)$。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p><a href="https://codeforces.com/contest/592/problem/D">原题链接</a></p><p>【题意】</p><p>给定一棵无边权的树，树上有 $m$ 个关键点，你要选择其中一个出发，到达其余所有关键点，路径（显然）可重复。费用定义为经过边的总数，求最小费用和对应的出发点（多个费用相同的点取最小）。</p><p>【解析】</p><p>容易发现，答案一定是一些走两遍的路径和一些走一遍的路径组成的，所以为了最小化答案，走一遍的路径就是直径。答案就是 （要经过的点数 $-1$）$\times 2$ $-$ 直径。</p><p>猜到这个结论就好想了，考虑如果要经过一个点，当且仅当其子树内有关键点，所以从直径开始 dfs 即可。</p><p>别忘了特判只有一个点的情况。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=x;i&lt;=y;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,x,y) for(int i=x;i&gt;=y;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x,y) memset(x,y,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> st[N],f[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    f[u]=dis;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        st[u]|=<span class="built_in">dfs</span>(v,u,dis+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        e[x].<span class="built_in">eb</span>(y);</span><br><span class="line">        e[y].<span class="built_in">eb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        st[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(st[i]&amp;&amp;f[i]&gt;f[c1]) c1=i;</span><br><span class="line">    <span class="built_in">dfs</span>(c1,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(f[i]&gt;f[c2]) c2=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(c1,c2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;(cnt<span class="number">-1</span>)*<span class="number">2</span>-f[c2]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p><a href="https://www.luogu.com.cn/problem/P1092">原题链接</a></p><p>【题意】</p><p>给定 $3$ 个长为 $n$ 的字符串，串中的字符表示一个数（如 ‘A’ 表示相同的一个数）。在 $n$ 进制下，前两个字符串代表的数的和等于第三个串代表的数。求每个字符 $c$ 代表的唯一数 $x$（’A’ $\le c\le$ ‘Z’,$0\le x\le 9$）</p><p>【解析】</p><p>先考虑爆搜。其实真的就是爆搜，从低位到高位枚举，最后再判断是否可行。可以获得 $40$ 分的好成绩（我考场就是这样的）。</p><p>我们想想能不能优化一下爆搜，剪一下枝。容易想到第一个显然的剪枝，最高位不能有进位，不然会超出 $n$ 位。这样是不够的，再考虑如果已经枚举出来一些数了，我们无法判断只是因为不知道是否有进位。</p><p>那么根据题目，进位最多为 $1$。所以判断一下，如果进不进位都不成立的话显然不行。</p><p>这样就可以通过本题，复杂度十分玄学，我不会算。听说正解是高斯消元，我也不会，先咕着。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string a,b,c;</span><br><span class="line"><span class="type">int</span> x[<span class="number">30</span>],y[<span class="number">30</span>],z[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">30</span>],nex[<span class="number">30</span>],st[<span class="number">30</span>],cnt,flag;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[x[<span class="number">0</span>]]+num[y[<span class="number">0</span>]]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">Fo</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> t1=num[x[i]],t2=num[y[i]],t3=num[z[i]];</span><br><span class="line"><span class="keyword">if</span>(t1==<span class="number">-1</span>||t2==<span class="number">-1</span>||t3==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>((t1+t2)%n!=t3&amp;&amp;(t1+t2+<span class="number">1</span>)%n!=t3) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp=<span class="number">0</span>,i=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((num[x[i]]+num[y[i]]+tmp)%n!=num[z[i]]) <span class="keyword">break</span>;</span><br><span class="line">tmp=(num[x[i]]+num[y[i]]+tmp)/n;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (i&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chk</span>()||flag) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(s==n)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chk2</span>())&#123;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Fo</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">st[i]=<span class="number">1</span>;</span><br><span class="line">num[nex[s]]=i;</span><br><span class="line"><span class="built_in">dfs</span>(s+<span class="number">1</span>);</span><br><span class="line">st[i]=<span class="number">0</span>;</span><br><span class="line">num[nex[s]]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[x])&#123;</span><br><span class="line">st[x]=<span class="number">1</span>;</span><br><span class="line">nex[cnt++]=x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">-1</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">x[i]=(<span class="type">int</span>)a[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">y[i]=(<span class="type">int</span>)b[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">z[i]=(<span class="type">int</span>)c[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Fo</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">init</span>(x[i]);</span><br><span class="line"><span class="built_in">init</span>(y[i]);</span><br><span class="line"><span class="built_in">init</span>(z[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) st[i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p><a href="https://www.luogu.com.cn/problem/P4178">原题链接</a></p><p>【题意】</p><p>给定一棵 $n$ 个节点的树，每条边有边权，求出树上两点距离小于等于 $k$ 的点对数量。</p><p>【解析】</p><p>跟第一题和板子题很像对吧（其实就是点分治板子）。记录所有出现过的距离，双指针尝试更新，容斥减掉子树内的答案并分治。复杂度 $O(n\ log^2n)$。</p><p>没啥好说的，很板。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> v,next,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> tot,rt,sum,cnt,ans;</span><br><span class="line"><span class="type">int</span> head[N],vis[N],mx[N],siz[N],dis[N],rem[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">e[++tot].v=v;</span><br><span class="line">e[tot].w=w;</span><br><span class="line">e[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">mx[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v=e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">getroot</span>(v,u);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line">mx[u]=<span class="built_in">max</span>(mx[u],siz[v]);</span><br><span class="line">&#125;</span><br><span class="line">mx[u]=<span class="built_in">max</span>(mx[u],sum-siz[u]);</span><br><span class="line"><span class="keyword">if</span>(mx[u]&lt;mx[rt]) rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    rem[++cnt]=dis[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]+e[i].w;</span><br><span class="line">        <span class="built_in">getdis</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    dis[u]=s;</span><br><span class="line">    <span class="built_in">getdis</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(rem+<span class="number">1</span>,rem+cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=cnt,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(rem[l]+rem[r]&lt;=k)&#123;</span><br><span class="line">    res+=(r-l);</span><br><span class="line">    l++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> r--;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">ans+=<span class="built_in">calc</span>(u,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v=e[i].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">ans-=<span class="built_in">calc</span>(v,e[i].w);</span><br><span class="line">mx[rt=<span class="number">0</span>]=inf;</span><br><span class="line">sum=siz[v];</span><br><span class="line"><span class="built_in">getroot</span>(v,u);</span><br><span class="line"><span class="built_in">solve</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z;i&lt;n;++i)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="built_in">add</span>(x,y,z);</span><br><span class="line"><span class="built_in">add</span>(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line">mx[rt]=sum=n;</span><br><span class="line"><span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">solve</span>(rt);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>总而言之，这场模拟赛还是不错的，锻炼了我的点分（就是 B 题想到正解了没对很可惜，以后加强训练代码能力）。希望能越来越好，撒花！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斜率优化</title>
      <link href="/2024/03/31/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
      <url>/2024/03/31/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><ul><li>斜率优化，一般是在转移方程中当前为 $i$，枚举决策点 $j$，然后化简式子出现同时与 $i$ 和 $j$ 有关的项（如果没有可以单调队列）。这样的话有点像一次函数，形如 $y&#x3D;kx+b$，那么这里的 $kx$ 就是与$i$ 和 $j$ 有关的项（具体题目具体分析）。问题变成查询最有决策点。</li><li>如果式子中的 $x$ 与 $y$ 都有单调性，可以使用单调队列线性维护。否则有两种做法：维护凸壳并二分或李超树（也可以平衡树或 cdq 分治，但我不会，就不弄巧成拙了）。这些做法是带一个 log 的。</li></ul><p>经典套路：</p><blockquote><p>$1.$ 写出朴素转移方程。</p><p>$2.$ 化简并设出 $x,y,k,b$，根据所求决定维护上凸还是下凸（最大值还是最小值）。</p><p>$3.$ 看单调性决定维护方式。</p></blockquote><h4 id="例题1-P3195-HNOI2008-玩具装箱"><a href="#例题1-P3195-HNOI2008-玩具装箱" class="headerlink" title="例题1 P3195 [HNOI2008] 玩具装箱"></a>例题1 <a href="https://www.luogu.com.cn/problem/P3195">P3195 [HNOI2008] 玩具装箱</a></h4><p>【题意】</p><p>给定一个序列，要求将其划分成若干段，一段划分为 $[i,j]$ 的费用为 $(j-i+\sum_{k&#x3D;i}^jC_k-L)^2$（这里的 $C_k$ 为给定数组，$L$ 为给定常量）。最小化划分序列的费用和。</p><p>【解析】</p><p>朴素的转移方程为：（设 $f_i$ 表示考虑到 $i$ 的答案，$s_i$ 表示 $C_i$ 的前缀和）<br>$$<br>f_i&#x3D;\min_{1\le j&lt;i}(f_j+[i-(j+1)+s_i-s_j-L]^2)<br>$$<br>换元并化简，设 $a_i&#x3D;s_i+i，b_i&#x3D;s_i+i+L+1$。<br>$$<br>\begin{aligned}<br>&amp;f_i&#x3D;\min_{1\le j&lt;i}(f_j+[a_i-b_j]^2)\\<br>&amp;f_i&#x3D;\min_{1\le j&lt;i}(f_j+a_i^2+b_j^2-2\times a_i\times b_j)<br>\end{aligned}<br>$$<br>先不管取 $\min$，先推式子，并把只与 $j$ 有关的移到一边，尝试分离 $i$ 和 $j$。<br>$$<br>\begin{aligned}<br>f_i&amp;&#x3D;f_j+a_i^2+b_j^2-2\times a_i\times b_j\\<br>f_j+b_j^2&amp;&#x3D;f_i-a_i^2+2\times a_i\times b_j<br>\end{aligned}<br>$$<br>我们发现，如果设 $y&#x3D;f_j+b_j^2，k&#x3D;2\times a_i，x&#x3D;b_j，b&#x3D;f_i-a_i^2$，那么方程变成了一个一次函数形式 $y&#x3D;kx+b$。所以要做的就是在二维平面中找一个斜率固定的直线使 $b$ 最小。</p><p>观察数据，$y&#x3D;f_j+b_j^2$ 和 $x&#x3D;b_j$ 都单调递增，所以使用单调队列优化，时空复杂度线性。</p><p>放个单调队列斜优的板子吧。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> n,l;</span><br><span class="line"><span class="type">int</span> s[N],f[N],q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (f[j]+s[j]*s[j]+<span class="number">2</span>*l*s[j])-(f[i]+s[i]*s[i]+<span class="number">2</span>*l*s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s[j]-s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;l;</span><br><span class="line">l=l+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) cin&gt;&gt;x,s[i]=s[i<span class="number">-1</span>]+x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=s[i]+i;</span><br><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">2</span>*s[i];</span><br><span class="line"><span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[h],q[h+<span class="number">1</span>])&lt;=<span class="built_in">down</span>(q[h],q[h+<span class="number">1</span>])*k) h++;</span><br><span class="line"><span class="type">int</span> j=q[h];</span><br><span class="line">f[i]=f[j]+(s[i]-s[j]-l)*(s[i]-s[j]-l);</span><br><span class="line"><span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[t<span class="number">-1</span>],q[t])*<span class="built_in">down</span>(q[t],i)&gt;=<span class="built_in">up</span>(q[t],i)*<span class="built_in">down</span>(q[t<span class="number">-1</span>],q[t])) t--;</span><br><span class="line">q[++t]=i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此题类似的题：</p><p><a href="https://www.luogu.com.cn/problem/P3628">P3628 [APIO2010] 特别行动队</a></p><p><a href="https://www.luogu.com.cn/problem/P2365">P2365 任务安排</a></p><p><a href="https://www.luogu.com.cn/problem/P4360">P4360 [CEOI2004] 锯木厂选址</a></p><h4 id="例题2-P4072-SDOI2016-征途"><a href="#例题2-P4072-SDOI2016-征途" class="headerlink" title="例题2 P4072 [SDOI2016] 征途"></a>例题2 P4072 [SDOI2016] 征途</h4><p>【题意】</p><p>给定长度为 $n$ 的序列，将其划分为 $m$ 段，使得这 $m$ 段各自求和后的总方差最小，输出方差 $\times m^2$。</p><p>形式化地，设 $b_i&#x3D;\sum_{j&#x3D;l_i}^{r_i}a_j$，$v&#x3D;\frac{\sum_{i&#x3D;1}^m(b_i-\bar{b})^2}{m}$，求最小的 $v\times m^2$。其中 $\forall i\in [1,m-1]$，$l_{i+1}&#x3D;r_i+1$。</p><p>【解析】</p><p>推推柿子。<br>$$<br>\begin{aligned}<br>v&amp;&#x3D;\frac{\sum_{i&#x3D;1}^m(b_i-\bar{b})^2}{m}\\<br>&amp;&#x3D;\frac{(b_1-\bar{b})^2+ (b_2-\bar{b})^2+…+ (b_m-\bar{b})^2}{m}\\<br>&amp;&#x3D;\frac{m\times(\bar{b})^2+\sum_{i&#x3D;1}^mb_i^2-2\times \bar{b}\times\sum_{i&#x3D;1}^mb_i}{m}\\<br>&amp;&#x3D;\frac{m\times(\frac{\sum_{i&#x3D;1}^mb_i}{m})^2+\sum_{i&#x3D;1}^mb_i^2-2\times \frac{\sum_{i&#x3D;1}^mb_i}{m}\times\sum_{i&#x3D;1}^mb_i}{m}\\<br>&amp;&#x3D;\frac{\frac{(\sum_{i&#x3D;1}^mb_i)}{m}^2+\sum_{i&#x3D;1}^mb_i^2-2\times \frac{(\sum_{i&#x3D;1}^mb_i)^2}{m}}{m}\\<br>&amp;&#x3D;\frac{\sum_{i&#x3D;1}^mb_i^2- \frac{(\sum_{i&#x3D;1}^mb_i)^2}{m}}{m}\\<br>v\times m^2&amp;&#x3D;m\times\sum_{i&#x3D;1}^mb_i^2-(\sum_{i&#x3D;1}^mb_i)^2<br>\end{aligned}<br>$$<br>可以发现， $-(\sum_{i&#x3D;1}^mb_i)^2$ 无论怎么划分都不会变，都是 $-(\sum_{i&#x3D;1}^na_i)^2$，所以就变成最小化 $m\times\sum_{i&#x3D;1}^mb_i^2$。</p><p>考虑 DP 设 $f_{i,j}$ 表示走到 $a_i$，是第 $j$ 天的最小 $\sum_{}$（最后再乘 $m$）。那么朴素式子很好推（这里的 $s_i$ 表示 $a_i$ 的前缀和）：<br>$$<br>f_{i,j}&#x3D;\min_{1\le k&lt;i}(f_{k,j-1}+(s_i-s_k)^2)<br>$$<br>直接做是 $O(n^3)$ 的，发现这是斜率优化的经典形式，即<br>$$<br>\begin{aligned}<br>f_{i,j}&amp;&#x3D;\min_{1\le k&lt;i}(f_{k,j-1}+s_i^2+s_k^2-2\times s_i\times s_k)\\<br>f_{i,j}&amp;&#x3D;f_{k,j-1}+s_i^2+s_k^2-2\times s_i\times s_k\\<br>f_{k,j-1}+s_k^2&amp;&#x3D;f_{i,j}-s_i^2+2\times s_i\times s_k<br>\end{aligned}<br>$$</p><p>设 $y&#x3D;f_{k,j-1}+s_k^2,k&#x3D;2\times s_i,x&#x3D;s_k,b&#x3D;f_{i,j}-s_i^2$，变成一次函数形式，即可斜率优化。此题斜率优化是二维的，使用了单调队列。</p><p>放个二维斜率优化的板子。使用了辅助数组 $g$，优化成线性空间。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3005</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> s[N],q[N],f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (g[j]+s[j]*s[j])-(g[i]+s[i]*s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s[j]-s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) cin&gt;&gt;x,s[i]=s[i<span class="number">-1</span>]+x,g[i]=s[i]*s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m;++j)&#123;</span><br><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=j;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[h],q[h+<span class="number">1</span>])&lt;=<span class="built_in">down</span>(q[h],q[h+<span class="number">1</span>])*<span class="number">2</span>*s[i]) h++;</span><br><span class="line"><span class="type">int</span> p=q[h];</span><br><span class="line">f[i]=g[p]+(s[i]-s[p])*(s[i]-s[p]);</span><br><span class="line"><span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[t<span class="number">-1</span>],q[t])*<span class="built_in">down</span>(q[t],i)&gt;=<span class="built_in">up</span>(q[t],i)*<span class="built_in">down</span>(q[t<span class="number">-1</span>],q[t])) t--;</span><br><span class="line">q[++t]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) g[i]=f[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m*f[n]-s[n]*s[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此题类似的题：</p><p><a href="https://www.luogu.com.cn/problem/P3648">P3648 [APIO2014] 序列分割</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF631E</title>
      <link href="/2024/03/31/CF631E/"/>
      <url>/2024/03/31/CF631E/</url>
      
        <content type="html"><![CDATA[<h2 id="CF631E-Product-Sum"><a href="#CF631E-Product-Sum" class="headerlink" title="CF631E Product Sum"></a>CF631E Product Sum</h2><ul><li>斜率优化DP</li></ul><p><a href="https://codeforces.com/contest/631/problem/E">传送门</a></p><h3 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h3><p>模拟赛 D 题。感觉是个斜优的比较板的题。</p><p>开始写了一发错误的贪心，Wa on 9，后来改成 DP 才过。</p><p>场上过了 $5$ 个，拜谢 AK 爷 <a href="https://www.luogu.com.cn/user/593274">@Helloworld_wuyuze</a> <a href="https://www.luogu.com.cn/user/586905">@RailgunZzzz</a> <a href="https://www.luogu.com.cn/user/536743">@秦屎皇</a>。</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的序列，序列的价值定义为 $\sum_{i&#x3D;1}^na_i\times i$。允许至多一次操作，把一个元素移动到任意一个序列中的位置，求最大的序列价值。</p><p>$2\le n\le 2\times 10^5，|a_i|\le 10^6$。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>先考虑 naive 做法。对于每个 $a_i$，枚举其移动到的位置位置 $j$，每次计算贡献的变化，时间复杂度 $O(n^2)$。</p><p>具体地，分两种情况讨论。对于向前移动，即 $j&lt;i$，从 $i$ 移到 $j$ 后面，会使位于 $[j+1,i-1]$ 的元素贡献多一次，然后 $i$ 的贡献转化到了 $j+1$。</p><p>也就是 $s_{i-1}-s_{j}-(i-(j+1))\times a_i$。这里的 $s_i$ 表示 $a_i$ 的前缀和。</p><p>对于向后移动，移动到位置 $j$，会使 $[i+1,j]$ 的元素贡献少一次，再算上 $i$ 到 $j$ 的贡献。</p><p>$-(s_j-s_i)+(j-i)\times a_i$，即 $s_i-s_j+(j-i)\times a_i$。</p><p>尝试化简一下第一个式子。<br>$$<br>\begin{aligned}<br>&amp;s_{i-1}-s_{j}-(i-(j+1))\times a_i\\<br>&#x3D;&amp;s_{i-1}-s_j-(i-j-1)\times a_i\\<br>&#x3D;&amp;s_{i-1}-s_j+a_i-(i-j)\times a_i\\<br>&#x3D;&amp;s_i-s_j-(i-j)\times a_i\\<br>&#x3D;&amp;s_i-s_j+(j-i)\times a_i<br>\end{aligned}<br>$$<br>我们推导可以发现，向前移动与向后移动的式子等价。这样的话，两个转移被合并成了一个转移，方便很多。</p><p>我们还需要优化。把括号拆开，变成 $s_i-s_j+a_i\times j-a_i\times i$。发现此时的方程中只有一个与 $i,j$ 都有关的项 $a_i\times j$ 和几个只与 $i$ 或 $j$ 有关的项。是斜率优化的经典形式，此处不赘述斜优过程。</p><p>数据没有单调性，所以可以用二分凸包或者李超树维护。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>考场上没想到可以变一个式子，正反做了两遍，二分+栈。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> M=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> k,b;</span><br><span class="line"><span class="built_in">line</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">line</span>(<span class="type">int</span> _k,<span class="type">int</span> _b)&#123;</span><br><span class="line">k=_k,b=_b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k*x+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> t1 s.size()-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> t2 s.size()-2</span></span><br><span class="line">vector&lt;line&gt; s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(line x,line p1,line p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (p2.b-x.b)*(p1.k-p2.k)&lt;=(p2.b-p1.b)*(x.k-p2.k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(line x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(s.<span class="built_in">size</span>()&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">cmp</span>(x,s[t1],s[t2])) s.<span class="built_in">pop_back</span>();</span><br><span class="line">s.<span class="built_in">eb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=t1;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(s[mid].<span class="built_in">calc</span>(x)&gt;=s[mid+<span class="number">1</span>].<span class="built_in">calc</span>(x)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[r].<span class="built_in">calc</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> t1</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> t2</span></span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> n,res=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">f[i]=f[i<span class="number">-1</span>]+a[i];</span><br><span class="line">res+=i*a[i];</span><br><span class="line">&#125;</span><br><span class="line">t1.<span class="built_in">insert</span>(<span class="built_in">line</span>(<span class="number">1</span>,-f[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,-a[i]*i+f[i<span class="number">-1</span>]+t1.<span class="built_in">query</span>(a[i]));</span><br><span class="line">t1.<span class="built_in">insert</span>(<span class="built_in">line</span>(i,-f[i<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">t2.<span class="built_in">insert</span>(<span class="built_in">line</span>(-n,-f[n]));</span><br><span class="line"><span class="built_in">fo</span>(i,n<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,-a[i]*i+f[i]+t2.<span class="built_in">query</span>(-a[i]));</span><br><span class="line">t2.<span class="built_in">insert</span>(<span class="built_in">line</span>(-i,-f[i]));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans+res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赛后用李超树写了第二种实现，$k&#x3D;j,b&#x3D;-s_j$，查询 $x&#x3D;a_i$ 处的最值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> M=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> k[N],b[N],s[N],a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> k[i]*x+b[i];&#125;</span><br><span class="line"><span class="type">int</span> t[M&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">calc</span>(x,l)&gt;<span class="built_in">calc</span>(t[p],l)) t[p]=x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(x,mid)&gt;<span class="built_in">calc</span>(t[p],mid)) <span class="built_in">swap</span>(t[p],x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(x,l)&gt;<span class="built_in">calc</span>(t[p],l)) <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">calc</span>(x,r)&gt;<span class="built_in">calc</span>(t[p],r)) <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="built_in">calc</span>(t[p],x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">calc</span>(t[p],x);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">max</span>(res,<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(res,<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> n,res=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">res+=i*a[i];</span><br><span class="line">s[i]=a[i]+s[i<span class="number">-1</span>];</span><br><span class="line">k[i]=i;</span><br><span class="line">b[i]=-s[i];</span><br><span class="line"><span class="built_in">update</span>(<span class="number">1</span>,-M,M,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line"><span class="type">int</span> tmp=<span class="built_in">query</span>(<span class="number">1</span>,-M,M,a[i]);</span><br><span class="line">ans=<span class="built_in">max</span>(ans,s[i]-a[i]*i+tmp);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans+res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>完结撒花！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AT_dp</title>
      <link href="/2024/03/31/AT_dp/"/>
      <url>/2024/03/31/AT_dp/</url>
      
        <content type="html"><![CDATA[<h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>DP 太菜了，刷 AT 经典 DP，前面的比较简单，从 J 开始吧 qwq</p><hr><h3 id="AT-dp-J"><a href="#AT-dp-J" class="headerlink" title="AT_dp_J"></a>AT_dp_J</h3><ul><li>期望 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_j">传送门</a></p><p>注意到 $a_i\leq3$，所以状态应该跟 $a_i$ 有关。考虑设 $f_{a,b,c,d}$ 表示有 $a$ 种剩余 $3$ 个的寿司，$b$ 种剩余 $2$ 个的寿司……</p><p>$$f_{a,b,c,d}&#x3D;1+\frac{a}{n}f_{a-1,b+1,c,d}+\frac{b}{n}f_{a,b-1,c+1,d}+\frac{c}{n}f_{a,b,c-1,d+1}+\frac{d}{n}f_{a,b,c,d}$$<br>整理并可得<br>$$f_{a,b,c,d}&#x3D;\frac{n}{n-d}+\frac{a}{n-d}f_{a-1,b+1,c,d}+\frac{b}{n-d}f_{a,b-1,c+1,d}+\frac{c}{n-d}f_{a,b,c-1,d+1}$$</p><p>这样是四维的，发现 $d&#x3D;n-(a+b+c)$，于是变成 $3$ 维，可以 $O(n^3)$ 的 DP，得到最终方程</p><p>$$f_{a,b,c}&#x3D;\frac{n}{a+b+c}+\frac{a}{a+b+c}f_{a-1,b+1,c}+\frac{b}{a+b+c}f_{a,b-1,c+1}+\frac{c}{a+b+c}f_{a,b,c-1}$$</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) cin&gt;&gt;x,a[x]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;++k)</span><br><span class="line">      <span class="keyword">if</span>(i+j+k)&#123;</span><br><span class="line">        <span class="type">double</span> p=i+j+k;</span><br><span class="line">        <span class="keyword">if</span>(i) f[i][j][k]+=(<span class="number">1.0</span>*i/p*f[i<span class="number">-1</span>][j+<span class="number">1</span>][k]);</span><br><span class="line">        <span class="keyword">if</span>(j) f[i][j][k]+=(<span class="number">1.0</span>*j/p*f[i][j<span class="number">-1</span>][k+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(k) f[i][j][k]+=(<span class="number">1.0</span>*k/p*f[i][j][k<span class="number">-1</span>]);</span><br><span class="line">        f[i][j][k]+=<span class="number">1.0</span>*n/p;</span><br><span class="line">      &#125;</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;f[a[<span class="number">3</span>]][a[<span class="number">2</span>]][a[<span class="number">1</span>]]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong>给点启示：</strong> DP 优化的一个思路：合并等价状态、消除无用状态（这个有点像百钱买百只因）。</p><hr><h3 id="AT-dp-K"><a href="#AT-dp-K" class="headerlink" title="AT_dp_K"></a>AT_dp_K</h3><ul><li>博弈论</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_k">传送门</a></p><p>简单题。设 $f_i$ 表示剩余 $i$ 个石子时当前操作者的胜负，那么显然 $f_0&#x3D;0$。考虑转移，用点博弈论的知识，必败状态后继的所有状态都是必胜状态，那么写出转移 $f_i&#x3D;\max{[f_{i-a_j}&#x3D;0],1\le j\le n}$</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i-a[j]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    f[i]|=(!f[i-a[j]]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-L"><a href="#AT-dp-L" class="headerlink" title="AT_dp_L"></a>AT_dp_L</h3><ul><li>区间 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_l">传送门</a></p><p>一个经典的 trick。设 $f_{i,j}$ 表示序列还剩下 $[i,j]$ 时，$X-Y$ 的最大值。转移要分两种情况，因为是两个人轮流取，一个会使答案增大，另一个使答案变小。</p><p>具体地，当前操作次数为偶数，先手取改变 $X$，$f_{i,j}&#x3D;\max(f_{i+1,j}+a_i,f_{i,j-1}+a_j)$。</p><p>否则后手取，$f_{i,j}&#x3D;\min(f_{i+1,j}-a_i,f_{i,j-1}-a_j)$。</p><p>答案即为 $f_{1,n}$，时间复杂度 $O(n^2)$。</p><p>与此题很类似的，还有 <a href="https://atcoder.jp/contests/tdpc/tasks/tdpc_game">AT_tdpc_game</a>，可以左转<a href="https://www.luogu.com.cn/article/8lch1g1m">我的题解</a>。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;++len)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;++i)&#123;</span><br><span class="line"><span class="type">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>((n-len)&amp;<span class="number">1</span>) f[i][j]=<span class="built_in">min</span>(f[i+<span class="number">1</span>][j]-a[i],f[i][j<span class="number">-1</span>]-a[j]);</span><br><span class="line"><span class="keyword">else</span> f[i][j]=<span class="built_in">max</span>(f[i+<span class="number">1</span>][j]+a[i],f[i][j<span class="number">-1</span>]+a[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题还有一个贪心的思路，可以做到线性。</p><p>考虑对于每三个数，如果中间的最大，那么一定是先手取两边，后手取中间，这样把序列中的这样结构的三个数贡献合并成两边减中间，此时序列一定先减后增，直接贪心即可。</p><p>形式化地，$\forall a_{i-1},a_i,a_{i+1}(1&lt;i&lt;n)，s.t.\ a_i\ge a_{i-1}$ 且 $a_i\ge a_{i+1}$，将其改为 $f_i&#x3D;a_{i-1}+a_{i+1}-a_i$，剩余的不变。</p><p>这个做法代码不贴了。</p><p><strong>启示：</strong> 很多这种类似博弈两个人取数的题都可以转化成这种 DP 的状态设计，算是一个区间 DP 的套路了。</p><hr><h3 id="AT-dp-M"><a href="#AT-dp-M" class="headerlink" title="AT_dp_M"></a>AT_dp_M</h3><ul><li>前缀和优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_m">传送门</a></p><p>首先考虑一下朴素 DP，设 $f_{i,j}$ 表示进行到 $i$，已经分出去了 $j$ 块糖的方案数。那么显然 $f_{i,j}&#x3D;\sum_{k&#x3D;0}^{a_i}f_{i-1,k}$。每次转移都需要扫一遍，时间复杂度 $O(nk^2)$ 。</p><p>但是发现每一层 DP 的状态只与上一层有关，所以可以直接使用前缀和优化，时间复杂度 $O(nk)$。</p><p>代码不贴了，注意数组下标，前缀和容易 RE。</p><p><strong>启示：</strong> 当发现 DP 转移时方程只与上一层有关时，可以考虑用一些求和数据结构优化（比如前缀和）。</p><hr><h3 id="AT-dp-N"><a href="#AT-dp-N" class="headerlink" title="AT_dp_N"></a>AT_dp_N</h3><ul><li>区间 DP</li><li>前缀和优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_n">传送门</a></p><p>区间 DP 傻题，和 <a href="https://www.luogu.com.cn/problem/P1775">石子合并</a> 一模一样。</p><p>需要注意的一点是，朴素直接计算贡献是 $O(n^4)$ 的，使用前缀和优化到 $O(n^3)$。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;++k)</span><br><span class="line">      f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-O"><a href="#AT-dp-O" class="headerlink" title="AT_dp_O"></a>AT_dp_O</h3><ul><li>状压 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_o">传送门</a></p><p><del>拜谢老头。</del> 看数据范围考虑状压 DP。发现一个合法的方案一定满足每一行、每一列只选一个 $1$，所以设 $f_{i,S}$ 表示进行到第 $i$ 行，此时选点集合为 $S$，复杂度 $O(n^22^n)$ 会 T 掉。但观察可知已知 $S$ 即可确定 $i$，是 $S$ 中 $1$ 的个数，所以可以直接设为 $f_S$，复杂度 $O(n2^n)$。</p><p>Tips：popcount 用来计算二进制 $1$ 的个数。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>;S&lt;(<span class="number">1</span>&lt;&lt;n);++S)&#123;</span><br><span class="line"><span class="type">int</span> k=__builtin_popcount(S);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(S&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;a[k][j])</span><br><span class="line">f[S|(<span class="number">1</span>&lt;&lt;j)]=(f[S|(<span class="number">1</span>&lt;&lt;j)]+f[S])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-P"><a href="#AT-dp-P" class="headerlink" title="AT_dp_P"></a>AT_dp_P</h3><ul><li>树形 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_p">传送门</a></p><p><del>没有舞会的上司。</del> 树上 DP 简单题。设 $f_{u,0&#x2F;1}$ 表示当前点为 $u$，当前点是否染成黑色。那么对于 $f_{u,0}$，它的子节点染成什么颜色对其没有限制，所以 $f_{u,0}&#x3D;\prod_{v\in u}(f_{v,0}+f_{v,1})$；而对于 $f_{u,1}$，子节点不能还是黑色，所以 $f_{u,1}&#x3D;\prod_{v\in u}f_{v,1}$。</p><p>最后自底向上 dfs 即可，答案为 $f_{1,0}+f_{1,1}$，线性复杂度。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">f[u][<span class="number">0</span>]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line">f[u][<span class="number">0</span>]=f[u][<span class="number">0</span>]*(f[v][<span class="number">0</span>]+f[v][<span class="number">1</span>])%mod;</span><br><span class="line">f[u][<span class="number">1</span>]=f[u][<span class="number">1</span>]*f[v][<span class="number">0</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-Q"><a href="#AT-dp-Q" class="headerlink" title="AT_dp_Q"></a>AT_dp_Q</h3><ul><li>数据结构优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_q">传送门</a></p><p>最长上升子序列加权版。</p><p>发现朴素的 DP 就是 朴素的 LIS，设 $f_i$ 表示以 $i$ 为结尾的最大答案，只是把每次的贡献从 $1$ 变成 $a_i$ 了。但这样做是 $O(n^2)$ 的，考虑每次都是选择 $h_j&lt;h_i$ 的最大 $f_j$，这样可以使用数据结构优化。$f_i&#x3D;a_i+\max{f_j,1\le j&lt;i,h_j&lt;h_i}$。需要支持单点修，区间求最值，复杂度 $O(n\ logn)$。</p><p>这里使用了树状数组，因为要求的是前缀最大值，而且单点修改，树状数组比线段树更容易实现。</p><p><strong>Code:</strong></p><p>树状数组部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) c[i]=<span class="built_in">max</span>(c[i],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res=<span class="built_in">max</span>(res,c[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">ll x,a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">x=<span class="built_in">query</span>(h[i]<span class="number">-1</span>)+a;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,x);</span><br><span class="line"><span class="built_in">add</span>(h[i],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 对于一个 DP 转移方程，如果转移复杂度很高，要求的东西只与之前的值有关，可以尝试数据结构优化。</p><hr><h3 id="AT-dp-R"><a href="#AT-dp-R" class="headerlink" title="AT_dp_R"></a>AT_dp_R</h3><ul><li>矩阵加速 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_r">传送门</a></p><p>题目要求路径长度为 $k$ 的路径数，朴素的 DP 是直接设 $f_{k,i,j}$ 表示从 $i$ 到 $j$ 路径长度为 $k$ 的方案数，然后转移<br>$$f_{k,i,j}&#x3D;\sum_{u&#x3D;1}^nf_{k-1,i,u}+f_{1,u,j}$$</p><p>发现这样转移复杂度会爆炸，因为 $k$ 是 $10^{18}$ 量级的，但是这个方程你会发现跟最短路中的 Floyd 非常像，这就是个显然的矩阵乘法形式，于是想到矩阵优化，对于每一个距离矩阵 $f_i$，$f_i&#x3D;f_{i-1}\times f_1$，那么直接快速幂即可，答案为 $f_1^{k}$ 的所有元素和。时间复杂度 $O(n^3\ logk)$，可以通过。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">ll a[N][N];</span><br><span class="line"><span class="built_in">matrix</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">&#125;a;</span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="type">const</span> matrix&amp;a,<span class="type">const</span> matrix&amp;b)&#123;</span><br><span class="line">matrix res;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;++k)</span><br><span class="line">res.a[i][j]=(res.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">ksm</span><span class="params">(matrix a,ll k)</span></span>&#123;</span><br><span class="line">matrix res;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) res.a[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">a=a*a;</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 当一个线性 DP 发现转移数量非常多（一般达到了 $10^9$ 以上的量级），可以考虑矩阵优化。</p><hr><h3 id="AT-dp-S"><a href="#AT-dp-S" class="headerlink" title="AT_dp_S"></a>AT_dp_S</h3><ul><li>数位 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_s">传送门</a></p><p>看数据范围超级大想数位 DP。考虑记录 $3$ 个状态：当前位、是否达到最高位限制、当前数各位和模 $D$ 结果，边界条件是最后模 $D$ 为 $0$ 了答案加一。</p><p>具体地，设 $f_{pos,m,limit}$ 表示当前考虑到第 $pos$ 位（倒序从最高位往后找），各个位上的和模 $D$ 为 $m$，是否顶到上界。边界条件 $f_{0,0,0&#x2F;1}&#x3D;1$，转移时<br>$$f_{pos,m,limit}&#x3D;\sum f_{pos-1,(m+i)%D,limit&amp;&amp;[i&#x3D;n]}$$</p><p>注意，$i$ 表示当前枚举的下一位，$n$ 表示下一位的最大值。</p><p><strong>警钟：</strong> 最后的答案要 -1，因为 $0$ 不算，但减一以后可能会变成负数（全为 $0$ 的情况），所以还要加 mod 再对 mod 取模。</p><p>代码用记忆化搜索实现（因为太菜了不会递推），其实 $f$ 的第三维 $limit$ 可以不用设，但为了清晰还是写了。</p><p><strong>Code:</strong></p><p>记忆化搜索部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> m,<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> (m==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(~f[pos][m][limit]) <span class="keyword">return</span> f[pos][m][limit];</span><br><span class="line"><span class="type">int</span> n=limit?a[pos]:<span class="number">9</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i) res=(res+<span class="built_in">dfs</span>(pos<span class="number">-1</span>,(m+i)%d,limit&amp;&amp;(i==n)))%mod;</span><br><span class="line"><span class="keyword">return</span> f[pos][m][limit]=res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i) a[l-i]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">cout&lt;&lt;(<span class="built_in">dfs</span>(l,<span class="number">0</span>,<span class="number">1</span>)<span class="number">-1</span>+mod)%mod;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 当计算某些数的数量，且范围很大，考虑数位 DP，记忆化搜索可以便捷实现，注意是否要考虑前导零。</p><hr><h3 id="AT-dp-T"><a href="#AT-dp-T" class="headerlink" title="AT_dp_T"></a>AT_dp_T</h3><ul><li>前缀和优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_t">传送门</a></p><p>考虑设 $f_{i,j}$ 表示确定前 $i$ 个数，其中第 $i$ 个是 $j$ 的方案数，那么初始状态 $f_{1,1}&#x3D;1$。对于转移分两种情况讨论，如果 $s_i$ 是小于号，那么 $f_{i,j}&#x3D;\sum_{k&#x3D;1}^{j-1}f_{i-1,k}$，否则 $f_{i,j}&#x3D;\sum_{k&#x3D;j}^{i-1}f_{i-1,k}$。</p><p>朴素的转移是 $O(n^3)$ 的。发现又是只与上一层状态有关，可以通过前缀和优化为 $O(n^2)$，于是可以通过此题。</p><p>注意一下大于小于号与下标对应关系 qwq。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">1</span>][<span class="number">1</span>]=s[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(ch[i]==<span class="string">&#x27;&lt;&#x27;</span>) f[i][j]=s[i<span class="number">-1</span>][j<span class="number">-1</span>]%mod;</span><br><span class="line"><span class="keyword">else</span> f[i][j]=(f[i][j]+s[i<span class="number">-1</span>][i<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">s[i][j]=(s[i][j<span class="number">-1</span>]+f[i][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=(ans+f[n][i])%mod;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 与 $M$ 题相同。</p><hr><h3 id="AT-dp-U"><a href="#AT-dp-U" class="headerlink" title="AT_dp_U"></a>AT_dp_U</h3><ul><li>状压 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_u">传送门</a></p><p>看数据范围，显然是状压。考虑设 $f_S$ 表示已选兔子集合状态为 $S$ 的答案，设 $V_T$ 表示一组中的兔子状态为 $T$ 的贡献，那么可以写出转移方程 $f_S&#x3D;\max_{T\in S}{f_T+V_{\complement_ST}}$。</p><p>那其实就做完了，先枚举集合并预处理数组 $V$，复杂度 $O(2^nn^2)$，然后枚举子集转移，复杂度 $O(3^n)$，于是做完了。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);++s)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((s&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;((s&gt;&gt;j)&amp;<span class="number">1</span>))&#123;</span><br><span class="line">                v[s]+=a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[s]=v[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);++s)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> cs=s;cs&gt;<span class="number">0</span>;cs=(cs<span class="number">-1</span>)&amp;s)&#123;</span><br><span class="line">        f[s]=<span class="built_in">max</span>(f[s],f[cs]+v[s^cs]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 枚举子集复杂度 $O(3^n)$，数据范围在 $20$ 以内有限考虑状压 DP。</p><hr><h3 id="AT-dp-V"><a href="#AT-dp-V" class="headerlink" title="AT_dp_V"></a>AT_dp_V</h3><ul><li>树形 DP</li><li>换根 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_v">传送门</a></p><p>考虑树形 DP。设 $g_u$ 表示 $u$ 染成黑点，$u$ 的子树内的答案，转移的话可以 $g_u&#x3D;\prod_{v\in u}(g_v+1)$，表示对于每个儿子 $v$，都计算 $v$ 子树内的答案 $g_v$，以及 $v$ 染成白色，其子树全是白色的 $1$。这样总体做下来一次是 $O(n)$ 的。</p><p>但是题目要求输出每一个点为根的答案，一次 dfs 只能计算一个点为根的答案，总体复杂度 $O(n^2)$ 不能接受，所以考虑使用换根 DP，在第二次 dfs 中求出所有点的答案。</p><p>所以考虑设 $f_u$ 表示将 $u$ 染成黑色，$u$ 和其子树外的点所得的答案，那么显然对于每个点，最终的答案就是 $f_u\times g_u$。转移方程为 $f_v&#x3D;f_{u}+\frac{g_{u}}{g_v+1}+1$。这表示父亲 $u$ 的答案加上 $u$ 除 $v$ 的儿子的答案再加上白点的 $1$。时间复杂度 $O(n)$。</p><p>本来这个题已经快乐地做完了，但问题在于答案需要取模，模数不一定是质数。这就十分棘手，因为你无法直接算逆元。所以考虑对于每个点 $u$ 记一个前缀积 $pre$ 和后缀积 $suf$，在第一遍 dfs 中预处理。这样转移时除法就变成了挖去此点的前后缀积。</p><p>形式化地，$f_v&#x3D;f_u+pre_{u,i-1}\times suf_{u,i+1}+1$。其中 $i$ 表示 $v$ 是第几个儿子。代码中因为前后缀积的下标从 $0$ 开始，所以变成了 $pre_{u,i-2}\times suf_{u,i}$，本质上没有区别。</p><p><strong>Code:</strong></p><p>注意开 long long 和特殊的 $f_1&#x3D;1$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">g[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">g[u]=g[u]*(g[v]+<span class="number">1</span>)%mod;</span><br><span class="line">pre[u].<span class="built_in">push_back</span>(g[v]+<span class="number">1</span>);</span><br><span class="line">suf[u].<span class="built_in">push_back</span>(g[v]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l=pre[u].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;l;++i) pre[u][i]=<span class="number">1ll</span>*pre[u][i<span class="number">-1</span>]*pre[u][i]%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i) suf[u][i]=<span class="number">1ll</span>*suf[u][i+<span class="number">1</span>]*suf[u][i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=pre[u].<span class="built_in">size</span>(),cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(l==<span class="number">1</span>) f[v]=f[u]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">1</span>) f[v]=f[u]*suf[u][<span class="number">1</span>]%mod+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt==l) f[v]=f[u]*pre[u][cnt<span class="number">-2</span>]%mod+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> f[v]=f[u]*pre[u][cnt<span class="number">-2</span>]%mod*suf[u][cnt]%mod+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 换根 DP 的套路。</p><blockquote><p>$1.$ 指定某个节点为根节点（一般为 $1$）。</p><p>$2.$ 第一次搜索完成预处理，同时得到该节点的解。</p><p>$3.$ 第二次搜索进行换根 DP，由已知节点推出相邻节点。</p></blockquote><hr><h3 id="AT-dp-W"><a href="#AT-dp-W" class="headerlink" title="AT_dp_W"></a>AT_dp_W</h3><ul><li>数据结构优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_w">传送门</a></p><p>跟 NOIP T4 有点像对吧。先用一个经典的 trick，把一段区间的贡献转化为右端点的贡献，排序后只有到右端点才计算贡献，用一个结构体存储区间信息。</p><p>设 $f_{i,j}$ 表示进行到位置 $i$，最后一个 $1$ 在位置 $j$ 的答案。考虑转移，如果 $i&#x3D;j$，也即在最后一个位置放了 $1$，那么 $f_{i,i}&#x3D;\max_{j&#x3D;1}^{i-1}f_{i-1,j}$。</p><p>否则 $i\neq j$，考虑每一个转移相对于 $i-1$ 都是加上了右端点在 $i$ 且左端点包含 $j$ 的答案。<br>$$f_{i,j}&#x3D;f_{i-1,j}+\sum_{l_k\le j,r_k&#x3D;i} a_k$$</p><p>这样朴素转移复杂度是 $O(n^2)$ 的，必须优化。考虑当  $i&#x3D;j$，查询了最值，对于 $i\neq j$，所有右端点 $i$ 的区间贡献都要累加到 DP 数组里，这是区间加的操作。于是可以使用线段树维护 DP 数组优化一下转移，这样的复杂度变成了 $O(n\ log n)$。</p><p>空间复杂度部分，可以直接压到一维。注意每次的答案要与 $0$ 取 $\max$。</p><p><strong>Code:</strong></p><p>线段树部分就不放了，纯板子，查询是查询整体最值。</p><p>代码中的 $v_i$ 表示第 $i$ 个命令。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="built_in">update</span>(<span class="number">1</span>,i,i,<span class="built_in">query</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> u:v[i]) <span class="built_in">update</span>(<span class="number">1</span>,u.l,i,u.w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-X"><a href="#AT-dp-X" class="headerlink" title="AT_dp_X"></a>AT_dp_X</h3><ul><li>背包 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_x">传送门</a></p><p>我们先考虑最优策略。对于两个物品 $i$，$j$，如果 $i$ 放到 $j$ 下面，那么 $i$ 上面除了 $j$ 以外还能放 $s_i-w_j$ 重量的物品；如果 $j$ 放到 $i$ 下面，就能放 $s_j-w_i$ 重量的物品。考虑上面能放的更多那就更优，即 $i$ 放 $j$ 下面当且仅当 $s_i-w_j&gt;s_j-w_i$，移项得 $s_i+w_i&gt;s_j+w_j$。所以我们根据 $s+w$ 排序，这样放一定最优。</p><p>接下来 01 背包即可，答案为 $\max{f_i}$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.w+a.s&lt;b.w+b.s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">20005</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i].w&gt;&gt;a[i].s&gt;&gt;a[i].v;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=a[i].s;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">f[j+a[i].w]=<span class="built_in">max</span>(f[j+a[i].w],f[j]+a[i].v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20000</span>;++i) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-Y"><a href="#AT-dp-Y" class="headerlink" title="AT_dp_Y"></a>AT_dp_Y</h3><ul><li>组合数学</li><li>DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_y">传送门</a></p><p>H 题的加强版。</p><p>考虑设 $f_{i,j}$ 表示从 $(1,1)$ 走到 $(i,j)$，不经过障碍的方案数。先考虑没有障碍的简单情况，那么方案数就是 $\large \binom{i+j-2}{i-1}$，即选择 $i-1$ 步向下，剩下的向右。那么想想有障碍的转移，发现走到一个点的方案等于上述组合数减所有其左上角障碍的 $f$。想想为什么，因为所有会经过障碍的路都在左上角的障碍的 $f$ 里面。形式化地，$f_{i,j}&#x3D;calc(i,j)-\sum_{x&lt;&#x3D;i,y&lt;&#x3D;j,(x,y)\ne(i,j)}calc(x,y)$。这里的 $calc$ 就是指带入上面的组合数公式。所以处理一下组合数，时间复杂度 $O(n^2)$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a[M];</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">a=a*a%mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll f[M],fac[N&lt;&lt;<span class="number">1</span>],inv[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2e5</span>;++i) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">inv[<span class="number">200000</span>]=<span class="built_in">ksm</span>(fac[<span class="number">200000</span>],mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2e5</span><span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;h&gt;&gt;w&gt;&gt;n;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i].fi&gt;&gt;a[i].se;</span><br><span class="line">n++;</span><br><span class="line">a[n]=<span class="built_in">make_pair</span>(h,w);</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">f[i]=<span class="built_in">C</span>(a[i].fi+a[i].se<span class="number">-2</span>,a[i].fi<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j].se&gt;a[i].se) <span class="keyword">continue</span>;</span><br><span class="line">f[i]=(f[i]-f[j]*<span class="built_in">C</span>(a[i].fi-a[j].fi+a[i].se-a[j].se,a[i].fi-a[j].fi)%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-Z"><a href="#AT-dp-Z" class="headerlink" title="AT_dp_Z"></a>AT_dp_Z</h3><ul><li>斜率优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_z">传送门</a></p><p>a，b 题加强版。转移显然，设 $f_i$ 表示走到 $i$ 时的最小花费，那 $f_i&#x3D;\min_{1\le j&lt;i}(f_j+(h_i-h_j)^2+C)$。 </p><p>拆开式子变成 $f_i&#x3D;f_j+h_i^2+h_j^2-2\times h_i\times h_j+C$。</p><p>移项，把 $j$ 分离，$f_j+h_j^2&#x3D;f_i-h_i^2-C+2\times h_i\times h_j$。</p><p>设 $y_j&#x3D;f_j+h_j^2$，$k_i&#x3D;2\times h_i$，$x_j&#x3D;h_j$，$b_i&#x3D;f_i-h_i^2$，变成了一次函数形式，可以斜率优化。</p><p>题目要求最小值，维护下凸壳，又发现了 $y_j$ 和 $x_j$ 保证单调递增，所以使用单调队列维护，线性。</p><p>斜率优化可以左转<a href="https://jkyak.github.io/2024/03/31/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/">我的斜率优化详解</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">y</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f[i]+h[i]*h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">y</span>(i)-<span class="built_in">y</span>(j))/(h[i]-h[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;h[i];</span><br><span class="line">he=t=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(he&lt;t&amp;&amp;<span class="built_in">calc</span>(q[he],q[he+<span class="number">1</span>])&lt;=<span class="number">2</span>*h[i]) he++;</span><br><span class="line"><span class="type">int</span> j=q[he];</span><br><span class="line">f[i]=f[j]+(h[i]-h[j])*(h[i]-h[j])+c;</span><br><span class="line"><span class="keyword">while</span>(he&lt;t&amp;&amp;<span class="built_in">calc</span>(q[t<span class="number">-1</span>],q[t])&gt;=<span class="built_in">calc</span>(q[t],i)) t--;</span><br><span class="line">q[++t]=i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>至此，<strong>26</strong> 个 AT_dp 已经结束，这其中几乎包含了所有比较简单的 DP 类型，获益匪浅。</p><p>完结撒花！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
