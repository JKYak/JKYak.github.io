<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kketchup的小窝</title>
  
  <subtitle>My Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-08-11T12:41:31.301Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JKY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>长链剖分优化DP</title>
    <link href="http://example.com/2024/08/11/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86%E4%BC%98%E5%8C%96DP/"/>
    <id>http://example.com/2024/08/11/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86%E4%BC%98%E5%8C%96DP/</id>
    <published>2024-08-11T10:27:21.187Z</published>
    <updated>2024-08-11T12:41:31.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="长链剖分"><a href="#长链剖分" class="headerlink" title="长链剖分"></a>长链剖分</h2><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>长剖跟树剖很像，都是链剖分形式。区别在于，<strong>重儿子</strong>在树剖中定义为子树大小最大的儿子，而长剖中定义为子树深度最大的儿子。顺理成章地，不是重儿子的就是轻儿子，指向重儿子的边为<strong>重边</strong>，其余为轻边。重边所构成的链成为重链（为区别树剖与长剖，下文使用<strong>长链</strong>），特殊地，单节点也可作为一条重链。</p><p>接下来说说长剖的性质。</p><ul><li>性质一：树上所有长链长度和 $O(n)$</li></ul><p>比较好理解，因为一个点只能存在于一条长链。</p><ul><li>性质二：任意节点通过长链跳到根，最多跳 $O(\sqrt n)$ 次</li></ul><p>因为每次跳到的长链都会比原来的长链长（否则长链就是这个了），所以最坏情况长链长度从 $1$ 到 $\sqrt n$，总共跳 $O(\sqrt n)$ 次。</p><h4 id="树上-k-级祖先"><a href="#树上-k-级祖先" class="headerlink" title="树上 k 级祖先"></a>树上 k 级祖先</h4><p>法 $1$：倍增预处理，复杂度 $O(n\log n)-O(\log n)$。</p><p>法 $2$：树剖，跳重链，复杂度 $O(n)-O(\log n)$，加二分可以做到 $O(n\log n)-O(\log\log n)$。</p><p>但还不够优秀！长剖做法可以做到 $O(n\log n)-O(1)$。</p><p>具体地，我们先倍增预处理 $2^k$ 祖先，还有每个长链顶点向上向下长链长度（记为 $d$）的数组。也就是 $v_{i,j}$ 表示 $i$ 点（是一条长链的顶点）向上&#x2F;向下 $j$ 个的点。</p><p>对于 $k$，找到最大的 $i$，使得 $2^i\le k&lt;2^{i+1}$。此时从 $x$ 跳到其 $2^i$ 的父亲 $y$，还需要跳 $k-2^i$ 级。我们记 $y$ 所在长链长度为 $d$，那么 $k-2^i&lt;2^i\le d$。</p><p>因为**任意点的 $k$ 级祖先所在长链长度大于等于 $k$**，这一点容易发现，反证得若不满足，则祖先到儿子这条链更优。</p><p>于是我们跳到 $y$ 的链顶，用预处理的数组求剩下的部分。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,q,rt;</span><br><span class="line">ll res,ans;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ui unsigned int</span></span><br><span class="line">ui s;</span><br><span class="line"><span class="function">ui <span class="title">get</span><span class="params">(ui x)</span></span>&#123;</span><br><span class="line">    x^=x&lt;&lt;<span class="number">13</span>;</span><br><span class="line">    x^=x&gt;&gt;<span class="number">17</span>;</span><br><span class="line">    x^=x&lt;&lt;<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> s=x; </span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],v1[N],v2[N];</span><br><span class="line"><span class="type">int</span> son[N],fa[N][<span class="number">21</span>],len[N],top[N],mx[N],d[N],lg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    d[u]=d[f]+<span class="number">1</span>,mx[u]=d[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">19</span>;++i) fa[u][i+<span class="number">1</span>]=fa[fa[u][i]][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        fa[v][<span class="number">0</span>]=u,<span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span>(mx[v]&gt;mx[son[u]]) son[u]=v,mx[u]=mx[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    top[u]=t,len[u]=mx[u]-d[top[u]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u]) <span class="keyword">if</span>(v!=fa[u][<span class="number">0</span>]&amp;&amp;v!=son[u]) <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> t=lg[k];</span><br><span class="line">    k-=(<span class="number">1</span>&lt;&lt;t),x=fa[x][t];</span><br><span class="line">    k-=d[x]-d[top[x]],x=top[x];</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> k&gt;<span class="number">0</span>?(v1[x][k<span class="number">-1</span>]):(v2[x][-k<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line">    lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) rt=i;</span><br><span class="line">        <span class="keyword">else</span> e[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(rt,<span class="number">0</span>),<span class="built_in">dfs2</span>(rt,rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=top[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,x=i;j&lt;=len[i];++j)&#123;</span><br><span class="line">            x=fa[x][<span class="number">0</span>];</span><br><span class="line">            v1[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,y=i;j&lt;=len[i];++j)&#123;</span><br><span class="line">            y=son[y];</span><br><span class="line">            v2[i].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x=<span class="number">0</span>,k=<span class="number">0</span>;i&lt;=q;++i)&#123;</span><br><span class="line">        x=(<span class="built_in">get</span>(s)^res)%n+<span class="number">1</span>,k=(<span class="built_in">get</span>(s)^res)%d[x];</span><br><span class="line">        res=<span class="built_in">query</span>(x,k);</span><br><span class="line">        ans^=i*res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;长链剖分&quot;&gt;&lt;a href=&quot;#长链剖分&quot; class=&quot;headerlink&quot; title=&quot;长链剖分&quot;&gt;&lt;/a&gt;长链剖分&lt;/h2&gt;&lt;h4 id=&quot;基本定义&quot;&gt;&lt;a href=&quot;#基本定义&quot; class=&quot;headerlink&quot; title=&quot;基本定义&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演</title>
    <link href="http://example.com/2024/07/01/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://example.com/2024/07/01/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</id>
    <published>2024-07-01T11:48:30.653Z</published>
    <updated>2024-07-11T14:13:55.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>从听说莫反高高仰望，到现在总算理解了皮毛，不禁慨叹。所以，我要珍惜，不留遗憾。</p><p>尝试写一篇能让初学莫反的新人可以看懂的文章。</p><p>感受推柿子的魅力吧！</p><p><strong>一些约定：</strong></p><p>$\mu(x)$ 表示莫比乌斯函数。</p><p>$(x,y)$ 表示 $\gcd(x,y)$，即最大公约数。</p><p>$\left \lfloor a \right \rfloor$ 表示向下取整，即取小于 $a$ 的第一个整数。</p><p>$a|b$ 表示整除，$a$ 整除 $b$，也就是 $a$ 是 $b$ 的因数。</p><p>$[p]$ 表示若 $p$ 为真则为 $1$，否则为 $0$。</p><p>在推式子时，默认取 $n\le m$。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>莫反，就是通过反演形式更加方便地求函数的值。</p><p>原函数 $f$ 有一和函数 $F$，且 $F(n)&#x3D;\displaystyle\sum_{d|n}f(d)$。我们的目标就是通过 $F$ 求 $f$。</p><p>先写几项</p><p>$$<br>\begin{aligned}<br>F(1)&amp;&#x3D;f(1)\\<br>F(2)&amp;&#x3D;f(1)+f(2)\\<br>F(3)&amp;&#x3D;f(1)+f(3)\\<br>F(4)&amp;&#x3D;f(1)+f(2)+f(4)<br>\end{aligned}<br>$$</p><p>我们类似解方程，用 $F$ 表示 $f$。</p><p>$$<br>\begin{aligned}<br>f(1)&amp;&#x3D;F(1)\\<br>f(2)&amp;&#x3D;F(2)-F(1)\\<br>f(3)&amp;&#x3D;F(3)-F(1)\\<br>f(4)&amp;&#x3D;F(4)-F(2)<br>\end{aligned}<br>$$</p><p>我们发现，$f(n)$ 可以表示为若干 $\pm F(\frac{n}{d})$ 的和（其中 $d|n$），所以我们将 $f(n)$ 表示为 $\displaystyle\sum_{d|n}\mu(d)F(\frac{n}{d})$。$\mu$ 函数是我们定义的系数函数，有 $-1,0,1$ 三种取值。</p><p>手推可得，$\mu(1)&#x3D;1,\mu(2)&#x3D;-1,\mu(3)&#x3D;-1,\mu(4)&#x3D;0$。</p><h2 id="莫比乌斯反演-1"><a href="#莫比乌斯反演-1" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>让我们寻找一些 $\mu$ 函数的性质。</p><p>我们发现，如果 $p\in prime$，$F(p)&#x3D;f(p)+f(1)$，则 $f(p)&#x3D;F(p)-f(1)&#x3D;\mu(1)F(p)+\mu(p)F(1)$。可以得到 $\mu(p)&#x3D;-1,\mu(1)&#x3D;1$。</p><p>而当 $p\in prime$，$F(p^2)&#x3D;f(1)+f(p)+f(p^2)$，得 $f(p^2)&#x3D;F(p^2)-F(1)&#x3D;\mu(1)F(p^2)+\mu(p^2)F(1)$。可以得到 $\mu(p^2)&#x3D;0$。这个结论可以推广到 $\mu(p^k)&#x3D;0$。</p><p>所以我们终于得到了 $\mu$ 函数的定义。</p><p>$$\mu(n)&#x3D;\begin{cases}<br>1,\ n&#x3D;1\\<br>(-1)^k,\ n\ 是\ k\ 个不同质因子的积（即没有平方因子） \\<br>0,\ n\ 有平方因子<br>\end{cases}$$</p><p>所以我们可以线性筛出 $\mu$ 函数的值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) prime[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">        vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">            mu[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mu[i*prime[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面讲解一些 $\mu$ 函数的性质，方便后面推式子。</p><ul><li>性质 $1$</li></ul><p>$\mu$ 函数是积性函数，即 $a,b$ 互质时 $\mu(ab)&#x3D;\mu(a)\mu(b)$。</p><blockquote><p>简单证明：</p><p>第一种情况：$a&#x3D;1,\mu(a)&#x3D;1$。</p><p>此时 $ab&#x3D;b,\mu(ab)&#x3D;\mu(b)&#x3D;\mu(a)\mu(b)$ 成立。</p><p>第二种情况：$\mu(a)&#x3D;0$。</p><p>此时 $ab$ 一定也至少有一个平方因子（来自 $a$），故 $\mu(ab)&#x3D;0&#x3D;\mu(a)\mu(b)$。</p><p>第三种情况：$\mu(a)&#x3D;(-1)^n,\mu(b)&#x3D;(-1)^m$。</p><p>因为 $a,b$ 互质，所以这两个数没有相同的质因子，也就是 $ab$ 中没有平方因子。故 $\mu(ab)&#x3D;(-1)^{n+m}&#x3D;\mu(a)\mu(b)$，成立。</p></blockquote><ul><li>性质 $2$</li></ul><p>$F(n)&#x3D;\displaystyle\sum_{d|n}\mu(d)&#x3D;[n&#x3D;1]$。</p><blockquote><p>简单证明：</p><p>对于 $n&#x3D;1$，显然成立。</p><p>对于 $n&gt;1$，由性质 $1$，$\mu$ 是积性函数得其和函数 $F$ 也是积性函数。</p><p>设 $p\in prime,k\in N^*$。</p><p>可得 $F(p^k)&#x3D;\displaystyle\sum_{d|p^k}\mu(d)&#x3D;\mu(1)+\mu(p)+\mu(p^2)+…+\mu(p^k)&#x3D;1+(-1)+0+…+0&#x3D;0$。</p><p>分解 $n$，$n&#x3D;p_1^{e_1}+p_2^{e_2}+…+p_k^{e_k}$，则 $F(n)&#x3D;F(p_1^{e_1})F(p_2^{e_2})…F(p_k^{e_k})&#x3D;0$。</p></blockquote><ul><li>性质 $3$</li></ul><p>若 $f$ 是一个算数函数，$F$ 是其和函数，有 $F(n)&#x3D;\displaystyle\sum_{d|n}f(d)$。</p><p>则有 $f(n)&#x3D;\displaystyle\sum_{d|n}\mu(d)F(\frac nd)$。</p><p>此式称为莫比乌斯反演公式，也是莫反的灵魂所在。（感性理解看引入部分，严谨证明我不会 qwq。）</p><h2 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h2><p>在正式做题之前，先补点前置知识（会的大佬可以跳过这一部分）。</p><p>整除分块可以快速计算一些含有除法向下取整的和式，形如 $\displaystyle\sum_{i&#x3D;1}^nf(i)g(\left \lfloor \frac{n}{i} \right \rfloor)$。</p><p>我们要做的，其实是利用整除的性质把结果相同的值打包计算。例如 $\left \lfloor \frac{3}{3} \right \rfloor&#x3D;\left \lfloor \frac{4}{3} \right \rfloor&#x3D;\left \lfloor \frac{5}{3} \right \rfloor&#x3D;2$。</p><p><img src="/../../../../img/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%972.png"></p><ul><li>引理</li></ul><p>对于常数 $n$，有 $i\le j\le n$。确定一个 $i$，使<br>$$\left \lfloor \frac{n}{i} \right \rfloor&#x3D;\left \lfloor \frac{n}{j} \right \rfloor<br>$$</p><p>成立的最大 $j$ 为 $\left \lfloor \frac{n}{\left \lfloor \frac{n}{i} \right \rfloor} \right \rfloor$，即块右端点。</p><blockquote><p>简单证明：<br>$\begin{cases}<br>设\ k&#x3D;\left \lfloor \frac{n}{i} \right \rfloor\\<br>则\ i’&#x3D;max\ i，且\ ik\le n<br>\end{cases}$<br>故 $i’&#x3D;\left \lfloor \frac{n}{k} \right \rfloor&#x3D;\left \lfloor \frac{n}{\left \lfloor \frac{n}{i} \right \rfloor} \right \rfloor$。</p></blockquote><p>我们写出代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    ans+=(r-l+<span class="number">1</span>)*(n/l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做时间复杂度是 $O(\sqrt n)$ 的。也就是说，最多有 $O(\sqrt n)$ 级别种 $\left \lfloor \frac{n}{i} \right \rfloor$ 的取值。</p><blockquote><p>简单证明：<br>对于 $i\le \sqrt n$，显然只有 $\sqrt n$ 种取值。<br>对于 $i\ge \sqrt n$，$\left \lfloor \frac{n}{i} \right \rfloor\le \sqrt n$，所以也只有 $\sqrt n$ 种取值。</p></blockquote><p>其实不止是向下取整，也有向上取证的整除分块，不过用途不如向下取整的广泛，感兴趣的读者可以自行了解。</p><h2 id="题目选讲"><a href="#题目选讲" class="headerlink" title="题目选讲"></a>题目选讲</h2><p>注：有些题可以用别的方法做（比如欧拉函数，但本文只讨论莫反做法）。</p><h3 id="例题-1-SDOI2008-仪仗队"><a href="#例题-1-SDOI2008-仪仗队" class="headerlink" title="例题 1 [SDOI2008] 仪仗队"></a>例题 1 <a href="https://www.luogu.com.cn/problem/P2158">[SDOI2008] 仪仗队</a></h3><p><strong>形式化题意：</strong></p><p>求 $\displaystyle \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}[(i,j)&#x3D;1]$</p><p><strong>题目解析：</strong></p><p>我们使用上文的<strong>性质3</strong>，将式子变化一下</p><p>$$\displaystyle \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}[(i,j)&#x3D;1]\\$$</p><p>由 $[(i,j)&#x3D;1]\to\sum_{d|<br>(i,j)}\mu(d)$ 可得</p><p>$$\displaystyle \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}\sum_{d|<br>(i,j)}\mu(d)$$</p><p>更换枚举顺序，先枚举 $d$，得<br>$$\sum_{d&#x3D;1}\mu(d)\sum_{i&#x3D;1}^n[d|i]\sum_{j&#x3D;1}^n[d|j]$$</p><p>因为 $[1,n]$ 中 $d$ 的倍数有 $\left \lfloor \frac{n}{d} \right \rfloor$ 个，所以 $\sum_{i&#x3D;1}^n[d|i]&#x3D;\left \lfloor \frac{n}{d} \right \rfloor$</p><p>$$\sum_{d&#x3D;1}\mu(d)\left \lfloor \frac{n}{d} \right \rfloor^2$$</p><p>把上界 $n,n$ 替换为 $n,m$ 同理，答案为</p><p>$$\sum_{d&#x3D;1}\mu(d)\left \lfloor \frac{n}{d} \right \rfloor\left \lfloor \frac{m}{d} \right \rfloor$$</p><p>可以整除分块解决，时间复杂度 $O(n+T\sqrt n)$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [SDOI2008] 仪仗队</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> mu[N],st[N],p[N/<span class="number">10</span>],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    st[<span class="number">1</span>]=mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) p[++cnt]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;++j)&#123;</span><br><span class="line">            st[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                mu[i*p[j]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i*p[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) mu[i]+=mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(--n==<span class="number">0</span>) <span class="keyword">return</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl,<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=n/(n/l);</span><br><span class="line">        ans+=(mu[r]-mu[l<span class="number">-1</span>])*(n/l)*(n/r);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans+<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题-2-GCD-SUM"><a href="#例题-2-GCD-SUM" class="headerlink" title="例题 2 GCD SUM"></a>例题 2 <a href="https://www.luogu.com.cn/problem/P2398">GCD SUM</a></h3><p><strong>形式化题意：</strong></p><p>求 $\displaystyle \sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}(i,j)$。</p><p><strong>题目解析：</strong></p><p>我们考虑枚举 $(i,j)$，记为 $d$。</p><p>$$\displaystyle \sum_{d&#x3D;1}^nd\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}[(i,j)&#x3D;d]$$</p><p>让 $i,j$ 都除以 $d$，变为</p><p>$$\displaystyle \sum_{d&#x3D;1}^nd\sum_{i&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor}\sum_{j&#x3D;1}^{\left \lfloor \frac{n}{d} \right \rfloor}[(i,j)&#x3D;1]$$</p><p>后面的部分变成了例题 $1$</p><p>$$\displaystyle \sum_{d&#x3D;1}^nd\sum_{g&#x3D;1}^n\mu(g)\left \lfloor \frac{n}{dg} \right \rfloor^2$$</p><p>此时已经可以直接整除分块了，我们做进一步优化，设 $T&#x3D;dg$</p><p>$$\displaystyle \sum_{d&#x3D;1}^nd\sum_{g&#x3D;1}^n\mu(g)\left \lfloor \frac{n}{T} \right \rfloor^2$$</p><p>先枚举 $T$，得</p><p>$$\displaystyle \sum_{T&#x3D;1}^n\left \lfloor \frac{n}{T} \right \rfloor^2\sum_{d|T}d\mu(\frac{T}{d})$$</p><p>发现后面是欧拉函数（我收回不讲欧拉函数这句话）</p><p>$$\displaystyle \sum_{T&#x3D;1}^n\phi(T)\left \lfloor \frac{n}{T} \right \rfloor^2$$</p><p>杜教筛可以进一步优化，但此题没必要了，复杂度线性。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P2398 GCD SUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N/<span class="number">10</span>],st[N],cnt,phi[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    st[<span class="number">1</span>]=phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) p[++cnt]=i,phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*p[j]&lt;=n;++j)&#123;</span><br><span class="line">            st[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                phi[i*p[j]]=phi[i]*p[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i*p[j]]=phi[i]*phi[p[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) phi[i]+=phi[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=n/(n/l);</span><br><span class="line">        ans+=<span class="number">1ll</span>*(phi[r]-phi[l<span class="number">-1</span>])*(n/l)*(n/l);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;莫比乌斯反演&quot;&gt;&lt;a href=&quot;#莫比乌斯反演&quot; class=&quot;headerlink&quot; title=&quot;莫比乌斯反演&quot;&gt;&lt;/a&gt;莫比乌斯反演&lt;/h1&gt;&lt;h2 id=&quot;闲话&quot;&gt;&lt;a href=&quot;#闲话&quot; class=&quot;headerlink&quot; title=&quot;闲话&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>期望DP</title>
    <link href="http://example.com/2024/07/01/%E6%9C%9F%E6%9C%9BDP/"/>
    <id>http://example.com/2024/07/01/%E6%9C%9F%E6%9C%9BDP/</id>
    <published>2024-07-01T11:41:29.373Z</published>
    <updated>2024-07-01T11:47:54.515Z</updated>
    
    <content type="html"><![CDATA[<p><strong>数学期望：</strong> 在概率论和统计学中，数学期望(mathematic expectation)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。——摘自百度百科<br>不懂？<del>太正常了，百度百科就是不写人话。</del><br>举个栗子解释一下：在一次膜你赛中，小 z 预估自己有 $0.5$ 的概率考 $300$ 分，$0.3$ 的概率考250分，$0.2$ 的概率考 $200$分，计算方法与加权平均值有些类似，那她得分的数学期望即是： $0.5\times 300+0.3\times 250+0.2\times 200&#x3D;265pts$。<br>具体地，记第 $i$ 种结果的概率为 $p_i$，结果得分为 $f_i$，那么 $x$ 的期望 $E(x)&#x3D;\sum_{i&#x3D;1}^{x}p_i\times f_i$。<br>注意，$\sum_{i&#x3D;1}^{x}p_i&#x3D;1$，即所有概率总和必须是 $1$。</p><hr><p><strong>Problem1</strong> <a href="https://www.luogu.com.cn/problem/P4316">P4316 绿豆蛙的归宿</a><br><strong>题意简述</strong><br>给出一张 DAG，保证连通图，随机行走，求 $1$ 到 $n$ 的路径长度期望。具体地，若当前在点 $u$，出边数为 $od_u$，则走到每一条出边的概率相等，都为 $\frac{1}{od_u}$。<br><strong>题目解析</strong><br>我们设 $f_i$ 表示从 $1$ 到 $i$ 的路径长度期望，答案显然是 $f_n$。<br>但手算样例，我们看到如下情况，$f_1$ 显然为 $0$，$f_2$ 易得为 $0.5$，$f_3$ 如何计算？<br><a href="https://imgse.com/i/p9LHnqH"><img src="https://s1.ax1x.com/2023/05/28/p9LHnqH.png" alt="p9LHnqH.png"></a><br>显然我们还需要考虑从 $1$ 到 $3$ 的概率。但我们感觉这种方法略微繁琐，正推不方便，不妨逆推，也就是设 $f_i$ 表示从 $i$ 到 $n$ 的路径长度期望，此时答案为 $f_1$，初始状态 $f_n&#x3D;0$。<br>可以得出转移方程，当前在点 $u$，$f_u&#x3D;\frac{1}{od_u}\times \sum f_v+w_{u,v}$。<br>实现中，我们要逆推，所以两种方法处理图：记忆化搜索或者建反图拓扑排序。<br><strong>代码实现</strong><br>$1.$ 记忆化搜索</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+10;</span><br><span class="line">int n,m;</span><br><span class="line">int x,y;</span><br><span class="line">double z;</span><br><span class="line">struct edge&#123;int v,next;double w;&#125;e[N&lt;&lt;1];</span><br><span class="line">int head[N],tot;</span><br><span class="line">inline void add(int u,int v,double w)&#123;e[++tot].v=v,e[tot].w=w,e[tot].next=head[u],head[u]=tot;&#125;</span><br><span class="line">double chu[N];</span><br><span class="line">double f[N];</span><br><span class="line"></span><br><span class="line">void dfs(int u)&#123;</span><br><span class="line">    if(f[u]) return ;</span><br><span class="line">    for(int i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        int v=e[i].v;</span><br><span class="line">        if(!f[v]) dfs(v);</span><br><span class="line">        f[u]+=f[v]+e[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    if(chu[u]) f[u]/=chu[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;++i) scanf(&quot;%d%d%lf&quot;,&amp;x,&amp;y,&amp;z),add(x,y,z),chu[x]++; </span><br><span class="line">    dfs(1);</span><br><span class="line">    printf(&quot;%.2lf&quot;,f[1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$2.$ 反图拓扑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e5+100;</span><br><span class="line">const int M=2*N;</span><br><span class="line">int n,m;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int ver,nxt;</span><br><span class="line">    double edge;</span><br><span class="line">&#125;e[M];</span><br><span class="line">int head[N],tot;</span><br><span class="line">int in[N],out[N];</span><br><span class="line">double f[N],g[N];</span><br><span class="line">void add(int x,int y,double z)&#123;</span><br><span class="line">    e[++tot]=&#123;y,head[x],z&#125;;</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">void topsort()&#123;</span><br><span class="line">    f[1]=0.0;</span><br><span class="line">    g[1]=1.0;</span><br><span class="line">    q.push(1);</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int i=head[x];i;i=e[i].nxt)&#123;</span><br><span class="line">            int y=e[i].ver;</span><br><span class="line">            double z=e[i].edge;</span><br><span class="line">            f[y]+=(f[x]+g[x]*z)/out[x];</span><br><span class="line">            g[y]+=g[x]/out[x];</span><br><span class="line">            in[y]--;</span><br><span class="line">            if(in[y]==0)&#123;</span><br><span class="line">                q.push(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        double z;</span><br><span class="line">        scanf(&quot;%d%d%lf&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        add(x,y,z);</span><br><span class="line">        in[y]++;</span><br><span class="line">        out[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    topsort();</span><br><span class="line">    printf(&quot;%.2lf\n&quot;,f[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（法 $2$ 代码来自 <a href="https://www.luogu.com.cn/user/180256">此间的少年fu</a>）。</p><hr><p><strong>Problem2</strong> <a href="https://www.luogu.com.cn/problem/P8774">蓝桥杯 2022 省赛 A 组 E 题</a> <del>（蓝桥杯终于出了个好题。）</del><br><strong>题意简述</strong><br>有一只虫想要爬上高度为 $n$ 的树，初始位于树根, 即高度为 $0$，当它从高度 $i-1$ 爬到高度 $i$ 时有 $p_i$ 的概率掉回树根, 求它从树根爬到树顶时，花费总时间的数学期望（一次尝试向上爬花费时间为 $1$）。<br><strong>题目解析</strong><br>类似的套路，我们设 $f_i$ 表示从 $i$ 爬到 $n$ 时间的数学期望，答案即为 $f_0$。<br>则从 $i$ 成功上到 $i+1$ 的概率是 $1-p_{i+1}$，掉回树根的概率 $p_{i+1}$，初始状态 $f_n&#x3D;0$。<br>易得：$f_i&#x3D;1+(1-p_{i+1})\times f_{i+1}+p_{i+1}\times f_0$。<br>发现此时的 $f_i$ 与 $f_{i+1}$ 和 $f_0$ 有关。有后效性的 DP？怎么办呢？<br>我们尝试多写几项寻找一下规律：<br>$f_0&#x3D;1+(1−p_1)\times f_1+p_1\times f_0$<br>$f_1&#x3D;1+(1−p_2)\times f_2+p_2\times f_0$<br>$f_2&#x3D;1+(1−p_3)\times f_3+p_3\times f_0$<br>解方程组……高斯消元会 TLE……<br>于是直接代入可得 $f_0&#x3D;1+(1-p_1)+(1-p_1)\times (1-p_2)+(1-p_1)\times (1-p_2)\times (1-p_3)\times f_n+[p_1+(1-p_1)\times p_2+(1-p_1)\times (1-p_2)\times p_3]\times f_0$</p><p>可以推得 $f_0&#x3D;\prod_{i&#x3D;1}^n(1-p_i)f_n+f_0p_i\sum_{i&#x3D;1}^n\prod_{j&#x3D;1}^{i-1}(1-p_j)+\sum_{i&#x3D;1}^n\prod_{j&#x3D;1}^i(1-p_j)$</p><p>线性求解 $3$ 个系数，设为 $s1,s2,s3$，即可求 $f_0&#x3D;\frac{s3}{1-s2}$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll a[N],b[N];</span><br><span class="line">ll p[N],p2[N];</span><br><span class="line">ll A,C,fl[N];</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">    fl[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;    </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">        p[i]=(a[i]%mod*<span class="built_in">ksm</span>(b[i],mod<span class="number">-2</span>))%mod;</span><br><span class="line">        p2[i]=(<span class="number">1</span>-p[i]+mod)%mod;</span><br><span class="line">        fl[i]=fl[i<span class="number">-1</span>]*p2[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    A=<span class="number">1</span>,C=p[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;A=(A+fl[i])%mod;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;C=(C+fl[i<span class="number">-1</span>]*p[i]%mod)%mod;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,A%mod*<span class="built_in">ksm</span>((<span class="number">1</span>-C+mod)%mod,mod<span class="number">-2</span>)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;数学期望：&lt;/strong&gt; 在概率论和统计学中，数学期望(mathematic expectation)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。——摘自百度百科&lt;br&gt;不懂？&lt;</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF1840C</title>
    <link href="http://example.com/2024/07/01/CF1840C/"/>
    <id>http://example.com/2024/07/01/CF1840C/</id>
    <published>2024-07-01T11:40:21.146Z</published>
    <updated>2024-07-01T11:52:12.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CF1840C题解"><a href="#CF1840C题解" class="headerlink" title="CF1840C题解"></a>CF1840C题解</h1><p><strong>题目描述</strong></p><p><a href="https://codeforces.com/problemset/problem/1840/C">题目传送门</a></p><p>$T$ 组数据，每组数据给定 $n$，$k$，$q$ 和一个长度为 $n$ 的数组 $a$，求 $a$ 中长度大于等于 $k$ 且最大值小于等于 $q$ 的序列个数。<br>$\sum{n}\le 2e5$。</p><p><strong>题目解析</strong></p><ul><li>解法一：数据结构解法</li></ul><p>显然可以利用数据结构维护。考虑ST表预处理出区间最大值枚举区间左右端点累计，复杂度 $O(nlogn+n^2)$，需要优化。</p><p>再想想，若区间 $[i,j]$ 符合条件，则对于每个 $i\le k\le j$，区间 $[i,k]$ 都符合条件；若区间 $[i,j]$ 不符合，则对于每个 $j&lt;k\le n$，区间 $[i,k]$ 都不符合，答案可二分。所以我们枚举左端点，二分右端点，复杂度 $O(Tnlogn)$。</p><ul><li>解法二：数学解法</li></ul><p>显然：一个区间符合条件，当且仅当此区间不存在一个 $i\in [i,j]$ 使 $a_i&gt;q$。所以处理每一个 $a_i&gt;q$ 的 $i$，统计区间长度。区间长度为 $m$ 的合法区间贡献即为 $\sum_{i&#x3D;1}^{m}i$。而这个式子可以预处理，复杂度 $O(N+Tn)$。</p><p><strong>代码实现</strong></p><p>因为 $\sum{n}\le 2e5$，所以答案需要 long long。</p><ul><li>解法一<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n,k,q;</span><br><span class="line">ll f[N][<span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">maxx</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">log</span>(r-l+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[l][len],f[r-(<span class="number">1</span>&lt;&lt;len)+<span class="number">1</span>][len]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;f[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30</span>;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))<span class="number">-1</span>&lt;=n;++j)</span><br><span class="line">                f[j][i]=<span class="built_in">max</span>(f[j][i<span class="number">-1</span>],f[j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+k<span class="number">-1</span>&lt;=n;++i)&#123;</span><br><span class="line">            <span class="type">int</span> l=i+k<span class="number">-1</span>,r=n;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="type">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">maxx</span>(i,mid)&lt;=q) l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">maxx</span>(i,l)&lt;=q) ans+=<span class="built_in">min</span>(l,n)-i-k+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>解法二<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n,k,q;</span><br><span class="line">ll a[N],sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-10</span>;++i) sum[i]=sum[i<span class="number">-1</span>]+i;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;q)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p&gt;=k) ans+=sum[p-k+<span class="number">1</span>];</span><br><span class="line">                p=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p&gt;=k) ans+=sum[p-k+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p>完结撒花qwq</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CF1840C题解&quot;&gt;&lt;a href=&quot;#CF1840C题解&quot; class=&quot;headerlink&quot; title=&quot;CF1840C题解&quot;&gt;&lt;/a&gt;CF1840C题解&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>NOI2007 货币兑换</title>
    <link href="http://example.com/2024/07/01/%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/"/>
    <id>http://example.com/2024/07/01/%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/</id>
    <published>2024-07-01T11:39:42.372Z</published>
    <updated>2024-07-11T14:18:22.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NOI2007-货币兑换"><a href="#NOI2007-货币兑换" class="headerlink" title="[NOI2007] 货币兑换"></a><a href="https://www.luogu.com.cn/problem/P4027">[NOI2007] 货币兑换</a></h2><p>设 $f_i$ 表示第 $i$ 天最大的收益。</p><p>初始条件 $f_0&#x3D;s$，答案 $f_n$。</p><p>转移枚举上一个全买券的点 $j$，设 $y$ 表示第 $j$ 天买 $B$ 的数量，解方程。</p><p>$Rate_j\times y_j\times a_j+y_j\times b_j&#x3D;f_j$</p><p>得到 $y_j&#x3D;\large\frac{f_j}{Rate_j\times a_j+b_j}$</p><p>设 $x$ 表示买 $A$ 的数量，显然 $x_i&#x3D;Rate_j\times y_i$</p><p>转移方程 $f_i&#x3D;\max(f_{i-1},\max{a_i\times x_j+b_i\times y_j | j\in[1,i) } )$</p><p>提出 $b_i$，得到 $f_i&#x3D;\max(f_{i-1},b_i\times \max{\large\frac{a_i}{b_i}\small\times x_j+y_j})$</p><p>发现变成一次函数形式，即对于每个 $x_j,y_j$，查询 $\large\frac{a_i}{b_i}$ 处的最大值即可。</p><p>李超线段树即可（这里是一个简洁的李超树板子 qwq）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">db s;</span><br><span class="line">db x[N],y[N],k[N],c[N];</span><br><span class="line">db f[N],a[N],b[N],r[N];</span><br><span class="line"><span class="type">int</span> t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function">db <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> p)</span></span>&#123;<span class="keyword">return</span> x[i]*k[p]+y[i];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">calc</span>(t[p],l)&lt;<span class="built_in">calc</span>(x,l)) t[p]=x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(t[p],mid)&lt;<span class="built_in">calc</span>(x,mid)) <span class="built_in">swap</span>(t[p],x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(t[p],l)&lt;<span class="built_in">calc</span>(x,l)) <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="built_in">calc</span>(t[p],x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    db res=<span class="built_in">calc</span>(t[p],x);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">max</span>(res,<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(res,<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    f[<span class="number">0</span>]=s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;r[i];</span><br><span class="line">        k[i]=c[i]=a[i]/b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(k+<span class="number">1</span>,k+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">lower_bound</span>(k+<span class="number">1</span>,k+<span class="number">1</span>+n,c[i])-k;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],b[i]*<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,u));</span><br><span class="line">        db p=a[i]*r[i]+b[i];</span><br><span class="line">        y[i]=f[i]/p;</span><br><span class="line">        x[i]=y[i]*r[i];</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NOI2007-货币兑换&quot;&gt;&lt;a href=&quot;#NOI2007-货币兑换&quot; class=&quot;headerlink&quot; title=&quot;[NOI2007] 货币兑换&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4027&quot;</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>CF746G</title>
    <link href="http://example.com/2024/07/01/CF746G/"/>
    <id>http://example.com/2024/07/01/CF746G/</id>
    <published>2024-07-01T11:39:11.291Z</published>
    <updated>2024-07-11T14:19:20.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CF746G-题解"><a href="#CF746G-题解" class="headerlink" title="CF746G 题解"></a>CF746G 题解</h1><p>闲话：<del>2100的紫？</del> NOIP 集训，Smeow 讲图论，这是其中一个我觉得很妙的题，所以题解总结一下 qwq。没怎么写过题解，思路混乱请见谅。</p><p><a href="https://codeforces.com/contest/746/problem/G">传送门</a></p><p>题意：给一棵一共有 $n$ 个点的树，$t+1$ 层。第一层只有一个根节点，给出每层的节点数。已知有 $k$ 个叶子，求任意一种树的构造方案。</p><p>Solution：首先考虑构造一条链，满足题目 $t+1$ 层的要求，然后往上面挂节点。如果需要叶子，那么直接挂到这一层链上的节点，否则挂到上一层对应的节点（也是叶子），这样不会增加叶子数量，因为挂到上一层的叶子上会让叶子数量减 $1$，再加上新的，叶子数不变。记得判断无解，节点数不够叶子或有多余非叶子节点，具体实现看代码。第二种思路，先尽可能多地放叶子，再进行调整，把原来连在链上的点放到对应上层叶子减少叶子数，两种思路本质差别不大，这里只提供第一种实现。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,t,k;</span><br><span class="line"><span class="type">int</span> a[N],fa[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];<span class="comment">//v[i][j]表示第 i 层第 j 个点（设首都是第 0 层） </span></span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,notleaf;<span class="comment">//记得加上首都 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,t,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;++i) <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="keyword">if</span>(n-t&lt;k||a[t]&gt;k) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//特判，如果节点数量不够叶子或者最后一层节点数大于叶子数，直接-1 </span></span><br><span class="line">    v[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//先把首都加进去 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;++i) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=a[i];++j) v[i].<span class="built_in">push_back</span>(++cnt);<span class="comment">//给节点编号 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;++i) fa[v[i][<span class="number">0</span>]]=v[i<span class="number">-1</span>][<span class="number">0</span>];<span class="comment">//先构造链</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a[<span class="number">1</span>];++i) fa[v[<span class="number">1</span>][i]]=<span class="number">1</span>;<span class="comment">//第 1 层不用看，一定连到首都</span></span><br><span class="line">    notleaf=n-t-k;<span class="comment">//记录的是非叶子节点数量 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=t;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;a[i];++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(notleaf&gt;<span class="number">0</span>&amp;&amp;j&lt;a[i<span class="number">-1</span>]) fa[v[i][j]]=v[i<span class="number">-1</span>][j],notleaf--;</span><br><span class="line">            <span class="comment">//如果不需要叶子，挂到对应的上一层节点，不增加叶子数量 </span></span><br><span class="line">            <span class="keyword">else</span> fa[v[i][j]]=v[i<span class="number">-1</span>][<span class="number">0</span>];<span class="comment">//需要叶子，直接挂到上一层链上的节点即可 </span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(notleaf&gt;<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="comment">//如果还有剩余，无解 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,fa[i],i);<span class="comment">//按要求输出边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完结撒花！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CF746G-题解&quot;&gt;&lt;a href=&quot;#CF746G-题解&quot; class=&quot;headerlink&quot; title=&quot;CF746G 题解&quot;&gt;&lt;/a&gt;CF746G 题解&lt;/h1&gt;&lt;p&gt;闲话：&lt;del&gt;2100的紫？&lt;/del&gt; NOIP 集训，Smeow 讲图论，这是</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>浅谈平衡树</title>
    <link href="http://example.com/2024/07/01/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>http://example.com/2024/07/01/%E5%B9%B3%E8%A1%A1%E6%A0%91/</id>
    <published>2024-07-01T11:37:21.608Z</published>
    <updated>2024-07-01T11:46:14.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h2><p><strong>splay：伸展树，通过一系列的旋转维护平衡性。</strong></p><p><strong>注意，splay不一定是严格的平衡。故操作大部分均摊时间复杂度 $O(logn)$</strong></p><hr><p>分3种情况讨论旋转：</p><blockquote><p>$1.$ Zig $or$ Zag</p><p>$2.$ Zig-Zig $or$ Zag-Zag  （一字型，从左偏树到右偏树) </p><p>$3.$ Zig-Zag $or$ Zag-Zig  （之字形转成一字型）</p></blockquote><p>容易发现，旋转后树的中序遍历没有改变</p><hr><h3 id="splay的只因本操作"><a href="#splay的只因本操作" class="headerlink" title="splay的只因本操作"></a><del>splay的只因本操作</del></h3><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><blockquote><p>无需分开写左旋右旋</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=t[x].fa;</span><br><span class="line">    <span class="type">int</span> z=t[y].fa;</span><br><span class="line">    <span class="type">int</span> k=(<span class="built_in">rs</span>(y)==x);</span><br><span class="line">    t[z].son[<span class="built_in">rs</span>(z)==y]=x;</span><br><span class="line">    t[x].fa=z;</span><br><span class="line">    t[y].son[k]=t[x].son[k^<span class="number">1</span>];</span><br><span class="line">    t[t[x].son[k^<span class="number">1</span>]].fa=y;</span><br><span class="line">    t[x].son[k^<span class="number">1</span>]=y;</span><br><span class="line">    t[y].fa=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><blockquote><p>与二叉搜索树的查找相同，从根节点开始，如果要查询的值大于该点的值，递归右儿子，否则递归左二子。</p><p><strong>如果找到了当前要查找的数，将此节点旋转到根节点上。</strong></p></blockquote><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><blockquote><p>如果出现过，节点的数量+1。</p><p>否则新建节点，找到合适位置插入。</p><p><strong>插完以后旋转到根节点。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=root,p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        p=u;</span><br><span class="line">        u=t[u].son[v&gt;t[u].val];</span><br><span class="line">    &#125;</span><br><span class="line">    u=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p].son[v&gt;t[p].val]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    t[u].<span class="built_in">init</span>(v,p);</span><br><span class="line">    <span class="built_in">splay</span>(u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><blockquote><p>先找到此数的前驱，旋转到根节点。</p><p>再找后继，旋转到根节点的右儿子。</p><p><strong>当前根节点的右儿子的左二子即为要删除的点。</strong></p></blockquote><h4 id="提取区间"><a href="#提取区间" class="headerlink" title="提取区间"></a>提取区间</h4><blockquote><p>提取区间 $[x,y]$ ，将 $x-1$ 旋转到根，将 $y+1$ 旋转到根节点的右儿子。那么根节点的右儿子的左子树即为要提取的区间。</p><p><strong>注意，当 $x&#x3D;0$ 时无 $x-1$ 这个元素，当 $y&#x3D;n$ 时无 $y+1$ 这个元素，解决方法是加入两个“哨兵”，插入在 $0$ 和 $n+1$ 的位置。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qu</span><span class="params">(<span class="type">int</span> &amp;l,<span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l=<span class="built_in">getk</span>(l);</span><br><span class="line">    r=<span class="built_in">getk</span>(r+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">splay</span>(l,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">splay</span>(r,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="区间翻转"><a href="#区间翻转" class="headerlink" title="区间翻转"></a>区间翻转</h4><blockquote><p>区间翻转即为将区间内所有节点的左右子树进行交换。</p><p>首先提取区间（见上一个操作），随后交换根节点右儿子的左子树上每个节点的左右儿子。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="built_in">ls</span>(p),<span class="built_in">rs</span>(p));</span><br><span class="line">        t[<span class="built_in">ls</span>(p)].lazy^=<span class="number">1</span>;</span><br><span class="line">        t[<span class="built_in">rs</span>(p)].lazy^=<span class="number">1</span>;</span><br><span class="line">        t[p].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="P3391-【模板】文艺平衡树"><a href="#P3391-【模板】文艺平衡树" class="headerlink" title="P3391 【模板】文艺平衡树"></a>P3391 【模板】文艺平衡树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fastio</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> te template<span class="string">&lt;typename T&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> tem template<span class="string">&lt;typename T,typename ...Args&gt;</span></span></span><br><span class="line">    <span class="function">te <span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">if</span>(f==<span class="number">-1</span>) x=-x;&#125;</span><br><span class="line">    <span class="function">tem <span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x,Args&amp; ...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line">    <span class="function">te <span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> c,T x)</span></span>&#123;T p=x;<span class="keyword">if</span>(!p) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);<span class="keyword">if</span>(p&lt;<span class="number">0</span>)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);p=-p;&#125;<span class="type">int</span> cnt[<span class="number">105</span>],tot=<span class="number">0</span>;<span class="keyword">while</span>(p)&#123;cnt[++tot]=p%<span class="number">10</span>;p/=<span class="number">10</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=tot;i&gt;=<span class="number">1</span>;i--)&#123;<span class="built_in">putchar</span>(cnt[i]+<span class="string">&#x27;0&#x27;</span>);&#125;<span class="built_in">putchar</span>(c);&#125;</span><br><span class="line">    <span class="function">tem <span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c,T x,Args ...args)</span></span>&#123;<span class="built_in">write</span>(c,x);<span class="built_in">write</span>(c,args...);&#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> fastio;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) t[x].son[1]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> son[<span class="number">2</span>],fa,val;</span><br><span class="line">    <span class="type">int</span> siz,lazy;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val=a;</span><br><span class="line">        fa=b;</span><br><span class="line">        siz=<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;t[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    t[p].siz=t[<span class="built_in">ls</span>(p)].siz+t[<span class="built_in">rs</span>(p)].siz+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(<span class="built_in">ls</span>(p),<span class="built_in">rs</span>(p));</span><br><span class="line">        t[<span class="built_in">ls</span>(p)].lazy^=<span class="number">1</span>;</span><br><span class="line">        t[<span class="built_in">rs</span>(p)].lazy^=<span class="number">1</span>;</span><br><span class="line">        t[p].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=t[x].fa;</span><br><span class="line">    <span class="type">int</span> z=t[y].fa;</span><br><span class="line">    <span class="type">int</span> k=(<span class="built_in">rs</span>(y)==x);</span><br><span class="line">    t[z].son[<span class="built_in">rs</span>(z)==y]=x;</span><br><span class="line">    t[x].fa=z;</span><br><span class="line">    t[y].son[k]=t[x].son[k^<span class="number">1</span>];</span><br><span class="line">    t[t[x].son[k^<span class="number">1</span>]].fa=y;</span><br><span class="line">    t[x].son[k^<span class="number">1</span>]=y;</span><br><span class="line">    t[y].fa=x;</span><br><span class="line">    <span class="built_in">pushup</span>(y);</span><br><span class="line">    <span class="built_in">pushup</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(t[x].fa!=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=t[x].fa;</span><br><span class="line">        <span class="type">int</span> z=t[y].fa;</span><br><span class="line">        <span class="keyword">if</span>(z!=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">rs</span>(y)==x)^(<span class="built_in">rs</span>(z)==y)) &#123;<span class="built_in">rotate</span>(x);&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="built_in">rotate</span>(y);&#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!k) root=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=root,p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u)</span><br><span class="line">    &#123;</span><br><span class="line">        p=u;</span><br><span class="line">        u=t[u].son[v&gt;t[u].val];</span><br><span class="line">    &#125;</span><br><span class="line">    u=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        t[p].son[v&gt;t[p].val]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    t[u].<span class="built_in">init</span>(v,p);</span><br><span class="line">    <span class="built_in">splay</span>(u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getk</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="built_in">ls</span>(u)].siz&gt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            u=<span class="built_in">ls</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[<span class="built_in">ls</span>(u)].siz+<span class="number">1</span>==k) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k-=t[<span class="built_in">ls</span>(u)].siz+<span class="number">1</span>;</span><br><span class="line">            u=<span class="built_in">rs</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qu</span><span class="params">(<span class="type">int</span> &amp;l,<span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l=<span class="built_in">getk</span>(l);</span><br><span class="line">    r=<span class="built_in">getk</span>(r+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">splay</span>(l,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">splay</span>(r,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ls</span>(u))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">ls</span>(u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t[u].val&gt;=<span class="number">1</span>&amp;&amp;t[u].val&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>(<span class="string">&#x27; &#x27;</span>,t[u].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">rs</span>(u))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">rs</span>(u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n,m);</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;++i) &#123;<span class="built_in">insert</span>(i);&#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(l,r);</span><br><span class="line">        <span class="built_in">qu</span>(l,r);</span><br><span class="line">        t[<span class="built_in">ls</span>(r)].lazy^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="FHQ-Treap"><a href="#FHQ-Treap" class="headerlink" title="FHQ-Treap"></a>FHQ-Treap</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Treap 这个词是由 Tree 和 Heap 组合形成的，可以看出 Treap 是查找树和堆的结合，因此中文叫树堆。</p><p>和其他平衡树一样，Treap 的中序遍历值单调不减；而根据堆的性质，每个结点的权小于两个子结点的权。</p><p>Treap 分为有旋和无旋两种，而无旋 Treap又叫 FHQ-Treap，主要通过分裂（split）和合并（merge）实现维护操作。</p></blockquote><hr><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><blockquote><h4 id="1​-分裂（split）"><a href="#1​-分裂（split）" class="headerlink" title="1​. 分裂（split）"></a>1​. 分裂（split）</h4><p>分裂操作是将一个树分成 $x,y$ 两个树。$x$ 中每一个结点的值都小于 $k$，而 $y$ 中每一个结点的值都大于等于 $k$。复杂度 $O(logn)$</p><p>举个例子：</p><p><img src="http://www.yhzq-blog.cc/wp-content/uploads/2021/10/merge.gif" alt="slpit"></p><p>（此图<del>盗自</del>出自某dalao blog）</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> _val,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) x=y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[p].val&lt;=_val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">split</span>(t[p].r,_val,t[p].r,y);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">        x=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">split</span>(t[p].l,_val,x,t[p].l);</span><br><span class="line">        <span class="built_in">pushup</span>(p);</span><br><span class="line">        y=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><blockquote><h4 id="2-合并-（merge）"><a href="#2-合并-（merge）" class="headerlink" title="$2.$ 合并 （merge）"></a>$2.$ 合并 （merge）</h4><p>合并是将 $x,y$ 两棵树合并为一棵树 复杂度 $O(logn)$</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/bheudsa4.png" alt="merge"></p><p>（此图<del>盗自</del>出自另一位dalao blog）</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">   <span class="keyword">if</span>(t[x].key&lt;=t[y].key)</span><br><span class="line">   &#123;</span><br><span class="line">       t[x].r=<span class="built_in">merge</span>(t[x].r,y);</span><br><span class="line">       <span class="built_in">pushup</span>(x);</span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       t[y].l=<span class="built_in">merge</span>(x,t[y].l);</span><br><span class="line">       <span class="built_in">pushup</span>(y);</span><br><span class="line">       <span class="keyword">return</span> y;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><blockquote><h4 id="3-插入"><a href="#3-插入" class="headerlink" title="$3.$ 插入"></a>$3.$ 插入</h4><p>先将申请一个新的结点，作为一棵树 $y$；并将原来的树分裂成 $x,z$ 两棵树。<br>然后依次合并 $x,y,z$，就完成了。复杂度 $O(logn)$</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> _val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">split</span>(root,_val,x,y);</span><br><span class="line">    t[++cnt].<span class="built_in">init</span>(_val);</span><br><span class="line">    root=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(cnt,y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="4-删除"><a href="#4-删除" class="headerlink" title="$4.$ 删除"></a>$4.$ 删除</h4><p>删除比较巧妙，先将树分裂成 $x,y,z$ 三棵树；其中 $x$ 的每个结点的值均小于 $k$，$y$  的每个结点的值均为 $k$，$z$ 的每个结点的值均大于 $k$ 。</p><p>直接合并 $y$ 的左右两棵子树，根节点就被删除掉了。最后，依次合并 $x,y,z$。</p><p>复杂度 $O(logn)$</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> _val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,_val,x,y);</span><br><span class="line">    <span class="built_in">split</span>(x,_val<span class="number">-1</span>,x,z);</span><br><span class="line">    z=<span class="built_in">merge</span>(t[z].l,t[z].r);</span><br><span class="line">    root=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(z,y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="5-查询排名"><a href="#5-查询排名" class="headerlink" title="$5.$ 查询排名"></a>$5.$ 查询排名</h4><p>直接分裂，小于 $k$ 的树的大小加一即为排名。</p><p>复杂度 $O(logn)$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrank</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> _val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">split</span>(root,_val<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="type">int</span> res=t[x].siz+<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="6-排名为-x-的数"><a href="#6-排名为-x-的数" class="headerlink" title="$6.$ 排名为 $x$ 的数"></a>$6.$ 排名为 $x$ 的数</h4><p>这个操作是查询第 $x$ 大,要按照普通的查询方法来搞</p><p><strong>详见代码：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getvalue</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[t[p].l].siz+<span class="number">1</span>==k) <span class="keyword">return</span> t[p].val;</span><br><span class="line">    <span class="keyword">if</span>(t[t[p].l].siz+<span class="number">1</span>&lt;k) <span class="keyword">return</span> <span class="built_in">getvalue</span>(t[p].r,k-t[t[p].l].siz<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getvalue</span>(t[p].l,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="7-前驱"><a href="#7-前驱" class="headerlink" title="$7.$ 前驱"></a>$7.$ 前驱</h4><p>所以直接查找小于 $x$ 的数里最大的。</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">prev</span><span class="params">(<span class="type">int</span> _val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">split</span>(root,_val<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="type">int</span> tmp=x;</span><br><span class="line">    <span class="keyword">while</span>(t[tmp].r) tmp=t[tmp].r;</span><br><span class="line">    root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> t[tmp].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="8-后继"><a href="#8-后继" class="headerlink" title="$8.$ 后继"></a>$8.$ 后继</h4><p>于前驱同理，找大于等于 $x$ 里最小的</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">nex</span><span class="params">(<span class="type">int</span> _val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">split</span>(root,_val,x,y);</span><br><span class="line">    <span class="type">int</span> tmp=y;</span><br><span class="line">    <span class="keyword">while</span>(t[tmp].l) tmp=t[tmp].l;</span><br><span class="line">    root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> t[tmp].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="P3369-【模板】普通平衡树"><a href="#P3369-【模板】普通平衡树" class="headerlink" title="P3369 【模板】普通平衡树"></a>P3369 【模板】普通平衡树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> fastio</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> te template<span class="string">&lt;typename T&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> tem template<span class="string">&lt;typename T,typename ...Args&gt;</span></span></span><br><span class="line">    <span class="function">te <span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span>&#123;x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=<span class="built_in">getchar</span>();&#125;<span class="keyword">if</span>(f==<span class="number">-1</span>) x=-x;&#125;</span><br><span class="line">    <span class="function">tem <span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T&amp; x,Args&amp; ...args)</span></span>&#123;<span class="built_in">read</span>(x);<span class="built_in">read</span>(args...);&#125;</span><br><span class="line">    <span class="function">te <span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">char</span> c,T x)</span></span>&#123;T p=x;<span class="keyword">if</span>(!p) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);<span class="keyword">if</span>(p&lt;<span class="number">0</span>)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);p=-p;&#125;<span class="type">int</span> cnt[<span class="number">105</span>],tot=<span class="number">0</span>;<span class="keyword">while</span>(p)&#123;cnt[++tot]=p%<span class="number">10</span>;p/=<span class="number">10</span>;&#125;<span class="keyword">for</span>(<span class="type">int</span> i=tot;i&gt;=<span class="number">1</span>;i--)&#123;<span class="built_in">putchar</span>(cnt[i]+<span class="string">&#x27;0&#x27;</span>);&#125;<span class="built_in">putchar</span>(c);&#125;</span><br><span class="line">    <span class="function">tem <span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c,T x,Args ...args)</span></span>&#123;<span class="built_in">write</span>(c,x);<span class="built_in">write</span>(c,args...);&#125;</span><br><span class="line">&#125;<span class="keyword">using</span> <span class="keyword">namespace</span> fastio;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> op,x;</span><br><span class="line"><span class="type">int</span> root,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,key,val,siz;    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _val)</span></span>&#123;</span><br><span class="line">        val=_val;</span><br><span class="line">        siz=<span class="number">1</span>;</span><br><span class="line">        key=<span class="built_in">rand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;t[p].siz=t[t[p].l].siz+t[t[p].r].siz+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> _val,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) x=y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[p].val&lt;=_val)&#123;</span><br><span class="line">        <span class="built_in">split</span>(t[p].r,_val,t[p].r,y);</span><br><span class="line">        <span class="built_in">pushup</span>(p);x=p;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">split</span>(t[p].l,_val,x,t[p].l);</span><br><span class="line">        <span class="built_in">pushup</span>(p);y=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(t[x].key&lt;=t[y].key)&#123;</span><br><span class="line">        t[x].r=<span class="built_in">merge</span>(t[x].r,y);</span><br><span class="line">        <span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t[y].l=<span class="built_in">merge</span>(x,t[y].l);</span><br><span class="line">        <span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> _val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">split</span>(root,_val,x,y);</span><br><span class="line">    t[++cnt].<span class="built_in">init</span>(_val);</span><br><span class="line">    root=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(cnt,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> _val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">split</span>(root,_val,x,y);</span><br><span class="line">    <span class="built_in">split</span>(x,_val<span class="number">-1</span>,x,z);</span><br><span class="line">    z=<span class="built_in">merge</span>(t[z].l,t[z].r);</span><br><span class="line">    root=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(z,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrank</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> _val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">split</span>(root,_val<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="type">int</span> res=t[x].siz+<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(x,y);<span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getvalue</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[t[p].l].siz+<span class="number">1</span>==k) <span class="keyword">return</span> t[p].val;</span><br><span class="line">    <span class="keyword">if</span>(t[t[p].l].siz+<span class="number">1</span>&lt;k) <span class="keyword">return</span> <span class="built_in">getvalue</span>(t[p].r,k-t[t[p].l].siz<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getvalue</span>(t[p].l,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">prev</span><span class="params">(<span class="type">int</span> _val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">split</span>(root,_val<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="type">int</span> tmp=x;</span><br><span class="line">    <span class="keyword">while</span>(t[tmp].r) tmp=t[tmp].r;</span><br><span class="line">    root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> t[tmp].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">nex</span><span class="params">(<span class="type">int</span> _val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">split</span>(root,_val,x,y);</span><br><span class="line">    <span class="type">int</span> tmp=y;</span><br><span class="line">    <span class="keyword">while</span>(t[tmp].l) tmp=t[tmp].l;</span><br><span class="line">    root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> t[tmp].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">read</span>(op,x); </span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">del</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>) <span class="built_in">write</span>(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">getrank</span>(root,x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>) <span class="built_in">write</span>(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">getvalue</span>(root,x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>) <span class="built_in">write</span>(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">prev</span>(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">6</span>) <span class="built_in">write</span>(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">nex</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="完结撒花"><a href="#完结撒花" class="headerlink" title="~~完结撒花~~"></a>~~完结撒花~~</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Splay&quot;&gt;&lt;a href=&quot;#Splay&quot; class=&quot;headerlink&quot; title=&quot;Splay&quot;&gt;&lt;/a&gt;Splay&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;splay：伸展树，通过一系列的旋转维护平衡性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>并查集进阶</title>
    <link href="http://example.com/2024/07/01/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://example.com/2024/07/01/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2024-07-01T11:32:01.107Z</published>
    <updated>2024-07-01T11:32:57.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集扩展"><a href="#并查集扩展" class="headerlink" title="并查集扩展"></a>并查集扩展</h1><p><strong>前言：</strong> 本文不再赘述朴素的并查集，主要记录一些并查集的题目做法和并查集算法扩展。</p><ul><li>扩域并查集</li></ul><p>又称种类并查集。用于处理一些具有多个相互关系的并查集。一般朴素并查集判断是否在同一集合，扩域则判断多个集合的相互关系作用下（一般为排斥关系）是否在同一集合。本质上利用了并查集的传递性。</p><p>通俗地，朴素的并查集维护朋友，而扩域并查集可以维护朋友、敌人且满足敌人的敌人是朋友。</p><ul><li>带权并查集</li></ul><p>在并查集的边上定义某种权值、以及这种权值在路径压缩时产生的运算。一般来说，带权并查集时只能使用路径压缩优化，不过在比赛中一般不会卡这个。</p><h2 id="例题1-HAOI2016-食物链"><a href="#例题1-HAOI2016-食物链" class="headerlink" title="例题1 [HAOI2016] 食物链"></a>例题1 <a href="https://www.luogu.com.cn/problem/P2024">[HAOI2016] 食物链</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。</p><p>现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。</p><p>有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：</p><ul><li>第一种说法是 <code>1 X Y</code>，表示 $X$ 和 $Y$ 是同类。</li><li>第二种说法是 <code>2 X Y</code>，表示 $X$ 吃 $Y$。</li></ul><p>此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ul><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；</li><li>当前的话表示 $X$ 吃 $X$，就是假话。</li></ul><p>你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。</p><p>对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>此题使用上述两种并查集皆可，下面分别讲解。</p><blockquote><p><strong>扩域并查集：</strong></p><p>我们定义 $fa_x$ 表示集合，$y\in[1,n]$ 时表示 $x,y$ 是同类，$y\in[n+1,2n]$ 时表示 $y$ 吃 $x$，$y\in[2n+1,3n]$ 时表示 $x$ 吃 $y$。</p><p>这样我们发现，对于所有同类 $(x,y)$，其天敌 $(x+n,y+n)$ 在同一集合，同时其猎物 $(x+2n,y+2n)$ 也在同一集合。否则不满足条件，是假话。</p><p>这样就可以了，维护三种集合并判断，详见代码。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">3</span>*N];</span><br><span class="line"><span class="type">int</span> n,k,ans;</span><br><span class="line"><span class="type">int</span> op,x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> xx=<span class="built_in">find</span>(x),yy=<span class="built_in">find</span>(y);</span><br><span class="line">    f[xx]=yy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*n;++i) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x&gt;n||y&gt;n)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x+n)==<span class="built_in">find</span>(y)||<span class="built_in">find</span>(x+<span class="number">2</span>*n)==<span class="built_in">find</span>(y)) ans++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">merge</span>(x,y);</span><br><span class="line">                <span class="built_in">merge</span>(x+n,y+n);</span><br><span class="line">                <span class="built_in">merge</span>(x+<span class="number">2</span>*n,y+<span class="number">2</span>*n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y)||<span class="built_in">find</span>(x+<span class="number">2</span>*n)==<span class="built_in">find</span>(y)) ans++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">merge</span>(x,y+<span class="number">2</span>*n);</span><br><span class="line">                <span class="built_in">merge</span>(x+n,y);</span><br><span class="line">                <span class="built_in">merge</span>(x+<span class="number">2</span>*n,y+n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>带权并查集：</strong></p><p>用 $d_x$ 表示 $x$ 与 $fa_x$ 的关系，$0$ 表示同类，$1$ 表示捕食，$2$ 表示被捕食。</p><p>合并时，对于两点 $(x,y)$，权值关系为 $v$，设其父亲为 $(fx,fy)$。假设将 $fx$ 合并到 $fy$，则如图可知，$d_{fx}&#x3D;d_y+v-d_x$。因为若将 $x$ 直接合并到 $y$，$d_x&#x3D;d_y+v$，而现在是对于 $fx$ 合并到 $fy$，$x$ 的 $d$ 值应该相等，即 $d_x+d_{fx}&#x3D;d_y+v$，移项后得上式。</p><p><img src="/../../../../img/%E5%B9%B6%E6%9F%A5%E9%9B%86.png"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> f[N],d[N],n,k,d1,x,y,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=f[x])&#123;</span><br><span class="line">        <span class="type">int</span> xx=f[x];</span><br><span class="line">        f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">        d[x]=(d[x]+d[xx])%<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) f[i]=i,d[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;d1,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>((d1==<span class="number">2</span>&amp;&amp;x==y)||(x&gt;n||y&gt;n))&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d1==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y)) <span class="keyword">if</span>(d[x]!=d[y]) ans++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[f[x]]=(d[y]-d[x]+<span class="number">3</span>)%<span class="number">3</span>;</span><br><span class="line">                f[f[x]]=f[y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(d1==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y)) <span class="keyword">if</span>(d[x]!=(d[y]+<span class="number">1</span>)%<span class="number">3</span>) ans++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d[f[x]]=(d[y]-d[x]+<span class="number">4</span>)%<span class="number">3</span>;</span><br><span class="line">                f[f[x]]=f[y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题2-SDOI2006-二进制方程"><a href="#例题2-SDOI2006-二进制方程" class="headerlink" title="例题2 [SDOI2006] 二进制方程"></a>例题2 <a href="https://www.luogu.com.cn/problem/P2456">[SDOI2006] 二进制方程</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定若干（至多 $26$ 个）小写字母表示的变量及其表示的二进制长度和两个 $01$ 串，串中字符保证只有 $0,1$ 和变量，求若两个字符串相等，有多少种变量取值。</p><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>我们把两个串根据变量长度展开，然后根据确定的位置填数，并将对一个变量的固定修改下传到所有这个变量。使用并查集实现。</p><p><code>s:1bbaaaadddd1</code></p><p><code>t:aaaaccccbbee</code></p><p>变为（并查集维护）</p><p><code>s:1bb1aa1dddd1</code></p><p><code>t:1aa1cc1cbbe1</code></p><p>而剩下不确定的位置每个有两种可能，计算 $2$ 的次幂即可，注意需要高精度。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> k,n,m,sum;</span><br><span class="line"><span class="type">int</span> len[<span class="number">30</span>];</span><br><span class="line">string a,b;</span><br><span class="line"><span class="type">int</span> x[N],y[N],fa[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ca(x) (int)(x-<span class="string">&#x27;a&#x27;</span>+1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> p[N],top;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    len[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k+<span class="number">1</span>;++i) cin&gt;&gt;len[i],sum+=len[i],len[i]+=len[i<span class="number">-1</span>];</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="type">int</span> tmp1,tmp2;</span><br><span class="line">    tmp1=a.<span class="built_in">size</span>(),tmp2=b.<span class="built_in">size</span>();</span><br><span class="line">    a=<span class="string">&quot; &quot;</span>+a,b=<span class="string">&quot; &quot;</span>+b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tmp1;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;a[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=len[<span class="built_in">ca</span>(a[i])];j&lt;len[<span class="built_in">ca</span>(a[i])+<span class="number">1</span>];++j) x[++n]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span> x[++n]=a[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tmp2;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;b[i]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=len[<span class="built_in">ca</span>(b[i])];j&lt;len[<span class="built_in">ca</span>(b[i])+<span class="number">1</span>];++j) y[++m]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span> y[++m]=b[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=m) <span class="keyword">return</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl,<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len[k+<span class="number">1</span>];++i) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> fx=<span class="built_in">find</span>(x[i]),fy=<span class="built_in">find</span>(y[i]);</span><br><span class="line">        <span class="keyword">if</span>(fx+fy==<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">            fa[<span class="built_in">max</span>(fx,fy)]=<span class="built_in">min</span>(fx,fy);</span><br><span class="line">            sum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>,top=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sum;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;top;++j) p[j]&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;top;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                p[j+<span class="number">1</span>]+=p[j]/<span class="number">10</span>;</span><br><span class="line">                p[j]%=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;p[top];++top)&#123;</span><br><span class="line">            p[top+<span class="number">1</span>]+=p[top]/<span class="number">10</span>;</span><br><span class="line">            p[top]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) cout&lt;&lt;p[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题3-CEOI1999-Parity-Game"><a href="#例题3-CEOI1999-Parity-Game" class="headerlink" title="例题3 [CEOI1999] Parity Game"></a>例题3 <a href="https://www.luogu.com.cn/problem/P5937">[CEOI1999] Parity Game</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>Alice 和 Bob 在玩一个游戏：他写一个由 $0$ 和 $1$ 组成的序列。Alice 选其中的一段（比如第 $3$ 位到第 $5$ 位），问他这段里面有奇数个 $1$ 还是偶数个 $1$。Bob 回答你的问题，然后 Alice 继续问。Alice 要检查 Bob 的答案，指出在 Bob 的第几个回答一定有问题。有问题的意思就是存在一个 $01$ 序列满足这个回答前的所有回答，而且不存在序列满足这个回答前的所有回答及这个回答。</p><p>对于 $100%$ 的数据，$1 \le  n \leq 10^9$，$m \leq 5 \times 10^3$。</p><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p><del>这个数据范围也太小了，应该能用很多非正解方法过啊。</del></p><p>那么如果区间 $[i,j]$ 有奇数个 $1$，则 $[1,i-1]$ 和 $[1,j]$ 的奇偶性不同，反之同理。所以我们开始将区间左端点全部减一。问题变成查询左右端点奇偶性是否相同的问题。</p><p>使用扩域并查集，$[1,n]$ 表示与自己奇偶性相同的（朋友），$[n+1,2n]$ 表示与自己奇偶性不同的（敌人）。</p><p>于是对于朋友询问（<code>even</code>），若左端点是右端点敌人，或者右端点是左端点敌人，则有矛盾。敌人询问同理，合并操作即分别合并朋友和敌人的关系。</p><p>注意到数据范围，需要离散化。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int ll</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,odd;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> b[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i].l&gt;&gt;a[i].r&gt;&gt;op;</span><br><span class="line">        a[i].l--;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;o&#x27;</span>) a[i].odd=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a[i].odd=<span class="number">0</span>;</span><br><span class="line">        b[++cnt]=a[i].l,b[++cnt]=a[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+cnt);</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+cnt)-(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len*<span class="number">2</span>;++i) fa[i]=i;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+len,a[i].l)-b;</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+len,a[i].r)-b;</span><br><span class="line">        <span class="keyword">if</span>(a[i].odd)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y)||<span class="built_in">find</span>(x+len)==<span class="built_in">find</span>(y+len))&#123;</span><br><span class="line">                cout&lt;&lt;i<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">merge</span>(x+len,y),<span class="built_in">merge</span>(x,y+len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x+len)==<span class="built_in">find</span>(y)||<span class="built_in">find</span>(y+len)==<span class="built_in">find</span>(x))&#123;</span><br><span class="line">                cout&lt;&lt;i<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">merge</span>(x,y),<span class="built_in">merge</span>(x+len,y+len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) cout&lt;&lt;m&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题4-SCOI2016-萌萌哒"><a href="#例题4-SCOI2016-萌萌哒" class="headerlink" title="例题4 [SCOI2016] 萌萌哒"></a>例题4 <a href="https://www.luogu.com.cn/problem/P3295">[SCOI2016] 萌萌哒</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个长度为 $n$ 的大数，用 $S_1S_2S_3 \cdots S_n$表示，其中 $S_i$ 表示数的第 $i$ 位, $S_1$ 是数的最高位。告诉你一些限制条件，每个条件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串 $S_{l_1}S_{l_1+1}S_{l_1+2} \cdots S_{r_1}$ 与 $S_{l_2}S_{l_2+1}S_{l_2+2} \cdots S_{r_2}$ 完全相同。</p><p>比如 $n&#x3D;6$ 时，某限制条件 $l_1&#x3D;1,r_1&#x3D;3,l_2&#x3D;4,r_2&#x3D;6$ ，那么 $123123$，$351351$ 均满足条件，但是 $12012$，$131141$ 不满足条件，前者数的长度不为 $6$ ，后者第二位与第五位不同。问满足以上所有条件的数有多少个。对 $10^9+7$ 取模。</p><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><ul><li>$Part\ 1$</li></ul><p>我们对于每个条件，暴力循环，并将对应位置合并。</p><p>设最后的连通块个数是 $cnt$，则答案为 $9\times 10^{cnt-1}$，即第一位不能为 $0$，剩下的随便选。</p><p>复杂度 $O(nm\alpha)$，可以获得 $30pts$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> l1[N],l2[N],r1[N],r2[N];</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) fa[i]=i;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin&gt;&gt;l1[i]&gt;&gt;r1[i]&gt;&gt;l2[i]&gt;&gt;r2[i];</span><br><span class="line">        <span class="built_in">F</span>(j,l1[i],r1[i]) <span class="built_in">merge</span>(j,l2[i]+j-l1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">count</span>(<span class="built_in">find</span>(i))==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>) ans=ans*<span class="number">9</span>%mod;</span><br><span class="line">            <span class="keyword">else</span> ans=ans*<span class="number">10</span>%mod;</span><br><span class="line">            s.<span class="built_in">insert</span>(<span class="built_in">find</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$Part\ 2$</li></ul><p>发现时间复杂度瓶颈在于暴力合并，考虑优化。</p><p>我们发现，合并两个并查集区间也可以转化为分别合并这两个区间的子区间（子区间之并等于原区间）。这被称为并查集合并的结合律（看图，上下两种合并等价）。</p><p><img src="/../../../../img/%E5%B9%B6%E6%9F%A5%E9%9B%862.png"></p><p>于是我们考虑用倍增维护这个关系，设 $f_{i,j}$ 表示从 $i$ 开始的 $2^j$ 个数的父亲。接下来可以看成把整个过程分成 $j$ 层，每一层向下递推合并关系，一直到 $0$ 层。</p><p>复杂度 $O(n\log n)$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m,l1,l2,r1,r2,cnt;</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">30</span>],p[<span class="number">30</span>],vis[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x][k]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x][k]=<span class="built_in">find</span>(fa[x][k],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x,k),y=<span class="built_in">find</span>(y,k);</span><br><span class="line">    fa[x][k]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,<span class="number">20</span>) p[i]=p[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;p[j]&lt;=n;++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+p[j]<span class="number">-1</span>&lt;=n;++i)</span><br><span class="line">            fa[i][j]=i;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;</span><br><span class="line">        <span class="type">int</span> j=<span class="built_in">log</span>(r1-l1+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">merge</span>(l1,l2,j);</span><br><span class="line">        <span class="built_in">merge</span>(r1-p[j]+<span class="number">1</span>,r2-p[j]+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fo</span>(j,<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>),<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+p[j]<span class="number">-1</span>&lt;=n;++i)&#123;</span><br><span class="line">            <span class="type">int</span> f=<span class="built_in">find</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(i==f) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">merge</span>(i,f,j<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">merge</span>(i+p[j<span class="number">-1</span>],f+p[j<span class="number">-1</span>],j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> f=<span class="built_in">find</span>(i,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!vis[f])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            vis[f]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="built_in">ksm</span>(<span class="number">10</span>,cnt<span class="number">-1</span>)*<span class="number">9</span>%mod;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并查集扩展&quot;&gt;&lt;a href=&quot;#并查集扩展&quot; class=&quot;headerlink&quot; title=&quot;并查集扩展&quot;&gt;&lt;/a&gt;并查集扩展&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt; 本文不再赘述朴素的并查集，主要记录一些并查集的题目做法和并查集算法扩展。&lt;</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络流入门</title>
    <link href="http://example.com/2024/05/24/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2024/05/24/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%85%A5%E9%97%A8/</id>
    <published>2024-05-24T08:42:06.482Z</published>
    <updated>2024-07-01T11:47:13.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络流入门"><a href="#网络流入门" class="headerlink" title="网络流入门"></a>网络流入门</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文是笔者第一次学习网络流写的 $\text{blog}$，可能比较简陋，但还是尽可能让所有人看懂 qwq。</p><p>本篇主要介绍网络流算法，具体题目的建模可以看<a href="">这一篇</a>。</p><h2 id="网络流引入"><a href="#网络流引入" class="headerlink" title="网络流引入"></a>网络流引入</h2><ul><li>网络流，简单来说就是在一个很多水管的地方，水流从起点流向终点，在水管有多种限制的情况下最大化总流量。</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>一个有向图 $G&#x3D;(V,E)$，满足以下两个条件则为网络。</p><blockquote><p>$1.$ $\forall e&#x3D;(u,v)\in E$（称为弧），都有一个称为容量的值 $w&#x3D;c(u,v)$，也可记作弧 $(u,v,w)$。<br>$2.$ 此图内有且仅有一个起点（源点）$S$ 和终点（汇点）$T$。</p></blockquote><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>我们记 $f(u,v)$ 表示 $u$ 到 $v$ 的流量。<br>对于网络中的一个路径，满足以下两个条件则为流。</p><blockquote><p>$1.$ 容量限制：对于路径上的每条边，流经该边的流量不能超过其容量，即 $f(u,v)\le c(u,v)$。感性理解为水管粗细有限，只能接受一定量的水流。<br>$2.$ 流量守恒：除了源点 $S$ 与汇点 $T$，路径上的每个点流入流量等于流出流量，即 $\sum_vf(u,v)&#x3D;\sum_xf(x,u)$。感性理解为水管不能储存水，也不能凭空变出水。</p></blockquote><h3 id="残量网络"><a href="#残量网络" class="headerlink" title="残量网络"></a>残量网络</h3><p>一个网络经过流的操作就变成残量网络。</p><p>我们用 $r(u,v)$ 表示残量网络，一开始 $r(u,v)&#x3D;c(u,v)$。其实就是边的剩余容量。</p><p>对于每一次流的操作，$r(u,v)-&#x3D;f(u,v)$。</p><p>因为流的相对性，一个流 $f(u,v)&#x3D;x$，也同时会让反向边 $f(v,u)&#x3D;-x$，这一点被称为<strong>反对称性</strong>。</p><p>所以对于一次流，$f(u,v)+&#x3D;x$，$f(v,u)-&#x3D;x$，$r(u,v)-&#x3D;x$，$r(v,u)+&#x3D;x$。</p><h3 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h3><p>在残量网络中，找到一条从 $S$ 到 $T$ 的路径，其中所有边剩余容量都不为 $0$，则称此路径为增广路。</p><p>简单来说，就是没流满，还能流，使答案增加的路径。</p><p>而当一个残量网络中不存在增广路，则此时汇点得到的流量就是网络中的<strong>最大流</strong>。</p><h3 id="反悔操作"><a href="#反悔操作" class="headerlink" title="反悔操作"></a>反悔操作</h3><p>上面好像是很完备的定义吧……等等，为什么 $r(v,u)+&#x3D;x$，剩余容量还会增加？</p><p>原因是下一次再流的时候会抵消掉这一次的流量，相当于无事发生，也就是所谓<strong>反悔</strong>操作。</p><p>理解一下，反向边的设定和反悔操作其实是为了避免直接贪心导致的错误答案。</p><p>我们先看个图，红色边表示原边，绿色边表示反向边，边上的数字表示剩余容量。</p><p><img src="/../../../../img/%E7%BD%91%E7%BB%9C%E6%B5%811.png"></p><p>然后我们先尝试增广路径 $(1,2,3,4)$，流量为 $10$，则残量网络如下（注意反向边的剩余容量增加）。</p><p><img src="/../../../../img/%E7%BD%91%E7%BB%9C%E6%B5%812.png"></p><p>我们再增广路径 $(1,3,4)$，流量为 $10$。</p><p><img src="/../../../../img/%E7%BD%91%E7%BB%9C%E6%B5%813.png"></p><p>如果没有反向边，已经返回了错误答案 $20$。但现在我们发现，图竟然还能增广，路径 $(1,3,2,4)$，流量为 $10$。</p><p>唯一的区别是这一次路径上有一条反向边，流过此边表示反悔操作，得到最大流 $30$。</p><p>这样流和直接增广 $(1,2,4)$ 与 $(1,3,4)$ 答案相同，避免了顺序问题导致的答案错误。</p><p><img src="/../../../../img/%E7%BD%91%E7%BB%9C%E6%B5%814.png"></p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="FF-算法"><a href="#FF-算法" class="headerlink" title="FF 算法"></a>FF 算法</h3><p>每次在残余网络中利用 $\text{dfs}$ 任意找一条从源点 $s$ 到汇点 $t$ 的增广路，直至不存增广路为止。</p><p>每次 $\text{dfs}$ 的复杂度是 $O(m)$ 的，可能有数据会卡到每次只能增广 $1$。如下图。</p><p><img src="/../../../../img/%E7%BD%91%E7%BB%9C%E6%B5%815.png"></p><p>这个图中可能会因顺序导致一直在走 $(1,2,3,4)$ 和 $(1,3,2,4)$，每次只增广 $1$。</p><p>这样算法的复杂度是 $O(m\times \max w)$ 的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> E = <span class="number">100000</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, w, next;</span><br><span class="line">&#125;;</span><br><span class="line">Edge e[<span class="number">2</span> * E];</span><br><span class="line"><span class="type">int</span> Flow[N];</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> n, m, s, t, tot = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> Maxflow = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot].u = u;</span><br><span class="line">    e[tot].v = v;</span><br><span class="line">    e[tot].w = w;</span><br><span class="line">    e[tot].next = h[u];</span><br><span class="line">    h[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> minf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || minf == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> minf;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v;</span><br><span class="line">        <span class="type">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (w &amp;&amp; !vis[v])&#123;</span><br><span class="line">            <span class="type">int</span> f = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(minf, w));</span><br><span class="line">            <span class="keyword">if</span> (f &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                e[i].w -= f;</span><br><span class="line">                e[i ^ <span class="number">1</span>].w += f;</span><br><span class="line">                <span class="keyword">return</span> f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="type">int</span> f = <span class="built_in">dfs</span>(s, INF);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Maxflow += f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="built_in">Add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">Add</span>(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FF</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（此代码经格式化）</p><h3 id="EK-算法"><a href="#EK-算法" class="headerlink" title="EK 算法"></a>EK 算法</h3><p>$\text{dfs}$ 太呆啦！我们在 $\text{FF}$ 算法的基础上使用 $\text{bfs}$ 找增广路，此时每次找的都是最短的增广路。</p><p>复杂度证明：</p><p>每次寻找增广路复杂度 $O(m)$。</p><p>我们接下来证明每条边最多成为 $O(n)$ 次路径流量上界（即是该残量网络中该路径上的容量最小值）</p><p>首先，对于 $(u,v)$ 是流量上界，有 $d_u&#x3D;d_v+1$。</p><p>而增广后，$r(u,v)&#x3D;0$，如果想要再次使用这条边，必须要走反向边反悔，即 $d’_u&#x3D;d’_v+1$。</p><p>但因为这条路径是最短的，所以 $d’_v\ge d_v$，所以 $d’_u\ge d_v+1$，推出 $d’_u\ge d_u+2$。</p><p>因此，每次增广都会使 $S$ 到 $(u,v)$ 的最短距离至少增加 $2$。</p><p>因为最短距离上界是 $O(n)$，所以增广次数上界也是 $O(n)$。对于所有边，总增广次数上界 $O(nm)$。</p><p>所以我们得到，$\text{EK}$ 算法的复杂度上界是 $O(nm^2)$。</p><p>实际上这个上界很松，可以跑过 $10^3-10^4$。</p><p>我的证明并不严格，更加好的证明可以上 $\text{wiki}$ 查看 qwq。</p><p>给出<a href="https://www.luogu.com.cn/problem/P3376">模板题</a>的代码实现。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,next;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],tot=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//这里 tot=1 是为后面反向边通过异或查找设置的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w)</span></span>&#123;</span><br><span class="line">    e[++tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"><span class="type">int</span> flag[<span class="number">205</span>][<span class="number">205</span>],pre[N],vis[N];</span><br><span class="line">ll d[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;<span class="comment">//找增广路</span></span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) vis[i]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    vis[s]=<span class="number">1</span>,d[s]=INF;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].v;</span><br><span class="line">            ll w=e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(w==<span class="number">0</span>||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            d[v]=<span class="built_in">min</span>(d[u],w);<span class="comment">//容量上界为路径剩余容量最小值</span></span><br><span class="line">            pre[v]=i;<span class="comment">//记录从哪条边来的</span></span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">            vis[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    ll z,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="keyword">if</span>(flag[x][y]==<span class="number">0</span>)&#123;<span class="comment">//去重边</span></span><br><span class="line">            <span class="built_in">add</span>(x,y,z);</span><br><span class="line">            <span class="built_in">add</span>(y,x,<span class="number">0</span>);</span><br><span class="line">            flag[x][y]=tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> e[flag[x][y]<span class="number">-1</span>].w+=z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()!=<span class="number">0</span>)&#123;<span class="comment">//有增广路</span></span><br><span class="line">        <span class="type">int</span> x=t;</span><br><span class="line">        <span class="keyword">while</span>(x!=s)&#123;<span class="comment">//一路跳回源点修改剩余容量</span></span><br><span class="line">            <span class="type">int</span> v=pre[x];</span><br><span class="line">            e[v].w-=d[t];</span><br><span class="line">            e[v^<span class="number">1</span>].w+=d[t];</span><br><span class="line">            x=e[v^<span class="number">1</span>].v;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=d[t];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络流入门&quot;&gt;&lt;a href=&quot;#网络流入门&quot; class=&quot;headerlink&quot; title=&quot;网络流入门&quot;&gt;&lt;/a&gt;网络流入门&lt;/h1&gt;&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF176B</title>
    <link href="http://example.com/2024/05/24/CF176B/"/>
    <id>http://example.com/2024/05/24/CF176B/</id>
    <published>2024-05-24T08:40:56.432Z</published>
    <updated>2024-05-24T08:41:14.247Z</updated>
    
    <content type="html"><![CDATA[<ul><li>字符串</li><li>DP</li></ul><p>【题意】</p><p>给定一个长度为 $n\le 1000$ 的字符串，再给定一个长度相等的目标串和<strong>非负</strong>整数 $k\le 10^5$，请问是否可以使用正好 $k$ 次操作，将原串变成目标串。</p><p>每一次操作选择一个位置 $p\in[1,n)$，然后将字符串变成 $[p+1,n]+[1,p]$。其中 $+$ 表示连接。</p><p>求操作方案数，取模。两个方案不同当且仅当至少有一步 $p$ 的选择不同。</p><p>【解析】</p><p>猜一个非常重要的结论：如果一次操作不行的话，那一定不行。</p><p>感性理解一下，字符之间的相对位置大体不变，一次不行的话多次也不行。</p><p>推广一下，也就是说做任意多次操作以后只需要做 $1$ 次操作就可以变成想要的样子。</p><p>所以我们可以先暴力求出一次操作能满足条件的方案数，记为 $\text{cnt}$。</p><p>则考虑 DP，设 $f_i$ 表示第 $i$ 步变成目标串的方案数，$g_i$ 表示第 $i$ 步没变成目标串的方案数。</p><p>推出转移方程 $f_i&#x3D;cnt\times g_{i-1}+(cnt-1)\times f_{i-1}$。表示有 $\text{cnt}$ 种方式从上一个的任意非目标串状态变成目标串状态，$\text{cnt-1}$ 种方式从上一个的目标串再操作一次还是目标串。</p><p>类似地，$g_i&#x3D;(n-cnt)\times f_{i-1}+(n-cnt-1)\times g_{i-1}$。</p><p>答案是 $f_k$，初始状态就是看看原串和目标串是否一样，是则 $f_0&#x3D;1$，否则 $g_0&#x3D;1$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">string a,b,s,t;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll f[N][<span class="number">2</span>],cnt;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t&gt;&gt;k;</span><br><span class="line">    n=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==t) cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">        cnt=<span class="number">1</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        a=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">        b=s.<span class="built_in">substr</span>(i,n-i);</span><br><span class="line">        a=b+a;</span><br><span class="line">        <span class="keyword">if</span>(a==t) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=(cnt*f[i<span class="number">-1</span>][<span class="number">1</span>]+(cnt<span class="number">-1</span>)*f[i<span class="number">-1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">        f[i][<span class="number">1</span>]=((n-cnt)*f[i<span class="number">-1</span>][<span class="number">0</span>]+(n-cnt<span class="number">-1</span>)*f[i<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[k][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;li&gt;DP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【题意】&lt;/p&gt;
&lt;p&gt;给定一个长度为 $n&#92;le 1000$ 的字符串，再给定一个长度相等的目标串和&lt;strong&gt;非负&lt;/strong&gt;整数 $k&#92;le 10^5$，请问是否可以使用正好 $k$ 次</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>0-1 Trie</title>
    <link href="http://example.com/2024/05/24/01trie/"/>
    <id>http://example.com/2024/05/24/01trie/</id>
    <published>2024-05-24T08:39:22.618Z</published>
    <updated>2024-05-24T08:39:42.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-1-Trie"><a href="#0-1-Trie" class="headerlink" title="0-1 Trie"></a>0-1 Trie</h1><p>大家都知道，$\text{trie}$ 很有用，具体可以见我的 <a href="">字符串笔记</a>，而 $\text{0-1 trie}$ 就是字符集只有 ${0,1}$ 的 $\text{trie}$，可以维护各种带修的异或问题。</p><p>那默认大家都会 $\text{trie}$ 了，我们直接讲点 $\text{0-1 trie}$ 的应用。</p><h3 id="应用-1-维护异或极值"><a href="#应用-1-维护异或极值" class="headerlink" title="应用 1 维护异或极值"></a>应用 1 维护异或极值</h3><p><a href="https://www.luogu.com.cn/problem/P4551">P4551 最长异或路径</a></p><p>对于此题，我们先预处理出根节点到每个点的异或值，记作 $a_u$，此时一条路径 $(u,v)$ 就转化为 $(root,u)\oplus(root,v)$，异或值就是 $a_u\oplus a_v$。</p><p>正确性在于，异或两个相同数时会变成 $0$，所以从 $lca(u,v)$ 往上的重复部分都被抵消了。</p><p>此时我们把问题转化为在一个数列中找异或值最大的两个数。</p><p>所以我们以每个 $a_i$ 的二进制从<strong>高位到低位</strong>建一棵 $\text{0-1 trie}$。对于每个 $a_i$，尝试每一位都在树上寻找与这一位不同的另一个方向，这样异或以后该位为 $1$。</p><p>如果有就统计上答案，否则先跟着走。因为二进制高位更大则一定更大，所以贪心正确。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> dis[N],cnt,ans;</span><br><span class="line"><span class="type">int</span> t[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Fo</span>(i,<span class="number">31</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t[p][c]) t[p][c]=++cnt;</span><br><span class="line">        p=t[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Fo</span>(i,<span class="number">31</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[p][c^<span class="number">1</span>]) p=t[p][c^<span class="number">1</span>],res=res*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> p=t[p][c],res=res*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) cin&gt;&gt;dis[i],<span class="built_in">insert</span>(dis[i]);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(dis[i]));</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用-2-维护异或和"><a href="#应用-2-维护异或和" class="headerlink" title="应用 2 维护异或和"></a>应用 2 维护异或和</h3><p>我们先来点定义：设 $t_{u,0&#x2F;1}$ 表示 $u$ 的 左右儿子，$w_u$ 表示 $u$ 子树中的点数，$s_u$ 表示以 $u$ 为根子树的异或和。</p><p>对于一些二进制数，从<strong>低位向高位</strong>建立 $\text{0-1 trie}$，然后类似动态开点线段树的方式维护。</p><p>异或和中当前位是 $1$ 的充要条件为：当前位恰有奇数个 $1$。所以我们只关心奇偶性，不关心具体的值。</p><ul><li>插入&#x2F;删除操作</li></ul><p>我们先把每一个数都往前补位补满 $0$，然后我们一直往下走，走到底以后将到根节点所有 $w$ 增加 $1$，递归往上处理信息</p><p>因为插入与删除几乎完全相同，区别只有走到底以后增加还是减少，所以合并成了一个函数。记得动态开点。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> x,<span class="type">int</span> d,<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>&amp;&amp;!p) p=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;Maxh) <span class="keyword">return</span> (<span class="type">void</span>)(w[p]=w[p]+op);</span><br><span class="line">    <span class="built_in">modify</span>(t[p][x&amp;<span class="number">1</span>],x&gt;&gt;<span class="number">1</span>,d+<span class="number">1</span>,op);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 $\text{op}$ 表示插入&#x2F;删除，$\text{Maxh}$ 是定义最大深度（二进制最大长度）。</p><ul><li>合并信息</li></ul><p>无非就是合并 $w$ 和 $s$，对于 $w$，就是两个子节点的和。</p><p>$s$ 要分类讨论一下，左儿子的信息可以直接乘二合并，右儿子则要看一下 $w$ 的奇偶性。</p><p>至于为什么乘二，儿子走到父亲的时候相当于在末尾加了一位，也就是左移一位。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    w[p]=s[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ls) w[p]+=w[ls],s[p]^=(s[ls]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(rs) w[p]+=w[rs],s[p]^=(s[rs]&lt;&lt;<span class="number">1</span>)|(w[rs]&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 $\text{ls,rs}$ 是 define 的左右儿子。</p><ul><li>全局加 $1$</li></ul><p>对于一个二进制，加 $1$ 操作实际就是从低位向高位找第一个 $0$，将其变为 $1$ 后把低位所有的 $1$ 变成 $0$。</p><p>比如 $1000111 + 1 &#x3D; 1001000$。</p><p>所以我们不停地交换左右儿子（把低位 $1$ 变成 $0$）直到交换后左二子（原右儿子）不是 $1$，表示这一位一开始是 $0$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ls,rs);</span><br><span class="line">    <span class="keyword">if</span>(ls) <span class="built_in">update</span>(ls);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>合并 $\text{0-1 trie}$</li></ul><p>与线段树合并相同，对于两个位置，有一个空时直接赋值为另一个，否则手动维护一下 $w$ 和 $s$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    w[a]=w[a]+w[b];</span><br><span class="line">    s[a]^=s[b];</span><br><span class="line">    t[a][<span class="number">0</span>]=<span class="built_in">merge</span>(t[a][<span class="number">0</span>],t[b][<span class="number">0</span>]);</span><br><span class="line">    t[a][<span class="number">1</span>]=<span class="built_in">merge</span>(t[a][<span class="number">1</span>],t[b][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P6018">P6018 [Ynoi2010] Fusion tree</a></p><p><del>前面的神秘题目背景是什么（晕）</del></p><p>我们考虑对于每个点开 $\text{0-1 trie}$，维护其<strong>直系子节点</strong>的信息。</p><p>以下记 $tire_x$ 表示 $x$ 的那棵树，记 $a_x$ 表示 $x$ 点的值。</p><p>操作 $1$，对于儿子，我们修改 $tire_x$ 即可，对于父亲，父亲的信息保存在父亲的父亲（祖父）的 $\text{0-1 trie}$ 里，所以修改 $a_{fa_x}$ 和 $\large trie_{fa_{fa_x}}$。</p><p>这里修改祖父时直接删除原父亲值并加入一个新的修改值即可。</p><p>操作 $2$，直接修改 $a_x$，并修改 $tire_{fa_x}$ 的信息。</p><p>操作 $3$，发现直接查询 $s_x\oplus a_x$ 并不正确，因为没有考虑父亲执行操作 $1$ 时对儿子 $a$ 值的影响。</p><p>暴力修改肯定不优，我们用一个标记数组来记录此点执行了几次操作 $1$。查询时异或上即可。</p><p>细节比较多，注意数据中有 $\text{hack}$ 点，根节点默认设 $1$ 就能避免。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls t[p][0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs t[p][1]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>,M=N*<span class="number">23</span>,Maxh=<span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> n,m,rt[N];</span><br><span class="line"><span class="type">int</span> t[M][<span class="number">2</span>],w[M],s[M],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    w[p]=s[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ls) w[p]+=w[ls],s[p]^=(s[ls]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(rs) w[p]+=w[rs],s[p]^=(s[rs]&lt;&lt;<span class="number">1</span>)|(w[rs]&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> x,<span class="type">int</span> d,<span class="type">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op==<span class="number">1</span>&amp;&amp;!p) p=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;Maxh) <span class="keyword">return</span> (<span class="type">void</span>)(w[p]=w[p]+op);</span><br><span class="line">    <span class="built_in">modify</span>(t[p][x&amp;<span class="number">1</span>],x&gt;&gt;<span class="number">1</span>,d+<span class="number">1</span>,op);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ls,rs);</span><br><span class="line">    <span class="keyword">if</span>(ls) <span class="built_in">update</span>(ls);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N],tag[N],fa[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++tot]=&#123;v,head[u]&#125;;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        fa[v]=u;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!fa[x]) <span class="keyword">return</span> a[x];</span><br><span class="line">    <span class="keyword">return</span> tag[fa[x]]+a[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> op,x,y;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">add</span>(x,y);</span><br><span class="line">        <span class="built_in">add</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(fa[i]) <span class="built_in">modify</span>(rt[fa[i]],a[i],<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            tag[x]++;</span><br><span class="line">            <span class="keyword">if</span>(x!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fa[fa[x]]) <span class="built_in">modify</span>(rt[fa[fa[x]]],<span class="built_in">find</span>(fa[x]),<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">                a[fa[x]]++;</span><br><span class="line">                <span class="keyword">if</span>(fa[fa[x]]) <span class="built_in">modify</span>(rt[fa[fa[x]]],<span class="built_in">find</span>(fa[x])+<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">update</span>(rt[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="keyword">if</span>(x!=<span class="number">1</span>) <span class="built_in">modify</span>(rt[fa[x]],<span class="built_in">find</span>(x),<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">            a[x]-=y;</span><br><span class="line">            <span class="keyword">if</span>(x!=<span class="number">1</span>) <span class="built_in">modify</span>(rt[fa[x]],<span class="built_in">find</span>(x),<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="type">int</span> res=s[rt[x]];</span><br><span class="line">            res^=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">            cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P6623">P6623 [省选联考 2020 A 卷] 树</a></p><p>考虑每个点建立 $\text{0-1 trie}$，一开始存权值，使用 dfs 自底向上合并子树以后全局加，表示距离的增加。</p><p><del>有没有人解释一下数据范围有什么特殊含义 qwq。</del></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls t[p][0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs t[p][1]</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">525100</span>,M=N*<span class="number">23</span>,Maxh=<span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> n,rt[N],a[N];</span><br><span class="line"><span class="type">int</span> t[M][<span class="number">2</span>],w[M],s[M],cnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    w[p]=s[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ls) w[p]+=w[ls],s[p]^=(s[ls]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(rs) w[p]+=w[rs],s[p]^=(s[rs]&lt;&lt;<span class="number">1</span>)|(w[rs]&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(d&gt;Maxh) <span class="keyword">return</span> (<span class="type">void</span>)(w[p]++);</span><br><span class="line">    <span class="built_in">modify</span>(t[p][x&amp;<span class="number">1</span>],x&gt;&gt;<span class="number">1</span>,d+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    w[a]=w[a]+w[b];</span><br><span class="line">    s[a]^=s[b];</span><br><span class="line">    t[a][<span class="number">0</span>]=<span class="built_in">merge</span>(t[a][<span class="number">0</span>],t[b][<span class="number">0</span>]);</span><br><span class="line">    t[a][<span class="number">1</span>]=<span class="built_in">merge</span>(t[a][<span class="number">1</span>],t[b][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ls,rs);</span><br><span class="line">    <span class="keyword">if</span>(ls) <span class="built_in">update</span>(ls);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++tot]=&#123;v,head[u]&#125;;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="built_in">update</span>(rt[v]);</span><br><span class="line">        rt[u]=<span class="built_in">merge</span>(rt[u],rt[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=<span class="number">1ll</span>*s[rt[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) cin&gt;&gt;a[i],<span class="built_in">modify</span>(rt[i],a[i],<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">2</span>,n) cin&gt;&gt;x,<span class="built_in">add</span>(x,i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-1-Trie&quot;&gt;&lt;a href=&quot;#0-1-Trie&quot; class=&quot;headerlink&quot; title=&quot;0-1 Trie&quot;&gt;&lt;/a&gt;0-1 Trie&lt;/h1&gt;&lt;p&gt;大家都知道，$&#92;text{trie}$ 很有用，具体可以见我的 &lt;a href=&quot;&quot;&gt;字符串</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>模拟赛2024-4-28</title>
    <link href="http://example.com/2024/05/04/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-4-28/"/>
    <id>http://example.com/2024/05/04/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-4-28/</id>
    <published>2024-05-04T10:23:56.089Z</published>
    <updated>2024-05-04T12:50:30.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="校内模拟-2024-4-28"><a href="#校内模拟-2024-4-28" class="headerlink" title="校内模拟-2024-4-28"></a>校内模拟-2024-4-28</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次 AK 校内比赛 qwq。</p><p>D 的 $\text{trick}$ 见过类似的才侥幸做出来。</p><h3 id="A"><a href="#A" class="headerlink" title="A"></a><a href="https://www.luogu.com.cn/problem/P3456">A</a></h3><p>简单题但是毒瘤题。</p><ul><li>搜索</li></ul><p>【题意】</p><p>给定矩阵，找值相等的八连通块，满足其八联通方向没有值更大&#x2F;更小。</p><p>分别求这两种连通块的个数。要做到 $O(n^2)$。</p><p>【解析】</p><p>搜索即可。开两个标记，表示是山峰&#x2F;山谷。</p><p>记得特判全相等的情况。</p><p>但不知道为什么，$\text{dfs}$ 在 LOJ 上会 MLE。</p><p>所以改成了 $\text{bfs}$ 卡空间，把所有能开在外面的开外面，卡了 $10$ 发才过。</p><p>幸亏没有罚时。</p><p>【代码】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1001</span>;</span><br><span class="line"><span class="type">int</span> n,flag,tmp;</span><br><span class="line">bitset&lt;N&gt; vis[N];</span><br><span class="line"><span class="type">int</span> a[N][N],ans1,ans2;</span><br><span class="line"><span class="type">bool</span> f1,f2;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> x,y;&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    f1=<span class="number">1</span>,f2=<span class="number">1</span>;</span><br><span class="line">    node u;</span><br><span class="line">    <span class="type">int</span> tx,ty;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">    vis[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">F</span>(i,<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">F</span>(j,<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                tx=u.x+i,ty=u.y+j;</span><br><span class="line">                <span class="keyword">if</span>(tx&lt;<span class="number">1</span>||tx&gt;n||ty&lt;<span class="number">1</span>||ty&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[tx][ty]&gt;a[u.x][u.y]) f1=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[tx][ty]&lt;a[u.x][u.y]) f2=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!vis[tx][ty])&#123;</span><br><span class="line">                    vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;tx,ty&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>) tmp=a[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]!=tmp) flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">bfs</span>(i,j);</span><br><span class="line">            ans1+=f1,ans2+=f2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a><a href="https://codeforces.com/contest/176/problem/B">B</a></h3><ul><li>字符串</li><li>DP</li></ul><p>【题意】</p><p>给定一个长度为 $n\le 1000$ 的字符串，再给定一个长度相等的目标串和<strong>非负</strong>整数 $k\le 10^5$，请问是否可以使用正好 $k$ 次操作，将原串变成目标串。</p><p>每一次操作选择一个位置 $p\in[1,n)$，然后将字符串变成 $[p+1,n]+[1,p]$。其中 $+$ 表示连接。</p><p>求操作方案数，取模。两个方案不同当且仅当至少有一步 $p$ 的选择不同。</p><p>【解析】</p><p>猜一个非常重要的结论：如果一次操作不行的话，那一定不行。</p><p>感性理解一下，字符之间的相对位置大体不变，一次不行的话多次也不行。</p><p>推广一下，也就是说做任意多次操作以后只需要做 $1$ 次操作就可以变成想要的样子。</p><p>所以我们可以先暴力求出一次操作能满足条件的方案数，记为 $\text{cnt}$。</p><p>则考虑 DP，设 $f_i$ 表示第 $i$ 步变成目标串的方案数，$g_i$ 表示第 $i$ 步没变成目标串的方案数。</p><p>推出转移方程 $f_i&#x3D;cnt\times g_{i-1}+(cnt-1)\times f_{i-1}$。表示有 $\text{cnt}$ 种方式从上一个的任意非目标串状态变成目标串状态，$\text{cnt-1}$ 种方式从上一个的目标串再操作一次还是目标串。</p><p>类似地，$g_i&#x3D;(n-cnt)\times f_{i-1}+(n-cnt-1)\times g_{i-1}$。</p><p>答案是 $f_k$，初始状态就是看看原串和目标串是否一样，是则 $f_0&#x3D;1$，否则 $g_0&#x3D;1$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">string a,b,s,t;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll f[N][<span class="number">2</span>],cnt;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t&gt;&gt;k;</span><br><span class="line">    n=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==t) cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">        cnt=<span class="number">1</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        a=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">        b=s.<span class="built_in">substr</span>(i,n-i);</span><br><span class="line">        a=b+a;</span><br><span class="line">        <span class="keyword">if</span>(a==t) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=(cnt*f[i<span class="number">-1</span>][<span class="number">1</span>]+(cnt<span class="number">-1</span>)*f[i<span class="number">-1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">        f[i][<span class="number">1</span>]=((n-cnt)*f[i<span class="number">-1</span>][<span class="number">0</span>]+(n-cnt<span class="number">-1</span>)*f[i<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[k][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a><a href="https://www.luogu.com.cn/problem/P2114">C</a></h3><ul><li>位运算</li><li>贪心</li></ul><p>【题意】</p><p>从 $[0,m]$ 中选择一个整数，使其经过 $n$ 次操作后的结果最大，求此最大值。</p><p>对于每一次操作，让原数执行与给定数按位与、按位或、按位异或中的一种（操作类型给定）。</p><p>【解析】</p><p>既然是位运算，考虑最后高位是 $1$ 则整体更大，启示我们从高往低考虑。贪心地想，这一位一开始要么是 $0$，要么是 $1$，那么我们分别枚举即可。</p><p>可以使用两个变量分别是 $0$ 和 $-1$，代表二进制的全 $0$ 和全 $1$，进行操作以后从高位向低位枚举，如果一开始是 $0$ 这一位是 $1$，那直接加答案，否则一开始是 $1$ 这一位是 $1$，加答案，同时判断没有超过 $m$ 的限制。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> ans,tmp1,tmp2;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    tmp1=<span class="number">0</span>,tmp2=<span class="number">-1</span>;<span class="comment">//000000000,1111111111</span></span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) tmp1&amp;=t,tmp2&amp;=t;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;O&#x27;</span>) tmp1|=t,tmp2|=t;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;X&#x27;</span>) tmp1^=t,tmp2^=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fo</span>(i,<span class="number">29</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((tmp1&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((tmp2&gt;&gt;i)&amp;<span class="number">1</span>&amp;&amp;m&gt;=(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">            ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            m-=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a><a href="https://www.luogu.com.cn/problem/P1129">D</a></h3><ul><li>网络流</li><li>二分图</li></ul><p>【题意】</p><p>给定一个 $01$ 方阵，操作可以交换任意行列，问最终是否可以让左上到右下对角线全为 $1$。</p><p>【解析】</p><p>经典建模。既然要把对角线全变成 $1$，那就是每个行上对应每个列都匹配了，由此想到二分图最大匹配。</p><p>考虑把行当作左部点，列当作右部点，然后原矩阵里的 $1$ 行向列连边，源点连行，列连汇点。</p><p>正确性在于，交换行列就是匹配过程，总边数不改变，最大流为 $n$ 时满流有解。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,s,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,next,w;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">    e[++tot]=&#123;u,head[v],<span class="number">0</span>&#125;;</span><br><span class="line">    head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N],now[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">1</span>,now[s]=head[s],q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!dis[v]&amp;&amp;e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">                now[v]=head[v];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                <span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> sum;</span><br><span class="line">    ll res=<span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;i=now[u];i&amp;&amp;sum;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>((dis[v]==dis[u]+<span class="number">1</span>)&amp;&amp;e[i].w)&#123;</span><br><span class="line">            tmp=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(sum,w));</span><br><span class="line">            <span class="keyword">if</span>(!tmp) dis[v]=<span class="number">0</span>;</span><br><span class="line">            e[i].w-=tmp,e[i^<span class="number">1</span>].w+=tmp;</span><br><span class="line">            sum-=tmp,res+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tot=<span class="number">1</span>;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(now,<span class="number">0</span>,<span class="built_in">sizeof</span>(now));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    s=n*<span class="number">2</span>+<span class="number">1</span>,t=s+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">add</span>(s,i,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i+n,t,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">F</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="built_in">add</span>(i,j+n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) ans+=<span class="built_in">dfs</span>(s,INF);</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;=n) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;校内模拟-2024-4-28&quot;&gt;&lt;a href=&quot;#校内模拟-2024-4-28&quot; class=&quot;headerlink&quot; title=&quot;校内模拟-2024-4-28&quot;&gt;&lt;/a&gt;校内模拟-2024-4-28&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;</summary>
      
    
    
    
    
    <category term="比赛总结" scheme="http://example.com/tags/%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>字符串入门</title>
    <link href="http://example.com/2024/04/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2024/04/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-04-02T14:41:21.940Z</published>
    <updated>2024-05-24T09:54:24.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串入门"><a href="#字符串入门" class="headerlink" title="字符串入门"></a>字符串入门</h1><h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>DFA，即确定有限状态自动机。用于判断输入的字符串是否符合要求。所有的字符串算法都是构造 DFA，结构有点像图灵机。</p><p>先给点定义：</p><ul><li>状态集 $Q$（有限）：若将自动机看成图，那么状态是顶点。</li><li>字符集 $\sum$：满足自动机要求的字符集。</li><li>可接受状态集 $F\subseteq Q$：是满足要求的状态。</li><li>初始状态 $q_0\in Q$：是初始空状态。</li><li>转移函数 $\delta$：$\delta\times \sum\rightarrow Q$ 是转移函数。</li></ul><p>整个算法流程就是，从初始状态 $q_0$ 出发，每次输入字符 $c$，并通过转移函数 $\delta$ 转移。最后若状态为 $F$，那么字符串符合要求。</p><h3 id="例题1：构造判断二进制数奇偶的-DFA"><a href="#例题1：构造判断二进制数奇偶的-DFA" class="headerlink" title="例题1：构造判断二进制数奇偶的 DFA"></a>例题1：构造判断二进制数奇偶的 DFA</h3><p>因为二进制数的奇偶性只与最后一位数是 $0$ 还是 $1$ 有关。所以这里构造的 DFA 用 $q$ 表示当前二进制数的奇偶性，每次输入的字符判断，如果是与当前 $q$ 相同就不变，否则转移到另一个。</p><p><img src="/../../../../img/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="看个图"></p><hr><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>简单来说，就是通过一个函数（即 $\text{Hash}$）把字符串映射到整数，用来快速判断字符串相等。</p><p>其实我个人感觉 $\text{Hash}$ 虽然简单，但在不少题目中都挺有用的，比直接用 $\text{map}$ 少一个 $\log$。</p><p>具体实现的话，通常是使用多项式 $\text{Hash}$，也可以看成进制转换。设 $H(s)&#x3D;\sum_{i&#x3D;1}^ns_i\times base^{n-i}\ (mod\ M)$。</p><p>此时对于一个串 $\text{abcd}，H(abcd)&#x3D;a\times base^3+b\times base^2+c\times base+d$。</p><p>可以证明（我不会），模数为大质数的时候冲突概率最小。一般为保证正确率使用双模哈希，即两个模数得出的 $\text{Hash}$ 值都相等的情况下才相等。不过这样常数比较大，我喜欢用 $\text{unsigned long long}$ 自然溢出，代码要好写很多。</p><p>当询问子串 $\text{Hash}$ 时，重新计算的话就跟朴素暴力复杂度相同了，于是我们采取预处理的策略。我们使用类似前缀和的方式，设 $H_i&#x3D;\sum_{j&#x3D;1}^is_j^{i-j}$。这样要查询子串 $[l,r]$ 的 $\text{Hash}$ 值时，只需要用 $H_r-H_{l-1}\times base^{r-l+1}$。具体不赘述，读者自证不难。</p><h3 id="例题1-最长回文子串"><a href="#例题1-最长回文子串" class="headerlink" title="例题1 最长回文子串"></a>例题1 最长回文子串</h3><p><a href="https://www.luogu.com.cn/problem/P3805">manacher 模板</a>。</p><p>这个题的正解是 $\text{manacher}$ 线性解决，但是如果忘了怎么写，可以用二分+哈希水过。</p><p>复杂度是 $O(n\log n)$ 的，只需要加一个特判即可通过。特判是如果当前长度不匹配直接跳过，减少二分次数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ull base=<span class="number">131</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">ull h1[N],h2[N],p[N];</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="function">ull <span class="title">hash1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h1[r]-h1[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">hash2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h2[l]-h2[r+<span class="number">1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正反处理哈希</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        p[i]=p[i<span class="number">-1</span>]*base;</span><br><span class="line">        h1[i]=h1[i<span class="number">-1</span>]*base+(ull)s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        h2[i]=h2[i+<span class="number">1</span>]*base+(ull)s[i];</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">min</span>(n-i+<span class="number">1</span>,i<span class="number">-1</span>)+<span class="number">1</span>,l=ans/<span class="number">2</span><span class="number">-1</span>,mid;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=<span class="number">0</span>||<span class="built_in">hash1</span>(i-l,i<span class="number">-1</span>)==<span class="built_in">hash2</span>(i,i+l<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line">                mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">hash1</span>(i-mid,i<span class="number">-1</span>)==<span class="built_in">hash2</span>(i,i+mid<span class="number">-1</span>)) l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,l*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r=<span class="built_in">min</span>(n-i,i<span class="number">-1</span>)+<span class="number">1</span>,l=ans/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=<span class="number">0</span>||<span class="built_in">hash1</span>(i-l,i<span class="number">-1</span>)==<span class="built_in">hash2</span>(i+<span class="number">1</span>,i+l))&#123;</span><br><span class="line">            <span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line">                mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">hash1</span>(i-mid,i<span class="number">-1</span>)==<span class="built_in">hash2</span>(i+<span class="number">1</span>,i+mid)) l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,l*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举回文中心，二分长度奇数/偶数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>字典树，<del>就是像字典的树，</del> 是一种用来处理字符串前缀的数据结构（当然也可以处理一些数据）。</p><p>其结构是点为状态，边为转移。放到 DFA 上说，初始状态为 $q_0$，然后一个字符串中每读入一个字符就往后找并新建状态，转移就是这个字符。剩下的字符串，先找是否有状态可转移，没有再新建。</p><p>假设单词为：b，abc，abd，bcd，abcd，efg，hii</p><p><img src="/../../../../img/%E5%AD%97%E5%85%B8%E6%A0%912.png" alt="看个图"></p><p>模板题的修改查询代码（有点像动态开点线段树）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> x-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> x-<span class="string">&#x27;a&#x27;</span>+<span class="number">26</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x-<span class="string">&#x27;0&#x27;</span>+<span class="number">52</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=<span class="built_in">f</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(!t[p][c]) t[p][c]=++tot;</span><br><span class="line">        p=t[p][c],cnt[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">        <span class="type">int</span> c=<span class="built_in">f</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(!t[p][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p=t[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题1-P4551-最长异或路径"><a href="#例题1-P4551-最长异或路径" class="headerlink" title="例题1 P4551 最长异或路径"></a>例题1 <a href="https://www.luogu.com.cn/problem/P4551">P4551 最长异或路径</a></h3><p>【题意】</p><p>给定一棵带边权树，求树上异或值最大的路径，路径的异或值定义为路径上边的异或和。输出最大值。</p><p>【解析】</p><p>先考虑路径异或和的转化，用 $w$ 表示，则 $w(u,v)&#x3D;w(u,root)\oplus w(v,root)$。所以对于每一个点 $u$，要寻找与 $w(u,root)$ 异或值最大的 $w(v,root)$。那么我们先把所有 $w(u,root)$ 处理出来，然后根据二进制建字典树</p><p>一个二进制数要尽可能大，那就要让高位尽可能为 $1$，所以异或起来为 $1$ 代表两位不同，也就是说，从根开始向下搜索，尽可能找与 $w(u,root)$ 当前位不同的子树，这样保证最大。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,next,w;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot].v=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N*<span class="number">32</span>],cnt,ans;</span><br><span class="line"><span class="type">int</span> t[N*<span class="number">32</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]^e[i].w;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Fo</span>(i,<span class="number">30</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t[p][c]) t[p][c]=++cnt;</span><br><span class="line">        p=t[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Fo</span>(i,<span class="number">30</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[p][c^<span class="number">1</span>])&#123;</span><br><span class="line">            tmp=tmp*<span class="number">2</span>+(c^<span class="number">1</span>);</span><br><span class="line">            p=t[p][c^<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp=tmp*<span class="number">2</span>+c;</span><br><span class="line">            p=t[p][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp^x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    tot=ans=<span class="number">0</span>;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">add</span>(x,y,z);</span><br><span class="line">        <span class="built_in">add</span>(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) <span class="built_in">insert</span>(dis[i]);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(dis[i]));</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP 是三位科学家共同设计的<strong>单模式串匹配算法</strong>。简单来说，就是用来快速查询字符串 $S$ 在 $T$ 中的出现次数、位置等信息。</p><p>我们定义一个字符串的前缀函数 $\pi$，$\pi_i$ 表示字符串 $S$（下标从 $0$ 开始）$s[0,i]$ 中最长的真前缀等于真后缀的长度。特别地，默认 $\pi_0&#x3D;0$。</p><p>举个例子，对于 $S&#x3D;abcabca$，其前缀函数为 $[0,0,0,1,2,3,4]$。详细过程可自行模拟。</p><p>朴素计算前缀函数时间复杂度是 $O(nm)$ 的，十分不优秀。考虑优化的话，我们发现没必要在失配以后从头匹配，可以直接在某个匹配了一部分字符的基础上再次尝试。根据这个想法，KMP 算法如下。</p><p>先预处理出前缀函数，再每次根据前缀函数匹配，失配则从当前位置的前缀函数位置开始往后匹配。时间复杂度 $O(n+m)$（但我并不会证明）。</p><p>正确性在于：每次找到前缀函数，前缀函数开始的一些字符与当前匹配好的一些字符是相等的，所以无错。</p><p>匹配部分（代码中的 $nex$ 数组就是前缀函数，$a$ 是文本串，$b$ 是模式串）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;b[j+<span class="number">1</span>]!=a[i]) j=nex[j];</span><br><span class="line">    <span class="comment">// 失配了，跳前缀函数</span></span><br><span class="line">    <span class="keyword">if</span>(b[j+<span class="number">1</span>]==a[i]) ++j;</span><br><span class="line">    <span class="comment">// 成功了，下一位</span></span><br><span class="line">    <span class="keyword">if</span>(j==m) ans[++cnt]=i-m+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 匹配完成，记录答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理怎么做？自己跟自己匹配！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;b[j+<span class="number">1</span>]!=b[i]) j=nex[j];</span><br><span class="line">    <span class="keyword">if</span>(b[j+<span class="number">1</span>]==b[i]) ++j;</span><br><span class="line">    nex[i]=j;</span><br><span class="line">    <span class="comment">// 记录当前匹配到了哪一位，即前缀函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板题完整代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> nex[N],ans[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(a+<span class="number">1</span>),m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;b[j+<span class="number">1</span>]!=b[i]) j=nex[j];</span><br><span class="line">        <span class="keyword">if</span>(b[j+<span class="number">1</span>]==b[i]) ++j;</span><br><span class="line">        nex[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;b[j+<span class="number">1</span>]!=a[i]) j=nex[j];</span><br><span class="line">        <span class="keyword">if</span>(b[j+<span class="number">1</span>]==a[i]) ++j;</span><br><span class="line">        <span class="keyword">if</span>(j==m) ans[++cnt]=i-m+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i) cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i) cout&lt;&lt;nex[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题1-P3426-POI2005-SZA-Template"><a href="#例题1-P3426-POI2005-SZA-Template" class="headerlink" title="例题1 P3426 [POI2005] SZA-Template"></a>例题1 <a href="https://www.luogu.com.cn/problem/P3426">P3426 [POI2005] SZA-Template</a></h3><p>【解析】</p><p>先求出前缀函数，再考虑 DP。设 $f_i$ 表示到 $i$ 的答案，则 $f_i$ 的取值只有 $i$ 或者 $f_{\pi_i}$，因为至少要对 $\pi_i$ 覆盖才能覆盖 $i$。考虑什么时候为 $f_{\pi_i}$（此时答案肯定不劣），当且仅当有一个 $f_j&#x3D;f_{\pi_i}，i-j\le \pi_i$，表示既然要求覆盖 $i$，那么 $s[0,\pi_i]&#x3D;s[i-\pi_i+1,i]$，也就是如果在 $[i-\pi_i+1,i]$ 内也可以用 $\pi_i$ 覆盖就可以覆盖 $i$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> fail[N],t[N],f[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j=fail[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) ++j;</span><br><span class="line">        fail[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>]=t[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        f[i]=i;</span><br><span class="line">        <span class="keyword">if</span>(t[f[fail[i]]]&gt;=i-fail[i]) f[i]=f[fail[i]];</span><br><span class="line">        t[f[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><p>设 $sa_i$ 表示按字典序排序后第 $i$ 小的后缀的编号，$rk_i$ 表示后缀 $i$ 的排名。</p><p>其中 $sa$ 数组也就是后缀数组，算法的本质就是快速求 $sa$ 数组。</p><p>两个数组满足：$sa[rk[i]]&#x3D;rk[sa[i]]&#x3D;i$。其实就是互为反数组（类似反函数）。</p><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>就是比较朴素，将 $n$ 个后缀直接 $\text{sort}$ 排序。排序复杂度是 $O(n\log n)$，再加上字符串排序比较字典序是 $O(n)$ 的，总复杂度 $O(n^2\log n)$。</p><h3 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h3><p>直接排序复杂度不能接受，考虑倍增优化。</p><p>首先对字符串 $s$ 的所有长度为 $1$ 的子串排序得到初始的 $sa$ 和 $rk$。</p><p>接下来，枚举次幂（设当前倍增到 k），那么用上一次得到的 $rk_i$ 和 $rk_{i+k}$ 作为第一关键字与第二关键字（如果没有第二关键字直接补 $0$），$\text{sort}$ 排序得到新的 $sa$。</p><p>因为排序后 $rk_i$ 表示的是 $[i,i+k-1]$ 的信息，而 $rk_{i+k}$ 表示 $[i+k+1,i+2*k]$ 的信息，所以合并是正确的。</p><p>放个图方便理解。</p><p><img src="/../../../../img/sa.png" alt="看个图"></p><p>倍增的复杂度是 $O(\log n)$，每次 $\text{sort}$ 是 $O(n\log n)$，总时间复杂度 $O(n\log^2n)$。</p><h3 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h3><p>$\text{sort}$ 是 $O(n\log n)$ 的，使用基数排序 $O(n)$，总复杂度 $O(n\log n)$。</p><p>贴个代码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m=<span class="number">122</span>,cnt;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> x[N],y[N],sa[N],c[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (y[i]==y[j])&amp;&amp;(y[i+w]==y[j+w]);</span><br><span class="line">    <span class="comment">//判断是否相等，即第一关键字与第二关键字都相等</span></span><br><span class="line">&#125;<span class="comment">//这个函数用来寻址优化（卡常）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) c[x[i]=s[i]]++;</span><br><span class="line">    <span class="comment">// x[i] 表示第一关键字，c 是桶用来记录第一关键字的数量</span></span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">2</span>,m) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 前缀和，这样处理以后保证字典序越大 c 数组值越大，用来处理 sa</span></span><br><span class="line">    <span class="built_in">Fo</span>(i,n,<span class="number">1</span>) sa[c[x[i]]--]=i;</span><br><span class="line">    <span class="comment">// 第一遍基数排序，c-- 保证有重复时编号不一样</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;;k&lt;&lt;=<span class="number">1</span>,m=cnt)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// y 表示第二关键字</span></span><br><span class="line">        <span class="built_in">F</span>(i,n-k+<span class="number">1</span>,n) y[++cnt]=i;</span><br><span class="line">        <span class="comment">// 最后 k 个没有第二关键字，直接放进来</span></span><br><span class="line">        <span class="built_in">F</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(sa[i]&gt;k) y[++cnt]=sa[i]-k;</span><br><span class="line">        <span class="comment">// 剩下的枚举排名，如果可以作为第二关键字就放进来</span></span><br><span class="line">        <span class="built_in">F</span>(i,<span class="number">1</span>,m) c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">F</span>(i,<span class="number">1</span>,n) c[x[i]]++;</span><br><span class="line">        <span class="built_in">F</span>(i,<span class="number">2</span>,m) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">Fo</span>(i,n,<span class="number">1</span>) sa[c[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 与第一遍排序类似，注意这里的 x[y[i]]，表示元素变成了 y1-yn</span></span><br><span class="line">        <span class="built_in">F</span>(i,<span class="number">1</span>,n) y[i]=x[i];</span><br><span class="line">        <span class="comment">// y 数组暂时没用，临时存 x</span></span><br><span class="line">        cnt=<span class="number">1</span>,x[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">F</span>(i,<span class="number">2</span>,n) x[sa[i]]=<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],k)?cnt:(++cnt);</span><br><span class="line">        <span class="comment">// 根据排序的结果处理下一次排序第一关键字</span></span><br><span class="line">        <span class="keyword">if</span>(cnt==n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果没有重复排名了，也就是排序好了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">SA</span>();</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串入门&quot;&gt;&lt;a href=&quot;#字符串入门&quot; class=&quot;headerlink&quot; title=&quot;字符串入门&quot;&gt;&lt;/a&gt;字符串入门&lt;/h1&gt;&lt;h2 id=&quot;DFA&quot;&gt;&lt;a href=&quot;#DFA&quot; class=&quot;headerlink&quot; title=&quot;DFA&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF161D</title>
    <link href="http://example.com/2024/04/01/CF161D/"/>
    <id>http://example.com/2024/04/01/CF161D/</id>
    <published>2024-04-01T15:06:46.774Z</published>
    <updated>2024-04-01T15:06:59.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CF161D"><a href="#CF161D" class="headerlink" title="CF161D"></a>CF161D</h3><p>点分&#x2F;长链剖分&#x2F;dsu 随便过。</p><p>但注意到数据范围不强，考虑 $O(nk)$ 的复杂度，可以树形DP。设 $f_{u,i}$ 表示以 $u$ 为根，子树中离 $u$ 路径长度为 $i$ 的点数。</p><p>统计答案时考虑每个的贡献是 $f_{u,j}\times f_{v,k-i-j}$（$0\le j&lt;k$）。然后再转移 $f_{u,j+1}&#x3D;\sum_{v\in u}f_{v,j}$。</p><p>这样的正确性在于，每次统计答案时都是新的和当前的统计，再把新的更新，不重不漏，有点像枚举两点时 $j$ 从 $i+1$ 开始枚举。第一遍没过就是这里没考虑好，shaber 了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i) ans+=(f[u][i]*f[v][k-i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i) f[u][i+<span class="number">1</span>]+=f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CF161D&quot;&gt;&lt;a href=&quot;#CF161D&quot; class=&quot;headerlink&quot; title=&quot;CF161D&quot;&gt;&lt;/a&gt;CF161D&lt;/h3&gt;&lt;p&gt;点分&amp;#x2F;长链剖分&amp;#x2F;dsu 随便过。&lt;/p&gt;
&lt;p&gt;但注意到数据范围不强，考虑 $O(nk)</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>模拟赛2024-3-28</title>
    <link href="http://example.com/2024/04/01/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-3-28/"/>
    <id>http://example.com/2024/04/01/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-3-28/</id>
    <published>2024-04-01T15:04:41.028Z</published>
    <updated>2024-07-01T11:46:23.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="校内模拟-2024-3-28"><a href="#校内模拟-2024-3-28" class="headerlink" title="校内模拟-2024-3-28"></a>校内模拟-2024-3-28</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><a href="https://codeforces.com/contest/161/problem/D">原题链接</a></p><p>【题意】</p><p>求树上距离（无边权）为 $k$ 的无序点对数。</p><p>$1\le n\le 5\times 10^4,1\le k\le 500$。</p><p>【解析】</p><p>这题我做过（惊恐）于是场上秒了。</p><p>可以左转<a href="https://jkyak.github.io/2024/04/01/CF161D/">我的题解</a>。</p><p>我的做法是 DP，复杂度 $O(nk)$。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p><a href="https://codeforces.com/contest/592/problem/D">原题链接</a></p><p>【题意】</p><p>给定一棵无边权的树，树上有 $m$ 个关键点，你要选择其中一个出发，到达其余所有关键点，路径（显然）可重复。费用定义为经过边的总数，求最小费用和对应的出发点（多个费用相同的点取最小）。</p><p>【解析】</p><p>容易发现，答案一定是一些走两遍的路径和一些走一遍的路径组成的，所以为了最小化答案，走一遍的路径就是直径。答案就是 （要经过的点数 $-1$）$\times 2$ $-$ 直径。</p><p>猜到这个结论就好想了，考虑如果要经过一个点，当且仅当其子树内有关键点，所以从直径开始 dfs 即可。</p><p>别忘了特判只有一个点的情况。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=x;i&lt;=y;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,x,y) for(int i=x;i&gt;=y;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x,y) memset(x,y,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> st[N],f[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    f[u]=dis;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        st[u]|=<span class="built_in">dfs</span>(v,u,dis+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        e[x].<span class="built_in">eb</span>(y);</span><br><span class="line">        e[y].<span class="built_in">eb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        st[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(st[i]&amp;&amp;f[i]&gt;f[c1]) c1=i;</span><br><span class="line">    <span class="built_in">dfs</span>(c1,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(f[i]&gt;f[c2]) c2=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(c1,c2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;(cnt<span class="number">-1</span>)*<span class="number">2</span>-f[c2]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p><a href="https://www.luogu.com.cn/problem/P1092">原题链接</a></p><p>【题意】</p><p>给定 $3$ 个长为 $n$ 的字符串，串中的字符表示一个数（如 ‘A’ 表示相同的一个数）。在 $n$ 进制下，前两个字符串代表的数的和等于第三个串代表的数。求每个字符 $c$ 代表的唯一数 $x$（’A’ $\le c\le$ ‘Z’,$0\le x\le 9$）</p><p>【解析】</p><p>先考虑爆搜。其实真的就是爆搜，从低位到高位枚举，最后再判断是否可行。可以获得 $40$ 分的好成绩（我考场就是这样的）。</p><p>我们想想能不能优化一下爆搜，剪一下枝。容易想到第一个显然的剪枝，最高位不能有进位，不然会超出 $n$ 位。这样是不够的，再考虑如果已经枚举出来一些数了，我们无法判断只是因为不知道是否有进位。</p><p>那么根据题目，进位最多为 $1$。所以判断一下，如果进不进位都不成立的话显然不行。</p><p>这样就可以通过本题，复杂度十分玄学，我不会算。听说正解是高斯消元，我也不会，先咕着。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string a,b,c;</span><br><span class="line"><span class="type">int</span> x[<span class="number">30</span>],y[<span class="number">30</span>],z[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">30</span>],nex[<span class="number">30</span>],st[<span class="number">30</span>],cnt,flag;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[x[<span class="number">0</span>]]+num[y[<span class="number">0</span>]]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">Fo</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> t1=num[x[i]],t2=num[y[i]],t3=num[z[i]];</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="number">-1</span>||t2==<span class="number">-1</span>||t3==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>((t1+t2)%n!=t3&amp;&amp;(t1+t2+<span class="number">1</span>)%n!=t3) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="number">0</span>,i=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((num[x[i]]+num[y[i]]+tmp)%n!=num[z[i]]) <span class="keyword">break</span>;</span><br><span class="line">        tmp=(num[x[i]]+num[y[i]]+tmp)/n;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (i&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">chk</span>()||flag) <span class="keyword">return</span> ;    </span><br><span class="line">    <span class="keyword">if</span>(s==n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">chk2</span>())&#123;</span><br><span class="line">            <span class="built_in">F</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fo</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            st[i]=<span class="number">1</span>;</span><br><span class="line">            num[nex[s]]=i;</span><br><span class="line">            <span class="built_in">dfs</span>(s+<span class="number">1</span>);</span><br><span class="line">            st[i]=<span class="number">0</span>;</span><br><span class="line">            num[nex[s]]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!st[x])&#123;</span><br><span class="line">        st[x]=<span class="number">1</span>;</span><br><span class="line">        nex[cnt++]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">-1</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        x[i]=(<span class="type">int</span>)a[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        y[i]=(<span class="type">int</span>)b[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        z[i]=(<span class="type">int</span>)c[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fo</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">init</span>(x[i]);</span><br><span class="line">        <span class="built_in">init</span>(y[i]);</span><br><span class="line">        <span class="built_in">init</span>(z[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) st[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p><a href="https://www.luogu.com.cn/problem/P4178">原题链接</a></p><p>【题意】</p><p>给定一棵 $n$ 个节点的树，每条边有边权，求出树上两点距离小于等于 $k$ 的点对数量。</p><p>【解析】</p><p>跟第一题和板子题很像对吧（其实就是点分治板子）。记录所有出现过的距离，双指针尝试更新，容斥减掉子树内的答案并分治。复杂度 $O(n\ log^2n)$。</p><p>没啥好说的，很板。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,next,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> tot,rt,sum,cnt,ans;</span><br><span class="line"><span class="type">int</span> head[N],vis[N],mx[N],siz[N],dis[N],rem[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot].v=v;</span><br><span class="line">    e[tot].w=w;</span><br><span class="line">    e[tot].next=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    mx[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        mx[u]=<span class="built_in">max</span>(mx[u],siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    mx[u]=<span class="built_in">max</span>(mx[u],sum-siz[u]);</span><br><span class="line">    <span class="keyword">if</span>(mx[u]&lt;mx[rt]) rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    rem[++cnt]=dis[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]+e[i].w;</span><br><span class="line">        <span class="built_in">getdis</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    dis[u]=s;</span><br><span class="line">    <span class="built_in">getdis</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(rem+<span class="number">1</span>,rem+cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=cnt,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rem[l]+rem[r]&lt;=k)&#123;</span><br><span class="line">            res+=(r-l);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    ans+=<span class="built_in">calc</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        ans-=<span class="built_in">calc</span>(v,e[i].w);</span><br><span class="line">        mx[rt=<span class="number">0</span>]=inf;</span><br><span class="line">        sum=siz[v];</span><br><span class="line">        <span class="built_in">getroot</span>(v,u);</span><br><span class="line">        <span class="built_in">solve</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">add</span>(x,y,z);</span><br><span class="line">        <span class="built_in">add</span>(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    mx[rt]=sum=n;</span><br><span class="line">    <span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">solve</span>(rt);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>总而言之，这场模拟赛还是不错的，锻炼了我的点分（就是 B 题想到正解了没对很可惜，以后加强训练代码能力）。希望能越来越好，撒花！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;校内模拟-2024-3-28&quot;&gt;&lt;a href=&quot;#校内模拟-2024-3-28&quot; class=&quot;headerlink&quot; title=&quot;校内模拟-2024-3-28&quot;&gt;&lt;/a&gt;校内模拟-2024-3-28&lt;/h2&gt;&lt;h3 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; c</summary>
      
    
    
    
    
    <category term="比赛总结" scheme="http://example.com/tags/%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>斜率优化</title>
    <link href="http://example.com/2024/03/31/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2024/03/31/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</id>
    <published>2024-03-31T14:00:20.511Z</published>
    <updated>2024-07-01T11:47:12.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><ul><li>斜率优化，一般是在转移方程中当前为 $i$，枚举决策点 $j$，然后化简式子出现同时与 $i$ 和 $j$ 有关的项（如果没有可以单调队列）。这样的话有点像一次函数，形如 $y&#x3D;kx+b$，那么这里的 $kx$ 就是与$i$ 和 $j$ 有关的项（具体题目具体分析）。问题变成查询最有决策点。</li><li>如果式子中的 $x$ 与 $y$ 都有单调性，可以使用单调队列线性维护。否则有两种做法：维护凸壳并二分或李超树（也可以平衡树或 cdq 分治，但我不会，就不弄巧成拙了）。这些做法是带一个 log 的。</li></ul><p>经典套路：</p><blockquote><p>$1.$ 写出朴素转移方程。</p><p>$2.$ 化简并设出 $x,y,k,b$，根据所求决定维护上凸还是下凸（最大值还是最小值）。</p><p>$3.$ 看单调性决定维护方式。</p></blockquote><h3 id="单调队列维护"><a href="#单调队列维护" class="headerlink" title="单调队列维护"></a>单调队列维护</h3><h4 id="例题1-P3195-HNOI2008-玩具装箱"><a href="#例题1-P3195-HNOI2008-玩具装箱" class="headerlink" title="例题1 P3195 [HNOI2008] 玩具装箱"></a>例题1 <a href="https://www.luogu.com.cn/problem/P3195">P3195 [HNOI2008] 玩具装箱</a></h4><p>【题意】</p><p>给定一个序列，要求将其划分成若干段，一段划分为 $[i,j]$ 的费用为 $(j-i+\sum_{k&#x3D;i}^jC_k-L)^2$（这里的 $C_k$ 为给定数组，$L$ 为给定常量）。最小化划分序列的费用和。</p><p>【解析】</p><p>朴素的转移方程为：（设 $f_i$ 表示考虑到 $i$ 的答案，$s_i$ 表示 $C_i$ 的前缀和）<br>$$<br>f_i&#x3D;\min_{1\le j&lt;i}(f_j+[i-(j+1)+s_i-s_j-L]^2)<br>$$<br>换元并化简，设 $a_i&#x3D;s_i+i，b_i&#x3D;s_i+i+L+1$。<br>$$<br>\begin{aligned}<br>&amp;f_i&#x3D;\min_{1\le j&lt;i}(f_j+[a_i-b_j]^2)\\<br>&amp;f_i&#x3D;\min_{1\le j&lt;i}(f_j+a_i^2+b_j^2-2\times a_i\times b_j)<br>\end{aligned}<br>$$<br>先不管取 $\min$，先推式子，并把只与 $j$ 有关的移到一边，尝试分离 $i$ 和 $j$。<br>$$<br>\begin{aligned}<br>f_i&amp;&#x3D;f_j+a_i^2+b_j^2-2\times a_i\times b_j\\<br>f_j+b_j^2&amp;&#x3D;f_i-a_i^2+2\times a_i\times b_j<br>\end{aligned}<br>$$<br>我们发现，如果设 $y&#x3D;f_j+b_j^2，k&#x3D;2\times a_i，x&#x3D;b_j，b&#x3D;f_i-a_i^2$，那么方程变成了一个一次函数形式 $y&#x3D;kx+b$。所以要做的就是在二维平面中找一个斜率固定的直线使 $b$ 最小。</p><p>观察数据，$y&#x3D;f_j+b_j^2$ 和 $x&#x3D;b_j$ 都单调递增，所以使用单调队列优化，时空复杂度线性。</p><p>放个单调队列斜优的板子吧。</p><p>代码中没用 $\text{double}$，防止爆精度。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> n,l;</span><br><span class="line"><span class="type">int</span> s[N],f[N],q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[j]+s[j]*s[j]+<span class="number">2</span>*l*s[j])-(f[i]+s[i]*s[i]+<span class="number">2</span>*l*s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[j]-s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;l;</span><br><span class="line">    l=l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) cin&gt;&gt;x,s[i]=s[i<span class="number">-1</span>]+x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=s[i]+i;</span><br><span class="line">    <span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">2</span>*s[i];</span><br><span class="line">        <span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[h],q[h+<span class="number">1</span>])&lt;=<span class="built_in">down</span>(q[h],q[h+<span class="number">1</span>])*k) h++;</span><br><span class="line">        <span class="type">int</span> j=q[h];</span><br><span class="line">        f[i]=f[j]+(s[i]-s[j]-l)*(s[i]-s[j]-l);</span><br><span class="line">        <span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[t<span class="number">-1</span>],q[t])*<span class="built_in">down</span>(q[t],i)&gt;=<span class="built_in">up</span>(q[t],i)*<span class="built_in">down</span>(q[t<span class="number">-1</span>],q[t])) t--;</span><br><span class="line">        q[++t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此题类似的题：</p><p><a href="https://www.luogu.com.cn/problem/P3628">P3628 [APIO2010] 特别行动队</a></p><p><a href="https://www.luogu.com.cn/problem/P2365">P2365 任务安排</a></p><p><a href="https://www.luogu.com.cn/problem/P4360">P4360 [CEOI2004] 锯木厂选址</a></p><h4 id="例题2-P4072-SDOI2016-征途"><a href="#例题2-P4072-SDOI2016-征途" class="headerlink" title="例题2 P4072 [SDOI2016] 征途"></a>例题2 <a href="https://www.luogu.com.cn/problem/P4072">P4072 [SDOI2016] 征途</a></h4><p>【题意】</p><p>给定长度为 $n$ 的序列，将其划分为 $m$ 段，使得这 $m$ 段各自求和后的总方差最小，输出方差 $\times m^2$。</p><p>形式化地，设 $b_i&#x3D;\sum_{j&#x3D;l_i}^{r_i}a_j$，$v&#x3D;\frac{\sum_{i&#x3D;1}^m(b_i-\bar{b})^2}{m}$，求最小的 $v\times m^2$。其中 $\forall i\in [1,m-1]$，$l_{i+1}&#x3D;r_i+1$。</p><p>【解析】</p><p>推推柿子。<br>$$<br>\begin{aligned}<br>v&amp;&#x3D;\frac{\sum_{i&#x3D;1}^m(b_i-\bar{b})^2}{m}\\<br>&amp;&#x3D;\frac{(b_1-\bar{b})^2+ (b_2-\bar{b})^2+…+ (b_m-\bar{b})^2}{m}\\<br>&amp;&#x3D;\frac{m\times(\bar{b})^2+\sum_{i&#x3D;1}^mb_i^2-2\times \bar{b}\times\sum_{i&#x3D;1}^mb_i}{m}\\<br>&amp;&#x3D;\frac{m\times(\frac{\sum_{i&#x3D;1}^mb_i}{m})^2+\sum_{i&#x3D;1}^mb_i^2-2\times \frac{\sum_{i&#x3D;1}^mb_i}{m}\times\sum_{i&#x3D;1}^mb_i}{m}\\<br>&amp;&#x3D;\frac{\frac{(\sum_{i&#x3D;1}^mb_i)}{m}^2+\sum_{i&#x3D;1}^mb_i^2-2\times \frac{(\sum_{i&#x3D;1}^mb_i)^2}{m}}{m}\\<br>&amp;&#x3D;\frac{\sum_{i&#x3D;1}^mb_i^2- \frac{(\sum_{i&#x3D;1}^mb_i)^2}{m}}{m}\\<br>v\times m^2&amp;&#x3D;m\times\sum_{i&#x3D;1}^mb_i^2-(\sum_{i&#x3D;1}^mb_i)^2<br>\end{aligned}<br>$$<br>可以发现， $-(\sum_{i&#x3D;1}^mb_i)^2$ 无论怎么划分都不会变，都是 $-(\sum_{i&#x3D;1}^na_i)^2$，所以就变成最小化 $m\times\sum_{i&#x3D;1}^mb_i^2$。</p><p>考虑 DP 设 $f_{i,j}$ 表示走到 $a_i$，是第 $j$ 天的最小 $\sum_{}$（最后再乘 $m$）。那么朴素式子很好推（这里的 $s_i$ 表示 $a_i$ 的前缀和）：<br>$$<br>f_{i,j}&#x3D;\min_{1\le k&lt;i}(f_{k,j-1}+(s_i-s_k)^2)<br>$$<br>直接做是 $O(n^3)$ 的，发现这是斜率优化的经典形式，即<br>$$<br>\begin{aligned}<br>f_{i,j}&amp;&#x3D;\min_{1\le k&lt;i}(f_{k,j-1}+s_i^2+s_k^2-2\times s_i\times s_k)\\<br>f_{i,j}&amp;&#x3D;f_{k,j-1}+s_i^2+s_k^2-2\times s_i\times s_k\\<br>f_{k,j-1}+s_k^2&amp;&#x3D;f_{i,j}-s_i^2+2\times s_i\times s_k<br>\end{aligned}<br>$$</p><p>设 $y&#x3D;f_{k,j-1}+s_k^2,k&#x3D;2\times s_i,x&#x3D;s_k,b&#x3D;f_{i,j}-s_i^2$，变成一次函数形式，即可斜率优化。此题斜率优化是二维的，使用了单调队列。</p><p>放个二维斜率优化的板子。使用了辅助数组 $g$，优化成线性空间。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3005</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> s[N],q[N],f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (g[j]+s[j]*s[j])-(g[i]+s[i]*s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[j]-s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) cin&gt;&gt;x,s[i]=s[i<span class="number">-1</span>]+x,g[i]=s[i]*s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">1</span>;</span><br><span class="line">        q[<span class="number">1</span>]=j<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=j;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[h],q[h+<span class="number">1</span>])&lt;=<span class="built_in">down</span>(q[h],q[h+<span class="number">1</span>])*<span class="number">2</span>*s[i]) h++;</span><br><span class="line">            <span class="type">int</span> p=q[h];</span><br><span class="line">            f[i]=g[p]+(s[i]-s[p])*(s[i]-s[p]);</span><br><span class="line">            <span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[t<span class="number">-1</span>],q[t])*<span class="built_in">down</span>(q[t],i)&gt;=<span class="built_in">up</span>(q[t],i)*<span class="built_in">down</span>(q[t<span class="number">-1</span>],q[t])) t--;</span><br><span class="line">            q[++t]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) g[i]=f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m*f[n]-s[n]*s[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此题类似的题：</p><p><a href="https://www.luogu.com.cn/problem/P3648">P3648 [APIO2014] 序列分割</a></p><h3 id="李超线段树维护"><a href="#李超线段树维护" class="headerlink" title="李超线段树维护"></a>李超线段树维护</h3><p>李超线段树，用来维护直线或线段上的信息。简单来说就是个标记永久化的线段树。</p><p>例如，我们要维护一些直线，查询横坐标为 $x$ 时纵坐标的最大值。</p><p>先考虑维护修改，第一步判断中点信息，选那个更大的作为主要线段（这样保证不会更劣），第二步分别比较两端点，确定一下哪边更大，然后递归处理。</p><p>具体地，设 $g$ 为主要线段，$f$ 为修改线段，默认 $f_{mid}&lt;g_{mid}$。若 $f_l&gt;g_l$，说明左半边有交点，递归左二子，右边同理。若 $f_l&lt;g_l,f_r&lt;g_r$，则无需递归，$g$ 完全优于 $f$。</p><p><img src="/../../../../img/%E6%9D%8E%E8%B6%85%E6%A0%91.png" alt="放张图"></p><p>查询的话，就是标记永久化以后一路查询最值。</p><p>放个<a href="https://www.luogu.com.cn/problem/P4097">李超树板子</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="function">db <span class="title">Abs</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> (x&lt;<span class="number">0</span>)?-x:x;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">    db k,b;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="built_in">line</span>()&#123;k=<span class="number">0</span>,b=<span class="number">-1e18</span>;&#125;</span><br><span class="line">    <span class="built_in">line</span>(db h1,db z1,db h2,db z2,<span class="type">int</span> _id)&#123;</span><br><span class="line">        id=_id;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Abs</span>(h1-h2)&lt;eps) k=<span class="number">0</span>,b=<span class="built_in">max</span>(z1,z2);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k=(z2-z1)/(h2-h1);</span><br><span class="line">            b=z2-k*h2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">db <span class="title">val</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> k*x+b;&#125;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,line f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[p].id==<span class="number">0</span>) <span class="keyword">return</span> t[p]=f,<span class="built_in">void</span>();</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Abs</span>(t[p].<span class="built_in">val</span>(mid)-f.<span class="built_in">val</span>(mid))&lt;eps)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t[p].id&gt;f.id) <span class="built_in">swap</span>(f,t[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[p].<span class="built_in">val</span>(mid)&lt;f.<span class="built_in">val</span>(mid)) <span class="built_in">swap</span>(f,t[p]);</span><br><span class="line">        <span class="keyword">if</span>(f.<span class="built_in">val</span>(l)+eps&gt;t[p].<span class="built_in">val</span>(l)) <span class="built_in">insert</span>(p&lt;&lt;<span class="number">1</span>,l,mid,L,R,f);</span><br><span class="line">        <span class="keyword">if</span>(f.<span class="built_in">val</span>(r)+eps&gt;t[p].<span class="built_in">val</span>(r)) <span class="built_in">insert</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,f);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) <span class="built_in">insert</span>(p&lt;&lt;<span class="number">1</span>,l,mid,L,R,f);</span><br><span class="line">    <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=R) <span class="built_in">insert</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">line <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> t[p];</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    line res;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) res=<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> res=<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,k);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Abs</span>(res.<span class="built_in">val</span>(k)-t[p].<span class="built_in">val</span>(k))&lt;eps)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.id&lt;t[p].id) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> t[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">val</span>(k)&gt;t[p].<span class="built_in">val</span>(k)) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> t[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lans,h1,h2,z1,z2,x,tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T,op;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            cin&gt;&gt;h1&gt;&gt;z1&gt;&gt;h2&gt;&gt;z2;</span><br><span class="line">            h1=(h1+lans<span class="number">-1</span>)%<span class="number">39989</span>+<span class="number">1</span>;</span><br><span class="line">            h2=(h2+lans<span class="number">-1</span>)%<span class="number">39989</span>+<span class="number">1</span>;</span><br><span class="line">            z1=(z1+lans<span class="number">-1</span>)%<span class="number">1000000000</span>+<span class="number">1</span>;</span><br><span class="line">            z2=(z2+lans<span class="number">-1</span>)%<span class="number">1000000000</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(h1&gt;h2) <span class="built_in">swap</span>(h1,h2),<span class="built_in">swap</span>(z1,z2);</span><br><span class="line">            line c=<span class="built_in">line</span>(h1,z1,h2,z2,++tot);</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">40000</span>,h1,h2,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            x=(x+lans<span class="number">-1</span>)%<span class="number">39989</span>+<span class="number">1</span>;</span><br><span class="line">            lans=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">40000</span>,x).id;</span><br><span class="line">            cout&lt;&lt;lans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题1-P4027-NOI2007-货币兑换"><a href="#例题1-P4027-NOI2007-货币兑换" class="headerlink" title="例题1 P4027 [NOI2007] 货币兑换"></a>例题1 <a href="https://www.luogu.com.cn/problem/P4027">P4027 [NOI2007] 货币兑换</a></h4><p>【解析】</p><p>设 $f_i$ 表示第 $i$ 天最大的收益。</p><p>初始条件 $f_0&#x3D;s$，答案 $f_n$。</p><p>转移枚举上一个全买券的点 $j$，设 $y$ 表示第 $j$ 天买 $B$ 的数量，解方程。</p><p>$Rate_j\times y_j\times a_j+y_j\times b_j&#x3D;f_j$</p><p>得到 $y_j&#x3D;\large\frac{f_j}{Rate_j\times a_j+b_j}$</p><p>设 $x$ 表示买 $A$ 的数量，显然 $x_i&#x3D;Rate_j\times y_i$</p><p>转移方程 $f_i&#x3D;\max(f_{i-1},\max{a_i\times x_j+b_i\times y_j | j\in[1,i) } )$</p><p>提出 $b_i$，得到 $f_i&#x3D;\max(f_{i-1},b_i\times \max{\large\frac{a_i}{b_i}\small\times x_j+y_j})$</p><p>发现变成一次函数形式，即对于每个 $x_j,y_j$，查询 $\large\frac{a_i}{b_i}$ 处的最大值即可。</p><p>李超线段树。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">db <span class="title">val</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> t)</span></span>&#123;<span class="keyword">return</span> x[t]*k[i]+y[t];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">val</span>(l,id)&gt;<span class="built_in">val</span>(l,t[p])) t[p]=id;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">val</span>(mid,id)&gt;<span class="built_in">val</span>(mid,t[p])) <span class="built_in">swap</span>(id,t[p]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">val</span>(l,id)&gt;<span class="built_in">val</span>(l,t[p])) <span class="built_in">modify</span>(ls,id,l,mid);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(rs,id,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="built_in">val</span>(now,t[p]);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(now&lt;=mid) <span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">val</span>(now,t[p]),<span class="built_in">query</span>(ls,l,mid));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">val</span>(now,t[p]),<span class="built_in">query</span>(rs,mid+<span class="number">1</span>,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;IOS;</span><br><span class="line">    <span class="type">int</span> n,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    f[<span class="number">0</span>]=s;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;r[i],k[i]=a[i]/b[i],kk[i]=k[i];</span><br><span class="line">    <span class="built_in">sort</span>(k+<span class="number">1</span>,k+<span class="number">1</span>+n);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        now=<span class="built_in">lower_bound</span>(k+<span class="number">1</span>,k+n+<span class="number">1</span>,kk[i])-k;</span><br><span class="line">        f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],b[i]*<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n));</span><br><span class="line">        db tmp=a[i]*r[i]+b[i];</span><br><span class="line">        y[i]=f[i]/tmp;</span><br><span class="line">        x[i]=r[i]*y[i];</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>,i,<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此题类似的题：</p><p><a href="https://www.luogu.com.cn/problem/P2497">P2497 [SDOI2012] 基站建设</a></p><p><a href="https://www.luogu.com.cn/problem/P5504">P5504 [JSOI2011] 柠檬</a></p><p><a href="https://www.luogu.com.cn/problem/P4655">P4655 [CEOI2017] Building Bridges</a></p><hr><p><strong>完结撒花！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;斜率优化&quot;&gt;&lt;a href=&quot;#斜率优化&quot; class=&quot;headerlink&quot; title=&quot;斜率优化&quot;&gt;&lt;/a&gt;斜率优化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;斜率优化，一般是在转移方程中当前为 $i$，枚举决策点 $j$，然后化简式子出现同时与 $i$ 和 $j$ 有关</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF631E</title>
    <link href="http://example.com/2024/03/31/CF631E/"/>
    <id>http://example.com/2024/03/31/CF631E/</id>
    <published>2024-03-31T13:59:23.608Z</published>
    <updated>2024-07-01T11:47:10.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CF631E-Product-Sum"><a href="#CF631E-Product-Sum" class="headerlink" title="CF631E Product Sum"></a>CF631E Product Sum</h2><ul><li>斜率优化DP</li></ul><p><a href="https://codeforces.com/contest/631/problem/E">传送门</a></p><h3 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h3><p>模拟赛 D 题。感觉是个斜优的比较板的题。</p><p>开始写了一发错误的贪心，Wa on 9，后来改成 DP 才过。</p><p>场上过了 $5$ 个，拜谢 AK 爷 <a href="https://www.luogu.com.cn/user/593274">@Helloworld_wuyuze</a> <a href="https://www.luogu.com.cn/user/586905">@RailgunZzzz</a> <a href="https://www.luogu.com.cn/user/536743">@秦屎皇</a>。</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的序列，序列的价值定义为 $\sum_{i&#x3D;1}^na_i\times i$。允许至多一次操作，把一个元素移动到任意一个序列中的位置，求最大的序列价值。</p><p>$2\le n\le 2\times 10^5，|a_i|\le 10^6$。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>先考虑 naive 做法。对于每个 $a_i$，枚举其移动到的位置位置 $j$，每次计算贡献的变化，时间复杂度 $O(n^2)$。</p><p>具体地，分两种情况讨论。对于向前移动，即 $j&lt;i$，从 $i$ 移到 $j$ 后面，会使位于 $[j+1,i-1]$ 的元素贡献多一次，然后 $i$ 的贡献转化到了 $j+1$。</p><p>也就是 $s_{i-1}-s_{j}-(i-(j+1))\times a_i$。这里的 $s_i$ 表示 $a_i$ 的前缀和。</p><p>对于向后移动，移动到位置 $j$，会使 $[i+1,j]$ 的元素贡献少一次，再算上 $i$ 到 $j$ 的贡献。</p><p>$-(s_j-s_i)+(j-i)\times a_i$，即 $s_i-s_j+(j-i)\times a_i$。</p><p>尝试化简一下第一个式子。<br>$$<br>\begin{aligned}<br>&amp;s_{i-1}-s_{j}-(i-(j+1))\times a_i\\<br>&#x3D;&amp;s_{i-1}-s_j-(i-j-1)\times a_i\\<br>&#x3D;&amp;s_{i-1}-s_j+a_i-(i-j)\times a_i\\<br>&#x3D;&amp;s_i-s_j-(i-j)\times a_i\\<br>&#x3D;&amp;s_i-s_j+(j-i)\times a_i<br>\end{aligned}<br>$$<br>我们推导可以发现，向前移动与向后移动的式子等价。这样的话，两个转移被合并成了一个转移，方便很多。</p><p>我们还需要优化。把括号拆开，变成 $s_i-s_j+a_i\times j-a_i\times i$。发现此时的方程中只有一个与 $i,j$ 都有关的项 $a_i\times j$ 和几个只与 $i$ 或 $j$ 有关的项。是斜率优化的经典形式，此处不赘述斜优过程。</p><p>数据没有单调性，所以可以用二分凸包或者李超树维护。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>考场上没想到可以变一个式子，正反做了两遍，二分+栈。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> M=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">    <span class="type">int</span> k,b;</span><br><span class="line">    <span class="built_in">line</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">line</span>(<span class="type">int</span> _k,<span class="type">int</span> _b)&#123;</span><br><span class="line">        k=_k,b=_b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k*x+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> t1 s.size()-1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> t2 s.size()-2</span></span><br><span class="line">    vector&lt;line&gt; s;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(line x,line p1,line p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p2.b-x.b)*(p1.k-p2.k)&lt;=(p2.b-p1.b)*(x.k-p2.k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(line x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s.<span class="built_in">size</span>()&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">cmp</span>(x,s[t1],s[t2])) s.<span class="built_in">pop_back</span>();</span><br><span class="line">        s.<span class="built_in">eb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=t1;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[mid].<span class="built_in">calc</span>(x)&gt;=s[mid+<span class="number">1</span>].<span class="built_in">calc</span>(x)) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[r].<span class="built_in">calc</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> t1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> t2</span></span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n,res=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        res+=i*a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    t1.<span class="built_in">insert</span>(<span class="built_in">line</span>(<span class="number">1</span>,-f[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,-a[i]*i+f[i<span class="number">-1</span>]+t1.<span class="built_in">query</span>(a[i]));</span><br><span class="line">        t1.<span class="built_in">insert</span>(<span class="built_in">line</span>(i,-f[i<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    t2.<span class="built_in">insert</span>(<span class="built_in">line</span>(-n,-f[n]));</span><br><span class="line">    <span class="built_in">fo</span>(i,n<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,-a[i]*i+f[i]+t2.<span class="built_in">query</span>(-a[i]));</span><br><span class="line">        t2.<span class="built_in">insert</span>(<span class="built_in">line</span>(-i,-f[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans+res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赛后用李超树写了第二种实现，$k&#x3D;j,b&#x3D;-s_j$，查询 $x&#x3D;a_i$ 处的最值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> M=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> k[N],b[N],s[N],a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> k[i]*x+b[i];&#125;</span><br><span class="line"><span class="type">int</span> t[M&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">calc</span>(x,l)&gt;<span class="built_in">calc</span>(t[p],l)) t[p]=x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(x,mid)&gt;<span class="built_in">calc</span>(t[p],mid)) <span class="built_in">swap</span>(t[p],x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(x,l)&gt;<span class="built_in">calc</span>(t[p],l)) <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">calc</span>(x,r)&gt;<span class="built_in">calc</span>(t[p],r)) <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="built_in">calc</span>(t[p],x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">calc</span>(t[p],x);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">max</span>(res,<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(res,<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n,res=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        res+=i*a[i];</span><br><span class="line">        s[i]=a[i]+s[i<span class="number">-1</span>];</span><br><span class="line">        k[i]=i;</span><br><span class="line">        b[i]=-s[i];</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,-M,M,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="built_in">query</span>(<span class="number">1</span>,-M,M,a[i]);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,s[i]-a[i]*i+tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans+res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>完结撒花！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CF631E-Product-Sum&quot;&gt;&lt;a href=&quot;#CF631E-Product-Sum&quot; class=&quot;headerlink&quot; title=&quot;CF631E Product Sum&quot;&gt;&lt;/a&gt;CF631E Product Sum&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>AT_dp</title>
    <link href="http://example.com/2024/03/31/AT_dp/"/>
    <id>http://example.com/2024/03/31/AT_dp/</id>
    <published>2024-03-31T13:58:15.360Z</published>
    <updated>2024-07-01T11:47:11.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>DP 太菜了，刷 AT 经典 DP，前面的比较简单，从 J 开始吧 qwq</p><hr><h3 id="AT-dp-J"><a href="#AT-dp-J" class="headerlink" title="AT_dp_J"></a>AT_dp_J</h3><ul><li>期望 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_j">传送门</a></p><p>注意到 $a_i\leq3$，所以状态应该跟 $a_i$ 有关。考虑设 $f_{a,b,c,d}$ 表示有 $a$ 种剩余 $3$ 个的寿司，$b$ 种剩余 $2$ 个的寿司……</p><p>$$f_{a,b,c,d}&#x3D;1+\frac{a}{n}f_{a-1,b+1,c,d}+\frac{b}{n}f_{a,b-1,c+1,d}+\frac{c}{n}f_{a,b,c-1,d+1}+\frac{d}{n}f_{a,b,c,d}$$<br>整理并可得<br>$$f_{a,b,c,d}&#x3D;\frac{n}{n-d}+\frac{a}{n-d}f_{a-1,b+1,c,d}+\frac{b}{n-d}f_{a,b-1,c+1,d}+\frac{c}{n-d}f_{a,b,c-1,d+1}$$</p><p>这样是四维的，发现 $d&#x3D;n-(a+b+c)$，于是变成 $3$ 维，可以 $O(n^3)$ 的 DP，得到最终方程</p><p>$$f_{a,b,c}&#x3D;\frac{n}{a+b+c}+\frac{a}{a+b+c}f_{a-1,b+1,c}+\frac{b}{a+b+c}f_{a,b-1,c+1}+\frac{c}{a+b+c}f_{a,b,c-1}$$</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) cin&gt;&gt;x,a[x]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;++k)</span><br><span class="line">          <span class="keyword">if</span>(i+j+k)&#123;</span><br><span class="line">            <span class="type">double</span> p=i+j+k;</span><br><span class="line">            <span class="keyword">if</span>(i) f[i][j][k]+=(<span class="number">1.0</span>*i/p*f[i<span class="number">-1</span>][j+<span class="number">1</span>][k]);</span><br><span class="line">            <span class="keyword">if</span>(j) f[i][j][k]+=(<span class="number">1.0</span>*j/p*f[i][j<span class="number">-1</span>][k+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(k) f[i][j][k]+=(<span class="number">1.0</span>*k/p*f[i][j][k<span class="number">-1</span>]);</span><br><span class="line">            f[i][j][k]+=<span class="number">1.0</span>*n/p;</span><br><span class="line">          &#125;</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;f[a[<span class="number">3</span>]][a[<span class="number">2</span>]][a[<span class="number">1</span>]]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong>给点启示：</strong> DP 优化的一个思路：合并等价状态、消除无用状态（这个有点像百钱买百只因）。</p><hr><h3 id="AT-dp-K"><a href="#AT-dp-K" class="headerlink" title="AT_dp_K"></a>AT_dp_K</h3><ul><li>博弈论</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_k">传送门</a></p><p>简单题。设 $f_i$ 表示剩余 $i$ 个石子时当前操作者的胜负，那么显然 $f_0&#x3D;0$。考虑转移，用点博弈论的知识，必败状态后继的所有状态都是必胜状态，那么写出转移 $f_i&#x3D;\max{[f_{i-a_j}&#x3D;0],1\le j\le n}$</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i-a[j]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        f[i]|=(!f[i-a[j]]);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-L"><a href="#AT-dp-L" class="headerlink" title="AT_dp_L"></a>AT_dp_L</h3><ul><li>区间 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_l">传送门</a></p><p>一个经典的 trick。设 $f_{i,j}$ 表示序列还剩下 $[i,j]$ 时，$X-Y$ 的最大值。转移要分两种情况，因为是两个人轮流取，一个会使答案增大，另一个使答案变小。</p><p>具体地，当前操作次数为偶数，先手取改变 $X$，$f_{i,j}&#x3D;\max(f_{i+1,j}+a_i,f_{i,j-1}+a_j)$。</p><p>否则后手取，$f_{i,j}&#x3D;\min(f_{i+1,j}-a_i,f_{i,j-1}-a_j)$。</p><p>答案即为 $f_{1,n}$，时间复杂度 $O(n^2)$。</p><p>与此题很类似的，还有 <a href="https://atcoder.jp/contests/tdpc/tasks/tdpc_game">AT_tdpc_game</a>，可以左转<a href="https://www.luogu.com.cn/article/8lch1g1m">我的题解</a>。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;++len)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>((n-len)&amp;<span class="number">1</span>) f[i][j]=<span class="built_in">min</span>(f[i+<span class="number">1</span>][j]-a[i],f[i][j<span class="number">-1</span>]-a[j]);</span><br><span class="line">        <span class="keyword">else</span> f[i][j]=<span class="built_in">max</span>(f[i+<span class="number">1</span>][j]+a[i],f[i][j<span class="number">-1</span>]+a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题还有一个贪心的思路，可以做到线性。</p><p>考虑对于每三个数，如果中间的最大，那么一定是先手取两边，后手取中间，这样把序列中的这样结构的三个数贡献合并成两边减中间，此时序列一定先减后增，直接贪心即可。</p><p>形式化地，$\forall a_{i-1},a_i,a_{i+1}(1&lt;i&lt;n)，s.t.\ a_i\ge a_{i-1}$ 且 $a_i\ge a_{i+1}$，将其改为 $f_i&#x3D;a_{i-1}+a_{i+1}-a_i$，剩余的不变。</p><p>这个做法代码不贴了。</p><p><strong>启示：</strong> 很多这种类似博弈两个人取数的题都可以转化成这种 DP 的状态设计，算是一个区间 DP 的套路了。</p><hr><h3 id="AT-dp-M"><a href="#AT-dp-M" class="headerlink" title="AT_dp_M"></a>AT_dp_M</h3><ul><li>前缀和优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_m">传送门</a></p><p>首先考虑一下朴素 DP，设 $f_{i,j}$ 表示进行到 $i$，已经分出去了 $j$ 块糖的方案数。那么显然 $f_{i,j}&#x3D;\sum_{k&#x3D;0}^{a_i}f_{i-1,k}$。每次转移都需要扫一遍，时间复杂度 $O(nk^2)$ 。</p><p>但是发现每一层 DP 的状态只与上一层有关，所以可以直接使用前缀和优化，时间复杂度 $O(nk)$。</p><p>代码不贴了，注意数组下标，前缀和容易 RE。</p><p><strong>启示：</strong> 当发现 DP 转移时方程只与上一层有关时，可以考虑用一些求和数据结构优化（比如前缀和）。</p><hr><h3 id="AT-dp-N"><a href="#AT-dp-N" class="headerlink" title="AT_dp_N"></a>AT_dp_N</h3><ul><li>区间 DP</li><li>前缀和优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_n">传送门</a></p><p>区间 DP 傻题，和 <a href="https://www.luogu.com.cn/problem/P1775">石子合并</a> 一模一样。</p><p>需要注意的一点是，朴素直接计算贡献是 $O(n^4)$ 的，使用前缀和优化到 $O(n^3)$。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;++k)</span><br><span class="line">              f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-O"><a href="#AT-dp-O" class="headerlink" title="AT_dp_O"></a>AT_dp_O</h3><ul><li>状压 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_o">传送门</a></p><p><del>拜谢老头。</del> 看数据范围考虑状压 DP。发现一个合法的方案一定满足每一行、每一列只选一个 $1$，所以设 $f_{i,S}$ 表示进行到第 $i$ 行，此时选点集合为 $S$，复杂度 $O(n^22^n)$ 会 T 掉。但观察可知已知 $S$ 即可确定 $i$，是 $S$ 中 $1$ 的个数，所以可以直接设为 $f_S$，复杂度 $O(n2^n)$。</p><p>Tips：popcount 用来计算二进制 $1$ 的个数。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>;S&lt;(<span class="number">1</span>&lt;&lt;n);++S)&#123;</span><br><span class="line">    <span class="type">int</span> k=__builtin_popcount(S);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(S&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;a[k][j])</span><br><span class="line">            f[S|(<span class="number">1</span>&lt;&lt;j)]=(f[S|(<span class="number">1</span>&lt;&lt;j)]+f[S])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-P"><a href="#AT-dp-P" class="headerlink" title="AT_dp_P"></a>AT_dp_P</h3><ul><li>树形 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_p">传送门</a></p><p><del>没有舞会的上司。</del> 树上 DP 简单题。设 $f_{u,0&#x2F;1}$ 表示当前点为 $u$，当前点是否染成黑色。那么对于 $f_{u,0}$，它的子节点染成什么颜色对其没有限制，所以 $f_{u,0}&#x3D;\prod_{v\in u}(f_{v,0}+f_{v,1})$；而对于 $f_{u,1}$，子节点不能还是黑色，所以 $f_{u,1}&#x3D;\prod_{v\in u}f_{v,1}$。</p><p>最后自底向上 dfs 即可，答案为 $f_{1,0}+f_{1,1}$，线性复杂度。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        f[u][<span class="number">0</span>]=f[u][<span class="number">0</span>]*(f[v][<span class="number">0</span>]+f[v][<span class="number">1</span>])%mod;</span><br><span class="line">        f[u][<span class="number">1</span>]=f[u][<span class="number">1</span>]*f[v][<span class="number">0</span>]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-Q"><a href="#AT-dp-Q" class="headerlink" title="AT_dp_Q"></a>AT_dp_Q</h3><ul><li>数据结构优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_q">传送门</a></p><p>最长上升子序列加权版。</p><p>发现朴素的 DP 就是 朴素的 LIS，设 $f_i$ 表示以 $i$ 为结尾的最大答案，只是把每次的贡献从 $1$ 变成 $a_i$ 了。但这样做是 $O(n^2)$ 的，考虑每次都是选择 $h_j&lt;h_i$ 的最大 $f_j$，这样可以使用数据结构优化。$f_i&#x3D;a_i+\max{f_j,1\le j&lt;i,h_j&lt;h_i}$。需要支持单点修，区间求最值，复杂度 $O(n\ logn)$。</p><p>这里使用了树状数组，因为要求的是前缀最大值，而且单点修改，树状数组比线段树更容易实现。</p><p><strong>Code:</strong></p><p>树状数组部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) c[i]=<span class="built_in">max</span>(c[i],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res=<span class="built_in">max</span>(res,c[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    ll x,a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    x=<span class="built_in">query</span>(h[i]<span class="number">-1</span>)+a;</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,x);</span><br><span class="line">    <span class="built_in">add</span>(h[i],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 对于一个 DP 转移方程，如果转移复杂度很高，要求的东西只与之前的值有关，可以尝试数据结构优化。</p><hr><h3 id="AT-dp-R"><a href="#AT-dp-R" class="headerlink" title="AT_dp_R"></a>AT_dp_R</h3><ul><li>矩阵加速 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_r">传送门</a></p><p>题目要求路径长度为 $k$ 的路径数，朴素的 DP 是直接设 $f_{k,i,j}$ 表示从 $i$ 到 $j$ 路径长度为 $k$ 的方案数，然后转移<br>$$f_{k,i,j}&#x3D;\sum_{u&#x3D;1}^nf_{k-1,i,u}+f_{1,u,j}$$</p><p>发现这样转移复杂度会爆炸，因为 $k$ 是 $10^{18}$ 量级的，但是这个方程你会发现跟最短路中的 Floyd 非常像，这就是个显然的矩阵乘法形式，于是想到矩阵优化，对于每一个距离矩阵 $f_i$，$f_i&#x3D;f_{i-1}\times f_1$，那么直接快速幂即可，答案为 $f_1^{k}$ 的所有元素和。时间复杂度 $O(n^3\ logk)$，可以通过。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">    ll a[N][N];</span><br><span class="line">    <span class="built_in">matrix</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">&#125;a;</span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="type">const</span> matrix&amp;a,<span class="type">const</span> matrix&amp;b)&#123;</span><br><span class="line">    matrix res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;++k)</span><br><span class="line">                res.a[i][j]=(res.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">ksm</span><span class="params">(matrix a,ll k)</span></span>&#123;</span><br><span class="line">    matrix res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) res.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 当一个线性 DP 发现转移数量非常多（一般达到了 $10^9$ 以上的量级），可以考虑矩阵优化。</p><hr><h3 id="AT-dp-S"><a href="#AT-dp-S" class="headerlink" title="AT_dp_S"></a>AT_dp_S</h3><ul><li>数位 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_s">传送门</a></p><p>看数据范围超级大想数位 DP。考虑记录 $3$ 个状态：当前位、是否达到最高位限制、当前数各位和模 $D$ 结果，边界条件是最后模 $D$ 为 $0$ 了答案加一。</p><p>具体地，设 $f_{pos,m,limit}$ 表示当前考虑到第 $pos$ 位（倒序从最高位往后找），各个位上的和模 $D$ 为 $m$，是否顶到上界。边界条件 $f_{0,0,0&#x2F;1}&#x3D;1$，转移时<br>$$f_{pos,m,limit}&#x3D;\sum f_{pos-1,(m+i)%D,limit&amp;&amp;[i&#x3D;n]}$$</p><p>注意，$i$ 表示当前枚举的下一位，$n$ 表示下一位的最大值。</p><p><strong>警钟：</strong> 最后的答案要 -1，因为 $0$ 不算，但减一以后可能会变成负数（全为 $0$ 的情况），所以还要加 mod 再对 mod 取模。</p><p>代码用记忆化搜索实现（因为太菜了不会递推），其实 $f$ 的第三维 $limit$ 可以不用设，但为了清晰还是写了。</p><p><strong>Code:</strong></p><p>记忆化搜索部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> m,<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> (m==<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(~f[pos][m][limit]) <span class="keyword">return</span> f[pos][m][limit];</span><br><span class="line">    <span class="type">int</span> n=limit?a[pos]:<span class="number">9</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i) res=(res+<span class="built_in">dfs</span>(pos<span class="number">-1</span>,(m+i)%d,limit&amp;&amp;(i==n)))%mod;</span><br><span class="line">    <span class="keyword">return</span> f[pos][m][limit]=res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i) a[l-i]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">cout&lt;&lt;(<span class="built_in">dfs</span>(l,<span class="number">0</span>,<span class="number">1</span>)<span class="number">-1</span>+mod)%mod;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 当计算某些数的数量，且范围很大，考虑数位 DP，记忆化搜索可以便捷实现，注意是否要考虑前导零。</p><hr><h3 id="AT-dp-T"><a href="#AT-dp-T" class="headerlink" title="AT_dp_T"></a>AT_dp_T</h3><ul><li>前缀和优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_t">传送门</a></p><p>考虑设 $f_{i,j}$ 表示确定前 $i$ 个数，其中第 $i$ 个是 $j$ 的方案数，那么初始状态 $f_{1,1}&#x3D;1$。对于转移分两种情况讨论，如果 $s_i$ 是小于号，那么 $f_{i,j}&#x3D;\sum_{k&#x3D;1}^{j-1}f_{i-1,k}$，否则 $f_{i,j}&#x3D;\sum_{k&#x3D;j}^{i-1}f_{i-1,k}$。</p><p>朴素的转移是 $O(n^3)$ 的。发现又是只与上一层状态有关，可以通过前缀和优化为 $O(n^2)$，于是可以通过此题。</p><p>注意一下大于小于号与下标对应关系 qwq。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">1</span>][<span class="number">1</span>]=s[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[i]==<span class="string">&#x27;&lt;&#x27;</span>) f[i][j]=s[i<span class="number">-1</span>][j<span class="number">-1</span>]%mod;</span><br><span class="line">        <span class="keyword">else</span> f[i][j]=(f[i][j]+s[i<span class="number">-1</span>][i<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">        s[i][j]=(s[i][j<span class="number">-1</span>]+f[i][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=(ans+f[n][i])%mod;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 与 $M$ 题相同。</p><hr><h3 id="AT-dp-U"><a href="#AT-dp-U" class="headerlink" title="AT_dp_U"></a>AT_dp_U</h3><ul><li>状压 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_u">传送门</a></p><p>看数据范围，显然是状压。考虑设 $f_S$ 表示已选兔子集合状态为 $S$ 的答案，设 $V_T$ 表示一组中的兔子状态为 $T$ 的贡献，那么可以写出转移方程 $f_S&#x3D;\max_{T\in S}{f_T+V_{\complement_ST}}$。</p><p>那其实就做完了，先枚举集合并预处理数组 $V$，复杂度 $O(2^nn^2)$，然后枚举子集转移，复杂度 $O(3^n)$，于是做完了。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);++s)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((s&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;((s&gt;&gt;j)&amp;<span class="number">1</span>))&#123;</span><br><span class="line">                v[s]+=a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[s]=v[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);++s)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> cs=s;cs&gt;<span class="number">0</span>;cs=(cs<span class="number">-1</span>)&amp;s)&#123;</span><br><span class="line">        f[s]=<span class="built_in">max</span>(f[s],f[cs]+v[s^cs]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 枚举子集复杂度 $O(3^n)$，数据范围在 $20$ 以内有限考虑状压 DP。</p><hr><h3 id="AT-dp-V"><a href="#AT-dp-V" class="headerlink" title="AT_dp_V"></a>AT_dp_V</h3><ul><li>树形 DP</li><li>换根 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_v">传送门</a></p><p>考虑树形 DP。设 $g_u$ 表示 $u$ 染成黑点，$u$ 的子树内的答案，转移的话可以 $g_u&#x3D;\prod_{v\in u}(g_v+1)$，表示对于每个儿子 $v$，都计算 $v$ 子树内的答案 $g_v$，以及 $v$ 染成白色，其子树全是白色的 $1$。这样总体做下来一次是 $O(n)$ 的。</p><p>但是题目要求输出每一个点为根的答案，一次 dfs 只能计算一个点为根的答案，总体复杂度 $O(n^2)$ 不能接受，所以考虑使用换根 DP，在第二次 dfs 中求出所有点的答案。</p><p>所以考虑设 $f_u$ 表示将 $u$ 染成黑色，$u$ 和其子树外的点所得的答案，那么显然对于每个点，最终的答案就是 $f_u\times g_u$。转移方程为 $f_v&#x3D;f_{u}+\frac{g_{u}}{g_v+1}+1$。这表示父亲 $u$ 的答案加上 $u$ 除 $v$ 的儿子的答案再加上白点的 $1$。时间复杂度 $O(n)$。</p><p>本来这个题已经快乐地做完了，但问题在于答案需要取模，模数不一定是质数。这就十分棘手，因为你无法直接算逆元。所以考虑对于每个点 $u$ 记一个前缀积 $pre$ 和后缀积 $suf$，在第一遍 dfs 中预处理。这样转移时除法就变成了挖去此点的前后缀积。</p><p>形式化地，$f_v&#x3D;f_u+pre_{u,i-1}\times suf_{u,i+1}+1$。其中 $i$ 表示 $v$ 是第几个儿子。代码中因为前后缀积的下标从 $0$ 开始，所以变成了 $pre_{u,i-2}\times suf_{u,i}$，本质上没有区别。</p><p><strong>Code:</strong></p><p>注意开 long long 和特殊的 $f_1&#x3D;1$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    g[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        g[u]=g[u]*(g[v]+<span class="number">1</span>)%mod;</span><br><span class="line">        pre[u].<span class="built_in">push_back</span>(g[v]+<span class="number">1</span>);</span><br><span class="line">        suf[u].<span class="built_in">push_back</span>(g[v]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=pre[u].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;l;++i) pre[u][i]=<span class="number">1ll</span>*pre[u][i<span class="number">-1</span>]*pre[u][i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i) suf[u][i]=<span class="number">1ll</span>*suf[u][i+<span class="number">1</span>]*suf[u][i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=pre[u].<span class="built_in">size</span>(),cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="number">1</span>) f[v]=f[u]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">1</span>) f[v]=f[u]*suf[u][<span class="number">1</span>]%mod+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt==l) f[v]=f[u]*pre[u][cnt<span class="number">-2</span>]%mod+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[v]=f[u]*pre[u][cnt<span class="number">-2</span>]%mod*suf[u][cnt]%mod+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 换根 DP 的套路。</p><blockquote><p>$1.$ 指定某个节点为根节点（一般为 $1$）。</p><p>$2.$ 第一次搜索完成预处理，同时得到该节点的解。</p><p>$3.$ 第二次搜索进行换根 DP，由已知节点推出相邻节点。</p></blockquote><hr><h3 id="AT-dp-W"><a href="#AT-dp-W" class="headerlink" title="AT_dp_W"></a>AT_dp_W</h3><ul><li>数据结构优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_w">传送门</a></p><p>跟 NOIP T4 有点像对吧。先用一个经典的 trick，把一段区间的贡献转化为右端点的贡献，排序后只有到右端点才计算贡献，用一个结构体存储区间信息。</p><p>设 $f_{i,j}$ 表示进行到位置 $i$，最后一个 $1$ 在位置 $j$ 的答案。考虑转移，如果 $i&#x3D;j$，也即在最后一个位置放了 $1$，那么 $f_{i,i}&#x3D;\max_{j&#x3D;1}^{i-1}f_{i-1,j}$。</p><p>否则 $i\neq j$，考虑每一个转移相对于 $i-1$ 都是加上了右端点在 $i$ 且左端点包含 $j$ 的答案。<br>$$f_{i,j}&#x3D;f_{i-1,j}+\sum_{l_k\le j,r_k&#x3D;i} a_k$$</p><p>这样朴素转移复杂度是 $O(n^2)$ 的，必须优化。考虑当  $i&#x3D;j$，查询了最值，对于 $i\neq j$，所有右端点 $i$ 的区间贡献都要累加到 DP 数组里，这是区间加的操作。于是可以使用线段树维护 DP 数组优化一下转移，这样的复杂度变成了 $O(n\ log n)$。</p><p>空间复杂度部分，可以直接压到一维。注意每次的答案要与 $0$ 取 $\max$。</p><p><strong>Code:</strong></p><p>线段树部分就不放了，纯板子，查询是查询整体最值。</p><p>代码中的 $v_i$ 表示第 $i$ 个命令。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>,i,i,<span class="built_in">query</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:v[i]) <span class="built_in">update</span>(<span class="number">1</span>,u.l,i,u.w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-X"><a href="#AT-dp-X" class="headerlink" title="AT_dp_X"></a>AT_dp_X</h3><ul><li>背包 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_x">传送门</a></p><p>我们先考虑最优策略。对于两个物品 $i$，$j$，如果 $i$ 放到 $j$ 下面，那么 $i$ 上面除了 $j$ 以外还能放 $s_i-w_j$ 重量的物品；如果 $j$ 放到 $i$ 下面，就能放 $s_j-w_i$ 重量的物品。考虑上面能放的更多那就更优，即 $i$ 放 $j$ 下面当且仅当 $s_i-w_j&gt;s_j-w_i$，移项得 $s_i+w_i&gt;s_j+w_j$。所以我们根据 $s+w$ 排序，这样放一定最优。</p><p>接下来 01 背包即可，答案为 $\max{f_i}$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w+a.s&lt;b.w+b.s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">20005</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i].w&gt;&gt;a[i].s&gt;&gt;a[i].v;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(f));    </span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=a[i].s;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">            f[j+a[i].w]=<span class="built_in">max</span>(f[j+a[i].w],f[j]+a[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20000</span>;++i) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-Y"><a href="#AT-dp-Y" class="headerlink" title="AT_dp_Y"></a>AT_dp_Y</h3><ul><li>组合数学</li><li>DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_y">传送门</a></p><p>H 题的加强版。</p><p>考虑设 $f_{i,j}$ 表示从 $(1,1)$ 走到 $(i,j)$，不经过障碍的方案数。先考虑没有障碍的简单情况，那么方案数就是 $\large \binom{i+j-2}{i-1}$，即选择 $i-1$ 步向下，剩下的向右。那么想想有障碍的转移，发现走到一个点的方案等于上述组合数减所有其左上角障碍的 $f$。想想为什么，因为所有会经过障碍的路都在左上角的障碍的 $f$ 里面。形式化地，$f_{i,j}&#x3D;calc(i,j)-\sum_{x&lt;&#x3D;i,y&lt;&#x3D;j,(x,y)\ne(i,j)}calc(x,y)$。这里的 $calc$ 就是指带入上面的组合数公式。所以处理一下组合数，时间复杂度 $O(n^2)$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a[M];</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll f[M],fac[N&lt;&lt;<span class="number">1</span>],inv[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2e5</span>;++i) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[<span class="number">200000</span>]=<span class="built_in">ksm</span>(fac[<span class="number">200000</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2e5</span><span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;h&gt;&gt;w&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i].fi&gt;&gt;a[i].se;</span><br><span class="line">    n++;</span><br><span class="line">    a[n]=<span class="built_in">make_pair</span>(h,w);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        f[i]=<span class="built_in">C</span>(a[i].fi+a[i].se<span class="number">-2</span>,a[i].fi<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j].se&gt;a[i].se) <span class="keyword">continue</span>;</span><br><span class="line">            f[i]=(f[i]-f[j]*<span class="built_in">C</span>(a[i].fi-a[j].fi+a[i].se-a[j].se,a[i].fi-a[j].fi)%mod+mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-Z"><a href="#AT-dp-Z" class="headerlink" title="AT_dp_Z"></a>AT_dp_Z</h3><ul><li>斜率优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_z">传送门</a></p><p>a，b 题加强版。转移显然，设 $f_i$ 表示走到 $i$ 时的最小花费，那 $f_i&#x3D;\min_{1\le j&lt;i}(f_j+(h_i-h_j)^2+C)$。 </p><p>拆开式子变成 $f_i&#x3D;f_j+h_i^2+h_j^2-2\times h_i\times h_j+C$。</p><p>移项，把 $j$ 分离，$f_j+h_j^2&#x3D;f_i-h_i^2-C+2\times h_i\times h_j$。</p><p>设 $y_j&#x3D;f_j+h_j^2$，$k_i&#x3D;2\times h_i$，$x_j&#x3D;h_j$，$b_i&#x3D;f_i-h_i^2$，变成了一次函数形式，可以斜率优化。</p><p>题目要求最小值，维护下凸壳，又发现了 $y_j$ 和 $x_j$ 保证单调递增，所以使用单调队列维护，线性。</p><p>斜率优化可以左转<a href="https://jkyak.github.io/2024/03/31/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/">我的斜率优化详解</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">y</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[i]+h[i]*h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">y</span>(i)-<span class="built_in">y</span>(j))/(h[i]-h[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;h[i];</span><br><span class="line">    he=t=<span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(he&lt;t&amp;&amp;<span class="built_in">calc</span>(q[he],q[he+<span class="number">1</span>])&lt;=<span class="number">2</span>*h[i]) he++;</span><br><span class="line">        <span class="type">int</span> j=q[he];</span><br><span class="line">        f[i]=f[j]+(h[i]-h[j])*(h[i]-h[j])+c;</span><br><span class="line">        <span class="keyword">while</span>(he&lt;t&amp;&amp;<span class="built_in">calc</span>(q[t<span class="number">-1</span>],q[t])&gt;=<span class="built_in">calc</span>(q[t],i)) t--;</span><br><span class="line">        q[++t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>至此，<strong>26</strong> 个 AT_dp 已经结束，这其中几乎包含了所有比较简单的 DP 类型，获益匪浅。</p><p>完结撒花！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;闲话&quot;&gt;&lt;a href=&quot;#闲话&quot; class=&quot;headerlink&quot; title=&quot;闲话&quot;&gt;&lt;/a&gt;闲话&lt;/h2&gt;&lt;p&gt;DP 太菜了，刷 AT 经典 DP，前面的比较简单，从 J 开始吧 qwq&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;AT-dp-J&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
