<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kketchup的小窝</title>
  
  <subtitle>My Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-04T12:50:30.067Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>JKY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模拟赛2024-4-28</title>
    <link href="http://example.com/2024/05/04/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-4-28/"/>
    <id>http://example.com/2024/05/04/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-4-28/</id>
    <published>2024-05-04T10:23:56.089Z</published>
    <updated>2024-05-04T12:50:30.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="校内模拟-2024-4-28"><a href="#校内模拟-2024-4-28" class="headerlink" title="校内模拟-2024-4-28"></a>校内模拟-2024-4-28</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>第一次 AK 校内比赛 qwq。</p><p>D 的 $\text{trick}$ 见过类似的才侥幸做出来。</p><h3 id="A"><a href="#A" class="headerlink" title="A"></a><a href="https://www.luogu.com.cn/problem/P3456">A</a></h3><p>简单题但是毒瘤题。</p><ul><li>搜索</li></ul><p>【题意】</p><p>给定矩阵，找值相等的八连通块，满足其八联通方向没有值更大&#x2F;更小。</p><p>分别求这两种连通块的个数。要做到 $O(n^2)$。</p><p>【解析】</p><p>搜索即可。开两个标记，表示是山峰&#x2F;山谷。</p><p>记得特判全相等的情况。</p><p>但不知道为什么，$\text{dfs}$ 在 LOJ 上会 MLE。</p><p>所以改成了 $\text{bfs}$ 卡空间，把所有能开在外面的开外面，卡了 $10$ 发才过。</p><p>幸亏没有罚时。</p><p>【代码】</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1001</span>;</span><br><span class="line"><span class="type">int</span> n,flag,tmp;</span><br><span class="line">bitset&lt;N&gt; vis[N];</span><br><span class="line"><span class="type">int</span> a[N][N],ans1,ans2;</span><br><span class="line"><span class="type">bool</span> f1,f2;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> x,y;&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    f1=<span class="number">1</span>,f2=<span class="number">1</span>;</span><br><span class="line">    node u;</span><br><span class="line">    <span class="type">int</span> tx,ty;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">    vis[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">F</span>(i,<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">F</span>(j,<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                tx=u.x+i,ty=u.y+j;</span><br><span class="line">                <span class="keyword">if</span>(tx&lt;<span class="number">1</span>||tx&gt;n||ty&lt;<span class="number">1</span>||ty&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(a[tx][ty]&gt;a[u.x][u.y]) f1=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(a[tx][ty]&lt;a[u.x][u.y]) f2=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!vis[tx][ty])&#123;</span><br><span class="line">                    vis[tx][ty]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;tx,ty&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>) tmp=a[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i][j]!=tmp) flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">bfs</span>(i,j);</span><br><span class="line">            ans1+=f1,ans2+=f2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B"><a href="#B" class="headerlink" title="B"></a><a href="https://codeforces.com/contest/176/problem/B">B</a></h3><ul><li>字符串</li><li>DP</li></ul><p>【题意】</p><p>给定一个长度为 $n\le 1000$ 的字符串，再给定一个长度相等的目标串和<strong>非负</strong>整数 $k\le 10^5$，请问是否可以使用正好 $k$ 次操作，将原串变成目标串。</p><p>每一次操作选择一个位置 $p\in[1,n)$，然后将字符串变成 $[p+1,n]+[1,p]$。其中 $+$ 表示连接。</p><p>求操作方案数，取模。两个方案不同当且仅当至少有一步 $p$ 的选择不同。</p><p>【解析】</p><p>猜一个非常重要的结论：如果一次操作不行的话，那一定不行。</p><p>感性理解一下，字符之间的相对位置大体不变，一次不行的话多次也不行。</p><p>推广一下，也就是说做任意多次操作以后只需要做 $1$ 次操作就可以变成想要的样子。</p><p>所以我们可以先暴力求出一次操作能满足条件的方案数，记为 $\text{cnt}$。</p><p>则考虑 DP，设 $f_i$ 表示第 $i$ 步变成目标串的方案数，$g_i$ 表示第 $i$ 步没变成目标串的方案数。</p><p>推出转移方程 $f_i&#x3D;cnt\times g_{i-1}+(cnt-1)\times f_{i-1}$。表示有 $\text{cnt}$ 种方式从上一个的任意非目标串状态变成目标串状态，$\text{cnt-1}$ 种方式从上一个的目标串再操作一次还是目标串。</p><p>类似地，$g_i&#x3D;(n-cnt)\times f_{i-1}+(n-cnt-1)\times g_{i-1}$。</p><p>答案是 $f_k$，初始状态就是看看原串和目标串是否一样，是则 $f_0&#x3D;1$，否则 $g_0&#x3D;1$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">string a,b,s,t;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll f[N][<span class="number">2</span>],cnt;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;s&gt;&gt;t&gt;&gt;k;</span><br><span class="line">    n=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==t) cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s==t)&#123;</span><br><span class="line">        cnt=<span class="number">1</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        a=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">        b=s.<span class="built_in">substr</span>(i,n-i);</span><br><span class="line">        a=b+a;</span><br><span class="line">        <span class="keyword">if</span>(a==t) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,k)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=(cnt*f[i<span class="number">-1</span>][<span class="number">1</span>]+(cnt<span class="number">-1</span>)*f[i<span class="number">-1</span>][<span class="number">0</span>])%mod;</span><br><span class="line">        f[i][<span class="number">1</span>]=((n-cnt)*f[i<span class="number">-1</span>][<span class="number">0</span>]+(n-cnt<span class="number">-1</span>)*f[i<span class="number">-1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[k][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a><a href="https://www.luogu.com.cn/problem/P2114">C</a></h3><ul><li>位运算</li><li>贪心</li></ul><p>【题意】</p><p>从 $[0,m]$ 中选择一个整数，使其经过 $n$ 次操作后的结果最大，求此最大值。</p><p>对于每一次操作，让原数执行与给定数按位与、按位或、按位异或中的一种（操作类型给定）。</p><p>【解析】</p><p>既然是位运算，考虑最后高位是 $1$ 则整体更大，启示我们从高往低考虑。贪心地想，这一位一开始要么是 $0$，要么是 $1$，那么我们分别枚举即可。</p><p>可以使用两个变量分别是 $0$ 和 $-1$，代表二进制的全 $0$ 和全 $1$，进行操作以后从高位向低位枚举，如果一开始是 $0$ 这一位是 $1$，那直接加答案，否则一开始是 $1$ 这一位是 $1$，加答案，同时判断没有超过 $m$ 的限制。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> ans,tmp1,tmp2;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    tmp1=<span class="number">0</span>,tmp2=<span class="number">-1</span>;<span class="comment">//000000000,1111111111</span></span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>) tmp1&amp;=t,tmp2&amp;=t;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;O&#x27;</span>) tmp1|=t,tmp2|=t;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;X&#x27;</span>) tmp1^=t,tmp2^=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fo</span>(i,<span class="number">29</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((tmp1&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((tmp2&gt;&gt;i)&amp;<span class="number">1</span>&amp;&amp;m&gt;=(<span class="number">1</span>&lt;&lt;i))&#123;</span><br><span class="line">            ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            m-=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a><a href="https://www.luogu.com.cn/problem/P1129">D</a></h3><ul><li>网络流</li><li>二分图</li></ul><p>【题意】</p><p>给定一个 $01$ 方阵，操作可以交换任意行列，问最终是否可以让左上到右下对角线全为 $1$。</p><p>【解析】</p><p>经典建模。既然要把对角线全变成 $1$，那就是每个行上对应每个列都匹配了，由此想到二分图最大匹配。</p><p>考虑把行当作左部点，列当作右部点，然后原矩阵里的 $1$ 行向列连边，源点连行，列连汇点。</p><p>正确性在于，交换行列就是匹配过程，总边数不改变，最大流为 $n$ 时满流有解。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,s,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,next,w;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++tot]=&#123;v,head[u],w&#125;;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">    e[++tot]=&#123;u,head[v],<span class="number">0</span>&#125;;</span><br><span class="line">    head[v]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N],now[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">1</span>,now[s]=head[s],q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!dis[v]&amp;&amp;e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">                now[v]=head[v];</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                <span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> sum;</span><br><span class="line">    ll res=<span class="number">0</span>,tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;i=now[u];i&amp;&amp;sum;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v,w=e[i].w;</span><br><span class="line">        <span class="keyword">if</span>((dis[v]==dis[u]+<span class="number">1</span>)&amp;&amp;e[i].w)&#123;</span><br><span class="line">            tmp=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(sum,w));</span><br><span class="line">            <span class="keyword">if</span>(!tmp) dis[v]=<span class="number">0</span>;</span><br><span class="line">            e[i].w-=tmp,e[i^<span class="number">1</span>].w+=tmp;</span><br><span class="line">            sum-=tmp,res+=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tot=<span class="number">1</span>;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(now,<span class="number">0</span>,<span class="built_in">sizeof</span>(now));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    s=n*<span class="number">2</span>+<span class="number">1</span>,t=s+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">add</span>(s,i,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i+n,t,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">F</span>(j,<span class="number">1</span>,n)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="built_in">add</span>(i,j+n,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) ans+=<span class="built_in">dfs</span>(s,INF);</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;=n) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;校内模拟-2024-4-28&quot;&gt;&lt;a href=&quot;#校内模拟-2024-4-28&quot; class=&quot;headerlink&quot; title=&quot;校内模拟-2024-4-28&quot;&gt;&lt;/a&gt;校内模拟-2024-4-28&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;</summary>
      
    
    
    
    
    <category term="比赛总结" scheme="http://example.com/tags/%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>字符串入门</title>
    <link href="http://example.com/2024/04/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2024/04/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-04-02T14:41:21.940Z</published>
    <updated>2024-05-04T10:22:43.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串入门"><a href="#字符串入门" class="headerlink" title="字符串入门"></a>字符串入门</h1><h2 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h2><p>DFA，即确定有限状态自动机。用于判断输入的字符串是否符合要求。所有的字符串算法都是构造 DFA，结构有点像图灵机。</p><p>先给点定义：</p><ul><li>状态集 $Q$（有限）：若将自动机看成图，那么状态是顶点。</li><li>字符集 $\sum$：满足自动机要求的字符集。</li><li>可接受状态集 $F\subseteq Q$：是满足要求的状态。</li><li>初始状态 $q_0\in Q$：是初始空状态。</li><li>转移函数 $\delta$：$\delta\times \sum\rightarrow Q$ 是转移函数。</li></ul><p>整个算法流程就是，从初始状态 $q_0$ 出发，每次输入字符 $c$，并通过转移函数 $\delta$ 转移。最后若状态为 $F$，那么字符串符合要求。</p><h3 id="例题1：构造判断二进制数奇偶的-DFA"><a href="#例题1：构造判断二进制数奇偶的-DFA" class="headerlink" title="例题1：构造判断二进制数奇偶的 DFA"></a>例题1：构造判断二进制数奇偶的 DFA</h3><p>因为二进制数的奇偶性只与最后一位数是 $0$ 还是 $1$ 有关。所以这里构造的 DFA 用 $q$ 表示当前二进制数的奇偶性，每次输入的字符判断，如果是与当前 $q$ 相同就不变，否则转移到另一个。</p><p><img src="/../../../../img/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="看个图"></p><hr><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>简单来说，就是通过一个函数（即 $\text{Hash}$）把字符串映射到整数，用来快速判断字符串相等。</p><p>其实我个人感觉 $\text{Hash}$ 虽然简单，但在不少题目中都挺有用的，比直接用 $\text{map}$ 少一个 $\log$。</p><p>具体实现的话，通常是使用多项式 $\text{Hash}$，也可以看成进制转换。设 $H(s)&#x3D;\sum_{i&#x3D;1}^ns_i\times base^{n-i}\ (mod\ M)$。</p><p>此时对于一个串 $\text{abcd}，H(abcd)&#x3D;a\times base^3+b\times base^2+c\times base+d$。</p><p>可以证明（我不会），模数为大质数的时候冲突概率最小。一般为保证正确率使用双模哈希，即两个模数得出的 $\text{Hash}$ 值都相等的情况下才相等。不过这样常数比较大，我喜欢用 $\text{unsigned long long}$ 自然溢出，代码要好写很多。</p><p>当询问子串 $\text{Hash}$ 时，重新计算的话就跟朴素暴力复杂度相同了，于是我们采取预处理的策略。我们使用类似前缀和的方式，设 $H_i&#x3D;\sum_{j&#x3D;1}^is_j^{i-j}$。这样要查询子串 $[l,r]$ 的 $\text{Hash}$ 值时，只需要用 $H_r-H_{l-1}\times base^{r-l+1}$。具体不赘述，读者自证不难。</p><h3 id="例题1-最长回文子串"><a href="#例题1-最长回文子串" class="headerlink" title="例题1 最长回文子串"></a>例题1 最长回文子串</h3><p><a href="https://www.luogu.com.cn/problem/P3805">manacher 模板</a>。</p><p>这个题的正解是 $\text{manacher}$ 线性解决，但是如果忘了怎么写，可以用二分+哈希水过。</p><p>复杂度是 $O(n\log n)$ 的，只需要加一个特判即可通过。特判是如果当前长度不匹配直接跳过，减少二分次数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1.1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ull base=<span class="number">131</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">ull h1[N],h2[N],p[N];</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="function">ull <span class="title">hash1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> h1[r]-h1[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">hash2</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> h2[l]-h2[r+<span class="number">1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正反处理哈希</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">p[i]=p[i<span class="number">-1</span>]*base;</span><br><span class="line">h1[i]=h1[i<span class="number">-1</span>]*base+(ull)s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">h2[i]=h2[i+<span class="number">1</span>]*base+(ull)s[i];</span><br><span class="line"><span class="type">int</span> r=<span class="built_in">min</span>(n-i+<span class="number">1</span>,i<span class="number">-1</span>)+<span class="number">1</span>,l=ans/<span class="number">2</span><span class="number">-1</span>,mid;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=<span class="number">0</span>||<span class="built_in">hash1</span>(i-l,i<span class="number">-1</span>)==<span class="built_in">hash2</span>(i,i+l<span class="number">-1</span>))&#123;</span><br><span class="line"><span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line">mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">hash1</span>(i-mid,i<span class="number">-1</span>)==<span class="built_in">hash2</span>(i,i+mid<span class="number">-1</span>)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,l*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">r=<span class="built_in">min</span>(n-i,i<span class="number">-1</span>)+<span class="number">1</span>,l=ans/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=<span class="number">0</span>||<span class="built_in">hash1</span>(i-l,i<span class="number">-1</span>)==<span class="built_in">hash2</span>(i+<span class="number">1</span>,i+l))&#123;</span><br><span class="line"><span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line">mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">hash1</span>(i-mid,i<span class="number">-1</span>)==<span class="built_in">hash2</span>(i+<span class="number">1</span>,i+mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,l*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举回文中心，二分长度奇数/偶数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>字典树，<del>就是像字典的树，</del> 是一种用来处理字符串前缀的数据结构（当然也可以处理一些数据）。</p><p>其结构是点为状态，边为转移。放到 DFA 上说，初始状态为 $q_0$，然后一个字符串中每读入一个字符就往后找并新建状态，转移就是这个字符。剩下的字符串，先找是否有状态可转移，没有再新建。</p><p>假设单词为：b，abc，abd，bcd，abcd，efg，hii</p><p><img src="/../../../../img/%E5%AD%97%E5%85%B8%E6%A0%912.png" alt="看个图"></p><p>模板题的修改查询代码（有点像动态开点线段树）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> x-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;x&lt;=<span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> x-<span class="string">&#x27;a&#x27;</span>+<span class="number">26</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x-<span class="string">&#x27;0&#x27;</span>+<span class="number">52</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> c=<span class="built_in">f</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(!t[p][c]) t[p][c]=++tot;</span><br><span class="line">        p=t[p][c],cnt[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)&#123;</span><br><span class="line">        <span class="type">int</span> c=<span class="built_in">f</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(!t[p][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p=t[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题1-P4551-最长异或路径"><a href="#例题1-P4551-最长异或路径" class="headerlink" title="例题1 P4551 最长异或路径"></a>例题1 <a href="https://www.luogu.com.cn/problem/P4551">P4551 最长异或路径</a></h3><p>【题意】</p><p>给定一棵带边权树，求树上异或值最大的路径，路径的异或值定义为路径上边的异或和。输出最大值。</p><p>【解析】</p><p>先考虑路径异或和的转化，用 $w$ 表示，则 $w(u,v)&#x3D;w(u,root)\oplus w(v,root)$。所以对于每一个点 $u$，要寻找与 $w(u,root)$ 异或值最大的 $w(v,root)$。那么我们先把所有 $w(u,root)$ 处理出来，然后根据二进制建字典树</p><p>一个二进制数要尽可能大，那就要让高位尽可能为 $1$，所以异或起来为 $1$ 代表两位不同，也就是说，从根开始向下搜索，尽可能找与 $w(u,root)$ 当前位不同的子树，这样保证最大。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> v,next,w;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">e[++tot].v=v;</span><br><span class="line">e[tot].w=w;</span><br><span class="line">e[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N*<span class="number">32</span>],cnt,ans;</span><br><span class="line"><span class="type">int</span> t[N*<span class="number">32</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]^e[i].w;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Fo</span>(i,<span class="number">30</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!t[p][c]) t[p][c]=++cnt;</span><br><span class="line">        p=t[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Fo</span>(i,<span class="number">30</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t[p][c^<span class="number">1</span>])&#123;</span><br><span class="line">            tmp=tmp*<span class="number">2</span>+(c^<span class="number">1</span>);</span><br><span class="line">            p=t[p][c^<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp=tmp*<span class="number">2</span>+c;</span><br><span class="line">            p=t[p][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp^x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    tot=ans=<span class="number">0</span>;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">add</span>(x,y,z);</span><br><span class="line">        <span class="built_in">add</span>(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) <span class="built_in">insert</span>(dis[i]);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(dis[i]));</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP 是三位科学家共同设计的<strong>单模式串匹配算法</strong>。简单来说，就是用来快速查询字符串 $S$ 在 $T$ 中的出现次数、位置等信息。</p><p>我们定义一个字符串的前缀函数 $\pi$，$\pi_i$ 表示字符串 $S$（下标从 $0$ 开始）$s[0,i]$ 中最长的真前缀等于真后缀的长度。特别地，默认 $\pi_0&#x3D;0$。</p><p>举个例子，对于 $S&#x3D;abcabca$，其前缀函数为 $[0,0,0,1,2,3,4]$。详细过程可自行模拟。</p><p>朴素计算前缀函数时间复杂度是 $O(nm)$ 的，十分不优秀。考虑优化的话，我们发现没必要在失配以后从头匹配，可以直接在某个匹配了一部分字符的基础上再次尝试。根据这个想法，KMP 算法如下。</p><p>先预处理出前缀函数，再每次根据前缀函数匹配，失配则从当前位置的前缀函数位置开始往后匹配。时间复杂度 $O(n+m)$（但我并不会证明）。</p><p>正确性在于：每次找到前缀函数，前缀函数开始的一些字符与当前匹配好的一些字符是相等的，所以无错。</p><p>匹配部分（代码中的 $nex$ 数组就是前缀函数，$a$ 是文本串，$b$ 是模式串）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;b[j+<span class="number">1</span>]!=a[i]) j=nex[j];</span><br><span class="line"><span class="comment">// 失配了，跳前缀函数</span></span><br><span class="line">    <span class="keyword">if</span>(b[j+<span class="number">1</span>]==a[i]) ++j;</span><br><span class="line"><span class="comment">// 成功了，下一位</span></span><br><span class="line">    <span class="keyword">if</span>(j==m) ans[++cnt]=i-m+<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 匹配完成，记录答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理怎么做？自己跟自己匹配！</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;b[j+<span class="number">1</span>]!=b[i]) j=nex[j];</span><br><span class="line">    <span class="keyword">if</span>(b[j+<span class="number">1</span>]==b[i]) ++j;</span><br><span class="line">    nex[i]=j;</span><br><span class="line"><span class="comment">// 记录当前匹配到了哪一位，即前缀函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板题完整代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> nex[N],ans[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line">n=<span class="built_in">strlen</span>(a+<span class="number">1</span>),m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;b[j+<span class="number">1</span>]!=b[i]) j=nex[j];</span><br><span class="line"><span class="keyword">if</span>(b[j+<span class="number">1</span>]==b[i]) ++j;</span><br><span class="line">nex[i]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;b[j+<span class="number">1</span>]!=a[i]) j=nex[j];</span><br><span class="line"><span class="keyword">if</span>(b[j+<span class="number">1</span>]==a[i]) ++j;</span><br><span class="line"><span class="keyword">if</span>(j==m) ans[++cnt]=i-m+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i) cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i) cout&lt;&lt;nex[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题1-P3426-POI2005-SZA-Template"><a href="#例题1-P3426-POI2005-SZA-Template" class="headerlink" title="例题1 P3426 [POI2005] SZA-Template"></a>例题1 <a href="https://www.luogu.com.cn/problem/P3426">P3426 [POI2005] SZA-Template</a></h3><p>【解析】</p><p>先求出前缀函数，再考虑 DP。设 $f_i$ 表示到 $i$ 的答案，则 $f_i$ 的取值只有 $i$ 或者 $f_{\pi_i}$，因为至少要对 $\pi_i$ 覆盖才能覆盖 $i$。考虑什么时候为 $f_{\pi_i}$（此时答案肯定不劣），当且仅当有一个 $f_j&#x3D;f_{\pi_i}，i-j\le \pi_i$，表示既然要求覆盖 $i$，那么 $s[0,\pi_i]&#x3D;s[i-\pi_i+1,i]$，也就是如果在 $[i-\pi_i+1,i]$ 内也可以用 $\pi_i$ 覆盖就可以覆盖 $i$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> fail[N],t[N],f[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">n=s.<span class="built_in">size</span>();</span><br><span class="line">s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j=fail[j];</span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) ++j;</span><br><span class="line">fail[i]=j;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">1</span>]=t[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">f[i]=i;</span><br><span class="line"><span class="keyword">if</span>(t[f[fail[i]]]&gt;=i-fail[i]) f[i]=f[fail[i]];</span><br><span class="line">t[f[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><p>设 $sa_i$ 表示按字典序排序后第 $i$ 小的后缀的编号，$rk_i$ 表示后缀 $i$ 的排名。</p><p>其中 $sa$ 数组也就是后缀数组，算法的本质就是快速求 $sa$ 数组。</p><p>两个数组满足：$sa[rk[i]]&#x3D;rk[sa[i]]&#x3D;i$。其实就是互为反数组（类似反函数）。</p><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>就是比较朴素，将 $n$ 个后缀直接 $\text{sort}$ 排序。排序复杂度是 $O(n\log n)$，再加上字符串排序比较字典序是 $O(n)$ 的，总复杂度 $O(n^2\log n)$。</p><h3 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h3><p>直接排序复杂度不能接受，考虑倍增优化。</p><p>首先对字符串 $s$ 的所有长度为 $1$ 的子串排序得到初始的 $sa$ 和 $rk$。</p><p>接下来，枚举次幂（设当前倍增到 k），那么用上一次得到的 $rk_i$ 和 $rk_{i+k}$ 作为第一关键字与第二关键字（如果没有第二关键字直接补 $0$），$\text{sort}$ 排序得到新的 $sa$。</p><p>因为排序后 $rk_i$ 表示的是 $[i,i+k-1]$ 的信息，而 $rk_{i+k}$ 表示 $[i+k+1,i+2*k]$ 的信息，所以合并是正确的。</p><p>放个图方便理解。</p><p><img src="/../../../../img/sa.png" alt="看个图"></p><p>倍增的复杂度是 $O(\log n)$，每次 $\text{sort}$ 是 $O(n\log n)$，总时间复杂度 $O(n\log^2n)$。</p><h3 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h3><p>$\text{sort}$ 是 $O(n\log n)$ 的，使用基数排序 $O(n)$，总复杂度 $O(n\log n)$。</p><p>贴个代码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m=<span class="number">122</span>,cnt;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> x[N],y[N],sa[N],c[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (y[i]==y[j])&amp;&amp;(y[i+w]==y[j+w]);</span><br><span class="line"><span class="comment">//判断是否相等，即第一关键字与第二关键字都相等</span></span><br><span class="line">&#125;<span class="comment">//这个函数用来寻址优化（卡常）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n) c[x[i]=s[i]]++;</span><br><span class="line"><span class="comment">// x[i] 表示第一关键字，c 是桶用来记录第一关键字的数量</span></span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">2</span>,m) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line"><span class="comment">// 前缀和，这样处理以后保证字典序越大 c 数组值越大，用来处理 sa</span></span><br><span class="line"><span class="built_in">Fo</span>(i,n,<span class="number">1</span>) sa[c[x[i]]--]=i;</span><br><span class="line"><span class="comment">// 第一遍基数排序，c-- 保证有重复时编号不一样</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;;k&lt;&lt;=<span class="number">1</span>,m=cnt)&#123;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// y 表示第二关键字</span></span><br><span class="line"><span class="built_in">F</span>(i,n-k+<span class="number">1</span>,n) y[++cnt]=i;</span><br><span class="line">        <span class="comment">// 最后 k 个没有第二关键字，直接放进来</span></span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(sa[i]&gt;k) y[++cnt]=sa[i]-k;</span><br><span class="line">        <span class="comment">// 剩下的枚举排名，如果可以作为第二关键字就放进来</span></span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,m) c[i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n) c[x[i]]++;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">2</span>,m) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">Fo</span>(i,n,<span class="number">1</span>) sa[c[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 与第一遍排序类似，注意这里的 x[y[i]]，表示元素变成了 y1-yn</span></span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n) y[i]=x[i];</span><br><span class="line">        <span class="comment">// y 数组暂时没用，临时存 x</span></span><br><span class="line">cnt=<span class="number">1</span>,x[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">2</span>,n) x[sa[i]]=<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],k)?cnt:(++cnt);</span><br><span class="line">        <span class="comment">// 根据排序的结果处理下一次排序第一关键字</span></span><br><span class="line"><span class="keyword">if</span>(cnt==n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果没有重复排名了，也就是排序好了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">SA</span>();</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sa[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串入门&quot;&gt;&lt;a href=&quot;#字符串入门&quot; class=&quot;headerlink&quot; title=&quot;字符串入门&quot;&gt;&lt;/a&gt;字符串入门&lt;/h1&gt;&lt;h2 id=&quot;DFA&quot;&gt;&lt;a href=&quot;#DFA&quot; class=&quot;headerlink&quot; title=&quot;DFA&quot;&gt;&lt;/</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF161D</title>
    <link href="http://example.com/2024/04/01/CF161D/"/>
    <id>http://example.com/2024/04/01/CF161D/</id>
    <published>2024-04-01T15:06:46.774Z</published>
    <updated>2024-04-01T15:06:59.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CF161D"><a href="#CF161D" class="headerlink" title="CF161D"></a>CF161D</h3><p>点分&#x2F;长链剖分&#x2F;dsu 随便过。</p><p>但注意到数据范围不强，考虑 $O(nk)$ 的复杂度，可以树形DP。设 $f_{u,i}$ 表示以 $u$ 为根，子树中离 $u$ 路径长度为 $i$ 的点数。</p><p>统计答案时考虑每个的贡献是 $f_{u,j}\times f_{v,k-i-j}$（$0\le j&lt;k$）。然后再转移 $f_{u,j+1}&#x3D;\sum_{v\in u}f_{v,j}$。</p><p>这样的正确性在于，每次统计答案时都是新的和当前的统计，再把新的更新，不重不漏，有点像枚举两点时 $j$ 从 $i+1$ 开始枚举。第一遍没过就是这里没考虑好，shaber 了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i) ans+=(f[u][i]*f[v][k-i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i) f[u][i+<span class="number">1</span>]+=f[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CF161D&quot;&gt;&lt;a href=&quot;#CF161D&quot; class=&quot;headerlink&quot; title=&quot;CF161D&quot;&gt;&lt;/a&gt;CF161D&lt;/h3&gt;&lt;p&gt;点分&amp;#x2F;长链剖分&amp;#x2F;dsu 随便过。&lt;/p&gt;
&lt;p&gt;但注意到数据范围不强，考虑 $O(nk)</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>模拟赛2024-3-28</title>
    <link href="http://example.com/2024/04/01/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-3-28/"/>
    <id>http://example.com/2024/04/01/%E6%A8%A1%E6%8B%9F%E8%B5%9B2024-3-28/</id>
    <published>2024-04-01T15:04:41.028Z</published>
    <updated>2024-04-01T15:27:57.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="校内模拟-2024-3-28"><a href="#校内模拟-2024-3-28" class="headerlink" title="校内模拟-2024-3-28"></a>校内模拟-2024-3-28</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p><a href="https://codeforces.com/contest/161/problem/D">原题链接</a></p><p>【题意】</p><p>求树上距离（无边权）为 $k$ 的无序点对数。</p><p>$1\le n\le 5\times 10^4,1\le k\le 500$。</p><p>【解析】</p><p>这题我做过（惊恐）于是场上秒了。</p><p>可以左转<a href="https://jkyak.github.io/2024/04/01/CF161D/">我的题解</a>。</p><p>我的做法是 DP，复杂度 $O(nk)$。</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p><a href="https://codeforces.com/contest/592/problem/D">原题链接</a></p><p>【题意】</p><p>给定一棵无边权的树，树上有 $m$ 个关键点，你要选择其中一个出发，到达其余所有关键点，路径（显然）可重复。费用定义为经过边的总数，求最小费用和对应的出发点（多个费用相同的点取最小）。</p><p>【解析】</p><p>容易发现，答案一定是一些走两遍的路径和一些走一遍的路径组成的，所以为了最小化答案，走一遍的路径就是直径。答案就是 （要经过的点数 $-1$）$\times 2$ $-$ 直径。</p><p>猜到这个结论就好想了，考虑如果要经过一个点，当且仅当其子树内有关键点，所以从直径开始 dfs 即可。</p><p>别忘了特判只有一个点的情况。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=x;i&lt;=y;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,x,y) for(int i=x;i&gt;=y;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x,y) memset(x,y,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> st[N],f[N],cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">    f[u]=dis;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        st[u]|=<span class="built_in">dfs</span>(v,u,dis+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        e[x].<span class="built_in">eb</span>(y);</span><br><span class="line">        e[y].<span class="built_in">eb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        st[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c1=<span class="number">0</span>,c2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(st[i]&amp;&amp;f[i]&gt;f[c1]) c1=i;</span><br><span class="line">    <span class="built_in">dfs</span>(c1,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(f[i]&gt;f[c2]) c2=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(c1,c2)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;(cnt<span class="number">-1</span>)*<span class="number">2</span>-f[c2]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p><a href="https://www.luogu.com.cn/problem/P1092">原题链接</a></p><p>【题意】</p><p>给定 $3$ 个长为 $n$ 的字符串，串中的字符表示一个数（如 ‘A’ 表示相同的一个数）。在 $n$ 进制下，前两个字符串代表的数的和等于第三个串代表的数。求每个字符 $c$ 代表的唯一数 $x$（’A’ $\le c\le$ ‘Z’,$0\le x\le 9$）</p><p>【解析】</p><p>先考虑爆搜。其实真的就是爆搜，从低位到高位枚举，最后再判断是否可行。可以获得 $40$ 分的好成绩（我考场就是这样的）。</p><p>我们想想能不能优化一下爆搜，剪一下枝。容易想到第一个显然的剪枝，最高位不能有进位，不然会超出 $n$ 位。这样是不够的，再考虑如果已经枚举出来一些数了，我们无法判断只是因为不知道是否有进位。</p><p>那么根据题目，进位最多为 $1$。所以判断一下，如果进不进位都不成立的话显然不行。</p><p>这样就可以通过本题，复杂度十分玄学，我不会算。听说正解是高斯消元，我也不会，先咕着。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string a,b,c;</span><br><span class="line"><span class="type">int</span> x[<span class="number">30</span>],y[<span class="number">30</span>],z[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">30</span>],nex[<span class="number">30</span>],st[<span class="number">30</span>],cnt,flag;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num[x[<span class="number">0</span>]]+num[y[<span class="number">0</span>]]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">Fo</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> t1=num[x[i]],t2=num[y[i]],t3=num[z[i]];</span><br><span class="line"><span class="keyword">if</span>(t1==<span class="number">-1</span>||t2==<span class="number">-1</span>||t3==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>((t1+t2)%n!=t3&amp;&amp;(t1+t2+<span class="number">1</span>)%n!=t3) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp=<span class="number">0</span>,i=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((num[x[i]]+num[y[i]]+tmp)%n!=num[z[i]]) <span class="keyword">break</span>;</span><br><span class="line">tmp=(num[x[i]]+num[y[i]]+tmp)/n;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (i&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chk</span>()||flag) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(s==n)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">chk2</span>())&#123;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) cout&lt;&lt;num[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Fo</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">st[i]=<span class="number">1</span>;</span><br><span class="line">num[nex[s]]=i;</span><br><span class="line"><span class="built_in">dfs</span>(s+<span class="number">1</span>);</span><br><span class="line">st[i]=<span class="number">0</span>;</span><br><span class="line">num[nex[s]]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[x])&#123;</span><br><span class="line">st[x]=<span class="number">1</span>;</span><br><span class="line">nex[cnt++]=x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">memset</span>(num,<span class="number">-1</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">x[i]=(<span class="type">int</span>)a[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">y[i]=(<span class="type">int</span>)b[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">z[i]=(<span class="type">int</span>)c[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Fo</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">init</span>(x[i]);</span><br><span class="line"><span class="built_in">init</span>(y[i]);</span><br><span class="line"><span class="built_in">init</span>(z[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) st[i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p><a href="https://www.luogu.com.cn/problem/P4178">原题链接</a></p><p>【题意】</p><p>给定一棵 $n$ 个节点的树，每条边有边权，求出树上两点距离小于等于 $k$ 的点对数量。</p><p>【解析】</p><p>跟第一题和板子题很像对吧（其实就是点分治板子）。记录所有出现过的距离，双指针尝试更新，容斥减掉子树内的答案并分治。复杂度 $O(n\ log^2n)$。</p><p>没啥好说的，很板。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> v,next,w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> tot,rt,sum,cnt,ans;</span><br><span class="line"><span class="type">int</span> head[N],vis[N],mx[N],siz[N],dis[N],rem[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">e[++tot].v=v;</span><br><span class="line">e[tot].w=w;</span><br><span class="line">e[tot].next=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">mx[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v=e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa||vis[v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">getroot</span>(v,u);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line">mx[u]=<span class="built_in">max</span>(mx[u],siz[v]);</span><br><span class="line">&#125;</span><br><span class="line">mx[u]=<span class="built_in">max</span>(mx[u],sum-siz[u]);</span><br><span class="line"><span class="keyword">if</span>(mx[u]&lt;mx[rt]) rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    rem[++cnt]=dis[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dis[v]=dis[u]+e[i].w;</span><br><span class="line">        <span class="built_in">getdis</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    dis[u]=s;</span><br><span class="line">    <span class="built_in">getdis</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(rem+<span class="number">1</span>,rem+cnt+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=cnt,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(rem[l]+rem[r]&lt;=k)&#123;</span><br><span class="line">    res+=(r-l);</span><br><span class="line">    l++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> r--;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">ans+=<span class="built_in">calc</span>(u,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v=e[i].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">ans-=<span class="built_in">calc</span>(v,e[i].w);</span><br><span class="line">mx[rt=<span class="number">0</span>]=inf;</span><br><span class="line">sum=siz[v];</span><br><span class="line"><span class="built_in">getroot</span>(v,u);</span><br><span class="line"><span class="built_in">solve</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z;i&lt;n;++i)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="built_in">add</span>(x,y,z);</span><br><span class="line"><span class="built_in">add</span>(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line">mx[rt]=sum=n;</span><br><span class="line"><span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">solve</span>(rt);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>总而言之，这场模拟赛还是不错的，锻炼了我的点分（就是 B 题想到正解了没对很可惜，以后加强训练代码能力）。希望能越来越好，撒花！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;校内模拟-2024-3-28&quot;&gt;&lt;a href=&quot;#校内模拟-2024-3-28&quot; class=&quot;headerlink&quot; title=&quot;校内模拟-2024-3-28&quot;&gt;&lt;/a&gt;校内模拟-2024-3-28&lt;/h2&gt;&lt;h3 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; c</summary>
      
    
    
    
    
    <category term="比赛总结" scheme="http://example.com/tags/%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>斜率优化</title>
    <link href="http://example.com/2024/03/31/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2024/03/31/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</id>
    <published>2024-03-31T14:00:20.511Z</published>
    <updated>2024-05-03T03:41:52.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h2><ul><li>斜率优化，一般是在转移方程中当前为 $i$，枚举决策点 $j$，然后化简式子出现同时与 $i$ 和 $j$ 有关的项（如果没有可以单调队列）。这样的话有点像一次函数，形如 $y&#x3D;kx+b$，那么这里的 $kx$ 就是与$i$ 和 $j$ 有关的项（具体题目具体分析）。问题变成查询最有决策点。</li><li>如果式子中的 $x$ 与 $y$ 都有单调性，可以使用单调队列线性维护。否则有两种做法：维护凸壳并二分或李超树（也可以平衡树或 cdq 分治，但我不会，就不弄巧成拙了）。这些做法是带一个 log 的。</li></ul><p>经典套路：</p><blockquote><p>$1.$ 写出朴素转移方程。</p><p>$2.$ 化简并设出 $x,y,k,b$，根据所求决定维护上凸还是下凸（最大值还是最小值）。</p><p>$3.$ 看单调性决定维护方式。</p></blockquote><h3 id="单调队列维护"><a href="#单调队列维护" class="headerlink" title="单调队列维护"></a>单调队列维护</h3><h4 id="例题1-P3195-HNOI2008-玩具装箱"><a href="#例题1-P3195-HNOI2008-玩具装箱" class="headerlink" title="例题1 P3195 [HNOI2008] 玩具装箱"></a>例题1 <a href="https://www.luogu.com.cn/problem/P3195">P3195 [HNOI2008] 玩具装箱</a></h4><p>【题意】</p><p>给定一个序列，要求将其划分成若干段，一段划分为 $[i,j]$ 的费用为 $(j-i+\sum_{k&#x3D;i}^jC_k-L)^2$（这里的 $C_k$ 为给定数组，$L$ 为给定常量）。最小化划分序列的费用和。</p><p>【解析】</p><p>朴素的转移方程为：（设 $f_i$ 表示考虑到 $i$ 的答案，$s_i$ 表示 $C_i$ 的前缀和）<br>$$<br>f_i&#x3D;\min_{1\le j&lt;i}(f_j+[i-(j+1)+s_i-s_j-L]^2)<br>$$<br>换元并化简，设 $a_i&#x3D;s_i+i，b_i&#x3D;s_i+i+L+1$。<br>$$<br>\begin{aligned}<br>&amp;f_i&#x3D;\min_{1\le j&lt;i}(f_j+[a_i-b_j]^2)\\<br>&amp;f_i&#x3D;\min_{1\le j&lt;i}(f_j+a_i^2+b_j^2-2\times a_i\times b_j)<br>\end{aligned}<br>$$<br>先不管取 $\min$，先推式子，并把只与 $j$ 有关的移到一边，尝试分离 $i$ 和 $j$。<br>$$<br>\begin{aligned}<br>f_i&amp;&#x3D;f_j+a_i^2+b_j^2-2\times a_i\times b_j\\<br>f_j+b_j^2&amp;&#x3D;f_i-a_i^2+2\times a_i\times b_j<br>\end{aligned}<br>$$<br>我们发现，如果设 $y&#x3D;f_j+b_j^2，k&#x3D;2\times a_i，x&#x3D;b_j，b&#x3D;f_i-a_i^2$，那么方程变成了一个一次函数形式 $y&#x3D;kx+b$。所以要做的就是在二维平面中找一个斜率固定的直线使 $b$ 最小。</p><p>观察数据，$y&#x3D;f_j+b_j^2$ 和 $x&#x3D;b_j$ 都单调递增，所以使用单调队列优化，时空复杂度线性。</p><p>放个单调队列斜优的板子吧。</p><p>代码中没用 $\text{double}$，防止爆精度。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="type">int</span> n,l;</span><br><span class="line"><span class="type">int</span> s[N],f[N],q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (f[j]+s[j]*s[j]+<span class="number">2</span>*l*s[j])-(f[i]+s[i]*s[i]+<span class="number">2</span>*l*s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s[j]-s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;l;</span><br><span class="line">l=l+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) cin&gt;&gt;x,s[i]=s[i<span class="number">-1</span>]+x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=s[i]+i;</span><br><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">2</span>*s[i];</span><br><span class="line"><span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[h],q[h+<span class="number">1</span>])&lt;=<span class="built_in">down</span>(q[h],q[h+<span class="number">1</span>])*k) h++;</span><br><span class="line"><span class="type">int</span> j=q[h];</span><br><span class="line">f[i]=f[j]+(s[i]-s[j]-l)*(s[i]-s[j]-l);</span><br><span class="line"><span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[t<span class="number">-1</span>],q[t])*<span class="built_in">down</span>(q[t],i)&gt;=<span class="built_in">up</span>(q[t],i)*<span class="built_in">down</span>(q[t<span class="number">-1</span>],q[t])) t--;</span><br><span class="line">q[++t]=i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此题类似的题：</p><p><a href="https://www.luogu.com.cn/problem/P3628">P3628 [APIO2010] 特别行动队</a></p><p><a href="https://www.luogu.com.cn/problem/P2365">P2365 任务安排</a></p><p><a href="https://www.luogu.com.cn/problem/P4360">P4360 [CEOI2004] 锯木厂选址</a></p><h4 id="例题2-P4072-SDOI2016-征途"><a href="#例题2-P4072-SDOI2016-征途" class="headerlink" title="例题2 P4072 [SDOI2016] 征途"></a>例题2 <a href="https://www.luogu.com.cn/problem/P4072">P4072 [SDOI2016] 征途</a></h4><p>【题意】</p><p>给定长度为 $n$ 的序列，将其划分为 $m$ 段，使得这 $m$ 段各自求和后的总方差最小，输出方差 $\times m^2$。</p><p>形式化地，设 $b_i&#x3D;\sum_{j&#x3D;l_i}^{r_i}a_j$，$v&#x3D;\frac{\sum_{i&#x3D;1}^m(b_i-\bar{b})^2}{m}$，求最小的 $v\times m^2$。其中 $\forall i\in [1,m-1]$，$l_{i+1}&#x3D;r_i+1$。</p><p>【解析】</p><p>推推柿子。<br>$$<br>\begin{aligned}<br>v&amp;&#x3D;\frac{\sum_{i&#x3D;1}^m(b_i-\bar{b})^2}{m}\\<br>&amp;&#x3D;\frac{(b_1-\bar{b})^2+ (b_2-\bar{b})^2+…+ (b_m-\bar{b})^2}{m}\\<br>&amp;&#x3D;\frac{m\times(\bar{b})^2+\sum_{i&#x3D;1}^mb_i^2-2\times \bar{b}\times\sum_{i&#x3D;1}^mb_i}{m}\\<br>&amp;&#x3D;\frac{m\times(\frac{\sum_{i&#x3D;1}^mb_i}{m})^2+\sum_{i&#x3D;1}^mb_i^2-2\times \frac{\sum_{i&#x3D;1}^mb_i}{m}\times\sum_{i&#x3D;1}^mb_i}{m}\\<br>&amp;&#x3D;\frac{\frac{(\sum_{i&#x3D;1}^mb_i)}{m}^2+\sum_{i&#x3D;1}^mb_i^2-2\times \frac{(\sum_{i&#x3D;1}^mb_i)^2}{m}}{m}\\<br>&amp;&#x3D;\frac{\sum_{i&#x3D;1}^mb_i^2- \frac{(\sum_{i&#x3D;1}^mb_i)^2}{m}}{m}\\<br>v\times m^2&amp;&#x3D;m\times\sum_{i&#x3D;1}^mb_i^2-(\sum_{i&#x3D;1}^mb_i)^2<br>\end{aligned}<br>$$<br>可以发现， $-(\sum_{i&#x3D;1}^mb_i)^2$ 无论怎么划分都不会变，都是 $-(\sum_{i&#x3D;1}^na_i)^2$，所以就变成最小化 $m\times\sum_{i&#x3D;1}^mb_i^2$。</p><p>考虑 DP 设 $f_{i,j}$ 表示走到 $a_i$，是第 $j$ 天的最小 $\sum_{}$（最后再乘 $m$）。那么朴素式子很好推（这里的 $s_i$ 表示 $a_i$ 的前缀和）：<br>$$<br>f_{i,j}&#x3D;\min_{1\le k&lt;i}(f_{k,j-1}+(s_i-s_k)^2)<br>$$<br>直接做是 $O(n^3)$ 的，发现这是斜率优化的经典形式，即<br>$$<br>\begin{aligned}<br>f_{i,j}&amp;&#x3D;\min_{1\le k&lt;i}(f_{k,j-1}+s_i^2+s_k^2-2\times s_i\times s_k)\\<br>f_{i,j}&amp;&#x3D;f_{k,j-1}+s_i^2+s_k^2-2\times s_i\times s_k\\<br>f_{k,j-1}+s_k^2&amp;&#x3D;f_{i,j}-s_i^2+2\times s_i\times s_k<br>\end{aligned}<br>$$</p><p>设 $y&#x3D;f_{k,j-1}+s_k^2,k&#x3D;2\times s_i,x&#x3D;s_k,b&#x3D;f_{i,j}-s_i^2$，变成一次函数形式，即可斜率优化。此题斜率优化是二维的，使用了单调队列。</p><p>放个二维斜率优化的板子。使用了辅助数组 $g$，优化成线性空间。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3005</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> s[N],q[N],f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">up</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (g[j]+s[j]*s[j])-(g[i]+s[i]*s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">down</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s[j]-s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) cin&gt;&gt;x,s[i]=s[i<span class="number">-1</span>]+x,g[i]=s[i]*s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m;++j)&#123;</span><br><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=j;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[h],q[h+<span class="number">1</span>])&lt;=<span class="built_in">down</span>(q[h],q[h+<span class="number">1</span>])*<span class="number">2</span>*s[i]) h++;</span><br><span class="line"><span class="type">int</span> p=q[h];</span><br><span class="line">f[i]=g[p]+(s[i]-s[p])*(s[i]-s[p]);</span><br><span class="line"><span class="keyword">while</span>(h&lt;t&amp;&amp;<span class="built_in">up</span>(q[t<span class="number">-1</span>],q[t])*<span class="built_in">down</span>(q[t],i)&gt;=<span class="built_in">up</span>(q[t],i)*<span class="built_in">down</span>(q[t<span class="number">-1</span>],q[t])) t--;</span><br><span class="line">q[++t]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) g[i]=f[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m*f[n]-s[n]*s[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此题类似的题：</p><p><a href="https://www.luogu.com.cn/problem/P3648">P3648 [APIO2014] 序列分割</a></p><h3 id="李超线段树维护"><a href="#李超线段树维护" class="headerlink" title="李超线段树维护"></a>李超线段树维护</h3><p>李超线段树，用来维护直线或线段上的信息。简单来说就是个标记永久化的线段树。</p><p>例如，我们要维护一些直线，查询横坐标为 $x$ 时纵坐标的最大值。</p><p>先考虑维护修改，第一步判断中点信息，选那个更大的作为主要线段（这样保证不会更劣），第二步分别比较两端点，确定一下哪边更大，然后递归处理。</p><p>具体地，设 $g$ 为主要线段，$f$ 为修改线段，默认 $f_{mid}&lt;g_{mid}$。若 $f_l&gt;g_l$，说明左半边有交点，递归左二子，右边同理。若 $f_l&lt;g_l,f_r&lt;g_r$，则无需递归，$g$ 完全优于 $f$。</p><p><img src="/../../../../img/%E6%9D%8E%E8%B6%85%E6%A0%91.png" alt="放张图"></p><p>查询的话，就是标记永久化以后一路查询最值。</p><p>放个<a href="https://www.luogu.com.cn/problem/P4097">李超树板子</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="function">db <span class="title">Abs</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> (x&lt;<span class="number">0</span>)?-x:x;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">db k,b;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="built_in">line</span>()&#123;k=<span class="number">0</span>,b=<span class="number">-1e18</span>;&#125;</span><br><span class="line"><span class="built_in">line</span>(db h1,db z1,db h2,db z2,<span class="type">int</span> _id)&#123;</span><br><span class="line">id=_id;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Abs</span>(h1-h2)&lt;eps) k=<span class="number">0</span>,b=<span class="built_in">max</span>(z1,z2);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">k=(z2-z1)/(h2-h1);</span><br><span class="line">b=z2-k*h2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">val</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> k*x+b;&#125;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,line f)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].id==<span class="number">0</span>) <span class="keyword">return</span> t[p]=f,<span class="built_in">void</span>();</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Abs</span>(t[p].<span class="built_in">val</span>(mid)-f.<span class="built_in">val</span>(mid))&lt;eps)&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].id&gt;f.id) <span class="built_in">swap</span>(f,t[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t[p].<span class="built_in">val</span>(mid)&lt;f.<span class="built_in">val</span>(mid)) <span class="built_in">swap</span>(f,t[p]);</span><br><span class="line"><span class="keyword">if</span>(f.<span class="built_in">val</span>(l)+eps&gt;t[p].<span class="built_in">val</span>(l)) <span class="built_in">insert</span>(p&lt;&lt;<span class="number">1</span>,l,mid,L,R,f);</span><br><span class="line"><span class="keyword">if</span>(f.<span class="built_in">val</span>(r)+eps&gt;t[p].<span class="built_in">val</span>(r)) <span class="built_in">insert</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,f);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid) <span class="built_in">insert</span>(p&lt;&lt;<span class="number">1</span>,l,mid,L,R,f);</span><br><span class="line"><span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=R) <span class="built_in">insert</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">line <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> t[p];</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">line res;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=mid) res=<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,l,mid,k);</span><br><span class="line"><span class="keyword">else</span> res=<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,k);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Abs</span>(res.<span class="built_in">val</span>(k)-t[p].<span class="built_in">val</span>(k))&lt;eps)&#123;</span><br><span class="line"><span class="keyword">if</span>(res.id&lt;t[p].id) <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">return</span> t[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(res.<span class="built_in">val</span>(k)&gt;t[p].<span class="built_in">val</span>(k)) <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">return</span> t[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lans,h1,h2,z1,z2,x,tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> T,op;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">cin&gt;&gt;h1&gt;&gt;z1&gt;&gt;h2&gt;&gt;z2;</span><br><span class="line">h1=(h1+lans<span class="number">-1</span>)%<span class="number">39989</span>+<span class="number">1</span>;</span><br><span class="line">h2=(h2+lans<span class="number">-1</span>)%<span class="number">39989</span>+<span class="number">1</span>;</span><br><span class="line">z1=(z1+lans<span class="number">-1</span>)%<span class="number">1000000000</span>+<span class="number">1</span>;</span><br><span class="line">z2=(z2+lans<span class="number">-1</span>)%<span class="number">1000000000</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(h1&gt;h2) <span class="built_in">swap</span>(h1,h2),<span class="built_in">swap</span>(z1,z2);</span><br><span class="line">line c=<span class="built_in">line</span>(h1,z1,h2,z2,++tot);</span><br><span class="line"><span class="built_in">insert</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">40000</span>,h1,h2,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">x=(x+lans<span class="number">-1</span>)%<span class="number">39989</span>+<span class="number">1</span>;</span><br><span class="line">lans=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">40000</span>,x).id;</span><br><span class="line">cout&lt;&lt;lans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题1-P4027-NOI2007-货币兑换"><a href="#例题1-P4027-NOI2007-货币兑换" class="headerlink" title="例题1 P4027 [NOI2007] 货币兑换"></a>例题1 <a href="https://www.luogu.com.cn/problem/P4027">P4027 [NOI2007] 货币兑换</a></h4><p>【解析】</p><p>设 $f_i$ 表示第 $i$ 天最大的收益。</p><p>初始条件 $f_0&#x3D;s$，答案 $f_n$。</p><p>转移枚举上一个全买券的点 $j$，设 $y$ 表示第 $j$ 天买 $B$ 的数量，解方程。</p><p>$Rate_j\times y_j\times a_j+y_j\times b_j&#x3D;f_j$</p><p>得到 $y_j&#x3D;\large\frac{f_j}{Rate_j\times a_j+b_j}$</p><p>设 $x$ 表示买 $A$ 的数量，显然 $x_i&#x3D;Rate_j\times y_i$</p><p>转移方程 $f_i&#x3D;\max(f_{i-1},\max{a_i\times x_j+b_i\times y_j | j\in[1,i) } )$</p><p>提出 $b_i$，得到 $f_i&#x3D;\max(f_{i-1},b_i\times \max{\large\frac{a_i}{b_i}\small\times x_j+y_j})$</p><p>发现变成一次函数形式，即对于每个 $x_j,y_j$，查询 $\large\frac{a_i}{b_i}$ 处的最大值即可。</p><p>李超线段树。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">db <span class="title">val</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> t)</span></span>&#123;<span class="keyword">return</span> x[t]*k[i]+y[t];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">val</span>(l,id)&gt;<span class="built_in">val</span>(l,t[p])) t[p]=id;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">val</span>(mid,id)&gt;<span class="built_in">val</span>(mid,t[p])) <span class="built_in">swap</span>(id,t[p]);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">val</span>(l,id)&gt;<span class="built_in">val</span>(l,t[p])) <span class="built_in">modify</span>(ls,id,l,mid);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(rs,id,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="built_in">val</span>(now,t[p]);</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(now&lt;=mid) <span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">val</span>(now,t[p]),<span class="built_in">query</span>(ls,l,mid));</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">val</span>(now,t[p]),<span class="built_in">query</span>(rs,mid+<span class="number">1</span>,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;IOS;</span><br><span class="line"><span class="type">int</span> n,s;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">f[<span class="number">0</span>]=s;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n) cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;r[i],k[i]=a[i]/b[i],kk[i]=k[i];</span><br><span class="line"><span class="built_in">sort</span>(k+<span class="number">1</span>,k+<span class="number">1</span>+n);</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">now=<span class="built_in">lower_bound</span>(k+<span class="number">1</span>,k+n+<span class="number">1</span>,kk[i])-k;</span><br><span class="line">f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>],b[i]*<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n));</span><br><span class="line">db tmp=a[i]*r[i]+b[i];</span><br><span class="line">y[i]=f[i]/tmp;</span><br><span class="line">x[i]=r[i]*y[i];</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,i,<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与此题类似的题：</p><p><a href="https://www.luogu.com.cn/problem/P2497">P2497 [SDOI2012] 基站建设</a></p><p><a href="https://www.luogu.com.cn/problem/P5504">P5504 [JSOI2011] 柠檬</a></p><p><a href="https://www.luogu.com.cn/problem/P4655">P4655 [CEOI2017] Building Bridges</a></p><hr><p><strong>完结撒花！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;斜率优化&quot;&gt;&lt;a href=&quot;#斜率优化&quot; class=&quot;headerlink&quot; title=&quot;斜率优化&quot;&gt;&lt;/a&gt;斜率优化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;斜率优化，一般是在转移方程中当前为 $i$，枚举决策点 $j$，然后化简式子出现同时与 $i$ 和 $j$ 有关</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF631E</title>
    <link href="http://example.com/2024/03/31/CF631E/"/>
    <id>http://example.com/2024/03/31/CF631E/</id>
    <published>2024-03-31T13:59:23.608Z</published>
    <updated>2024-04-01T14:35:58.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CF631E-Product-Sum"><a href="#CF631E-Product-Sum" class="headerlink" title="CF631E Product Sum"></a>CF631E Product Sum</h2><ul><li>斜率优化DP</li></ul><p><a href="https://codeforces.com/contest/631/problem/E">传送门</a></p><h3 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h3><p>模拟赛 D 题。感觉是个斜优的比较板的题。</p><p>开始写了一发错误的贪心，Wa on 9，后来改成 DP 才过。</p><p>场上过了 $5$ 个，拜谢 AK 爷 <a href="https://www.luogu.com.cn/user/593274">@Helloworld_wuyuze</a> <a href="https://www.luogu.com.cn/user/586905">@RailgunZzzz</a> <a href="https://www.luogu.com.cn/user/536743">@秦屎皇</a>。</p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的序列，序列的价值定义为 $\sum_{i&#x3D;1}^na_i\times i$。允许至多一次操作，把一个元素移动到任意一个序列中的位置，求最大的序列价值。</p><p>$2\le n\le 2\times 10^5，|a_i|\le 10^6$。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>先考虑 naive 做法。对于每个 $a_i$，枚举其移动到的位置位置 $j$，每次计算贡献的变化，时间复杂度 $O(n^2)$。</p><p>具体地，分两种情况讨论。对于向前移动，即 $j&lt;i$，从 $i$ 移到 $j$ 后面，会使位于 $[j+1,i-1]$ 的元素贡献多一次，然后 $i$ 的贡献转化到了 $j+1$。</p><p>也就是 $s_{i-1}-s_{j}-(i-(j+1))\times a_i$。这里的 $s_i$ 表示 $a_i$ 的前缀和。</p><p>对于向后移动，移动到位置 $j$，会使 $[i+1,j]$ 的元素贡献少一次，再算上 $i$ 到 $j$ 的贡献。</p><p>$-(s_j-s_i)+(j-i)\times a_i$，即 $s_i-s_j+(j-i)\times a_i$。</p><p>尝试化简一下第一个式子。<br>$$<br>\begin{aligned}<br>&amp;s_{i-1}-s_{j}-(i-(j+1))\times a_i\\<br>&#x3D;&amp;s_{i-1}-s_j-(i-j-1)\times a_i\\<br>&#x3D;&amp;s_{i-1}-s_j+a_i-(i-j)\times a_i\\<br>&#x3D;&amp;s_i-s_j-(i-j)\times a_i\\<br>&#x3D;&amp;s_i-s_j+(j-i)\times a_i<br>\end{aligned}<br>$$<br>我们推导可以发现，向前移动与向后移动的式子等价。这样的话，两个转移被合并成了一个转移，方便很多。</p><p>我们还需要优化。把括号拆开，变成 $s_i-s_j+a_i\times j-a_i\times i$。发现此时的方程中只有一个与 $i,j$ 都有关的项 $a_i\times j$ 和几个只与 $i$ 或 $j$ 有关的项。是斜率优化的经典形式，此处不赘述斜优过程。</p><p>数据没有单调性，所以可以用二分凸包或者李超树维护。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>考场上没想到可以变一个式子，正反做了两遍，二分+栈。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> M=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> k,b;</span><br><span class="line"><span class="built_in">line</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">line</span>(<span class="type">int</span> _k,<span class="type">int</span> _b)&#123;</span><br><span class="line">k=_k,b=_b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k*x+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> t1 s.size()-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> t2 s.size()-2</span></span><br><span class="line">vector&lt;line&gt; s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(line x,line p1,line p2)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (p2.b-x.b)*(p1.k-p2.k)&lt;=(p2.b-p1.b)*(x.k-p2.k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(line x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(s.<span class="built_in">size</span>()&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">cmp</span>(x,s[t1],s[t2])) s.<span class="built_in">pop_back</span>();</span><br><span class="line">s.<span class="built_in">eb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=t1;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(s[mid].<span class="built_in">calc</span>(x)&gt;=s[mid+<span class="number">1</span>].<span class="built_in">calc</span>(x)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[r].<span class="built_in">calc</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> t1</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> t2</span></span><br><span class="line">&#125;t1,t2;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> n,res=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">f[i]=f[i<span class="number">-1</span>]+a[i];</span><br><span class="line">res+=i*a[i];</span><br><span class="line">&#125;</span><br><span class="line">t1.<span class="built_in">insert</span>(<span class="built_in">line</span>(<span class="number">1</span>,-f[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,-a[i]*i+f[i<span class="number">-1</span>]+t1.<span class="built_in">query</span>(a[i]));</span><br><span class="line">t1.<span class="built_in">insert</span>(<span class="built_in">line</span>(i,-f[i<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">t2.<span class="built_in">insert</span>(<span class="built_in">line</span>(-n,-f[n]));</span><br><span class="line"><span class="built_in">fo</span>(i,n<span class="number">-1</span>,<span class="number">1</span>)&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,-a[i]*i+f[i]+t2.<span class="built_in">query</span>(-a[i]));</span><br><span class="line">t2.<span class="built_in">insert</span>(<span class="built_in">line</span>(-i,-f[i]));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans+res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赛后用李超树写了第二种实现，$k&#x3D;j,b&#x3D;-s_j$，查询 $x&#x3D;a_i$ 处的最值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> F(i,x,y) for(int i=(x);i&lt;=(y);++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,x,y) for(int i=(x);i&gt;=(y);--i)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> M=<span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">constexpr</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> k[N],b[N],s[N],a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> k[i]*x+b[i];&#125;</span><br><span class="line"><span class="type">int</span> t[M&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">calc</span>(x,l)&gt;<span class="built_in">calc</span>(t[p],l)) t[p]=x;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(x,mid)&gt;<span class="built_in">calc</span>(t[p],mid)) <span class="built_in">swap</span>(t[p],x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(x,l)&gt;<span class="built_in">calc</span>(t[p],l)) <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">calc</span>(x,r)&gt;<span class="built_in">calc</span>(t[p],r)) <span class="built_in">update</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="built_in">calc</span>(t[p],x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">calc</span>(t[p],x);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> <span class="built_in">max</span>(res,<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(res,<span class="built_in">query</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> n,res=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">res+=i*a[i];</span><br><span class="line">s[i]=a[i]+s[i<span class="number">-1</span>];</span><br><span class="line">k[i]=i;</span><br><span class="line">b[i]=-s[i];</span><br><span class="line"><span class="built_in">update</span>(<span class="number">1</span>,-M,M,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">F</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line"><span class="type">int</span> tmp=<span class="built_in">query</span>(<span class="number">1</span>,-M,M,a[i]);</span><br><span class="line">ans=<span class="built_in">max</span>(ans,s[i]-a[i]*i+tmp);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans+res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>完结撒花！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CF631E-Product-Sum&quot;&gt;&lt;a href=&quot;#CF631E-Product-Sum&quot; class=&quot;headerlink&quot; title=&quot;CF631E Product Sum&quot;&gt;&lt;/a&gt;CF631E Product Sum&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>AT_dp</title>
    <link href="http://example.com/2024/03/31/AT_dp/"/>
    <id>http://example.com/2024/03/31/AT_dp/</id>
    <published>2024-03-31T13:58:15.360Z</published>
    <updated>2024-04-01T15:02:04.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>DP 太菜了，刷 AT 经典 DP，前面的比较简单，从 J 开始吧 qwq</p><hr><h3 id="AT-dp-J"><a href="#AT-dp-J" class="headerlink" title="AT_dp_J"></a>AT_dp_J</h3><ul><li>期望 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_j">传送门</a></p><p>注意到 $a_i\leq3$，所以状态应该跟 $a_i$ 有关。考虑设 $f_{a,b,c,d}$ 表示有 $a$ 种剩余 $3$ 个的寿司，$b$ 种剩余 $2$ 个的寿司……</p><p>$$f_{a,b,c,d}&#x3D;1+\frac{a}{n}f_{a-1,b+1,c,d}+\frac{b}{n}f_{a,b-1,c+1,d}+\frac{c}{n}f_{a,b,c-1,d+1}+\frac{d}{n}f_{a,b,c,d}$$<br>整理并可得<br>$$f_{a,b,c,d}&#x3D;\frac{n}{n-d}+\frac{a}{n-d}f_{a-1,b+1,c,d}+\frac{b}{n-d}f_{a,b-1,c+1,d}+\frac{c}{n-d}f_{a,b,c-1,d+1}$$</p><p>这样是四维的，发现 $d&#x3D;n-(a+b+c)$，于是变成 $3$ 维，可以 $O(n^3)$ 的 DP，得到最终方程</p><p>$$f_{a,b,c}&#x3D;\frac{n}{a+b+c}+\frac{a}{a+b+c}f_{a-1,b+1,c}+\frac{b}{a+b+c}f_{a,b-1,c+1}+\frac{c}{a+b+c}f_{a,b,c-1}$$</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i) cin&gt;&gt;x,a[x]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;++k)</span><br><span class="line">      <span class="keyword">if</span>(i+j+k)&#123;</span><br><span class="line">        <span class="type">double</span> p=i+j+k;</span><br><span class="line">        <span class="keyword">if</span>(i) f[i][j][k]+=(<span class="number">1.0</span>*i/p*f[i<span class="number">-1</span>][j+<span class="number">1</span>][k]);</span><br><span class="line">        <span class="keyword">if</span>(j) f[i][j][k]+=(<span class="number">1.0</span>*j/p*f[i][j<span class="number">-1</span>][k+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(k) f[i][j][k]+=(<span class="number">1.0</span>*k/p*f[i][j][k<span class="number">-1</span>]);</span><br><span class="line">        f[i][j][k]+=<span class="number">1.0</span>*n/p;</span><br><span class="line">      &#125;</span><br><span class="line">cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;f[a[<span class="number">3</span>]][a[<span class="number">2</span>]][a[<span class="number">1</span>]]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong>给点启示：</strong> DP 优化的一个思路：合并等价状态、消除无用状态（这个有点像百钱买百只因）。</p><hr><h3 id="AT-dp-K"><a href="#AT-dp-K" class="headerlink" title="AT_dp_K"></a>AT_dp_K</h3><ul><li>博弈论</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_k">传送门</a></p><p>简单题。设 $f_i$ 表示剩余 $i$ 个石子时当前操作者的胜负，那么显然 $f_0&#x3D;0$。考虑转移，用点博弈论的知识，必败状态后继的所有状态都是必胜状态，那么写出转移 $f_i&#x3D;\max{[f_{i-a_j}&#x3D;0],1\le j\le n}$</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i-a[j]&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    f[i]|=(!f[i-a[j]]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-L"><a href="#AT-dp-L" class="headerlink" title="AT_dp_L"></a>AT_dp_L</h3><ul><li>区间 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_l">传送门</a></p><p>一个经典的 trick。设 $f_{i,j}$ 表示序列还剩下 $[i,j]$ 时，$X-Y$ 的最大值。转移要分两种情况，因为是两个人轮流取，一个会使答案增大，另一个使答案变小。</p><p>具体地，当前操作次数为偶数，先手取改变 $X$，$f_{i,j}&#x3D;\max(f_{i+1,j}+a_i,f_{i,j-1}+a_j)$。</p><p>否则后手取，$f_{i,j}&#x3D;\min(f_{i+1,j}-a_i,f_{i,j-1}-a_j)$。</p><p>答案即为 $f_{1,n}$，时间复杂度 $O(n^2)$。</p><p>与此题很类似的，还有 <a href="https://atcoder.jp/contests/tdpc/tasks/tdpc_game">AT_tdpc_game</a>，可以左转<a href="https://www.luogu.com.cn/article/8lch1g1m">我的题解</a>。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;++len)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n;++i)&#123;</span><br><span class="line"><span class="type">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>((n-len)&amp;<span class="number">1</span>) f[i][j]=<span class="built_in">min</span>(f[i+<span class="number">1</span>][j]-a[i],f[i][j<span class="number">-1</span>]-a[j]);</span><br><span class="line"><span class="keyword">else</span> f[i][j]=<span class="built_in">max</span>(f[i+<span class="number">1</span>][j]+a[i],f[i][j<span class="number">-1</span>]+a[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题还有一个贪心的思路，可以做到线性。</p><p>考虑对于每三个数，如果中间的最大，那么一定是先手取两边，后手取中间，这样把序列中的这样结构的三个数贡献合并成两边减中间，此时序列一定先减后增，直接贪心即可。</p><p>形式化地，$\forall a_{i-1},a_i,a_{i+1}(1&lt;i&lt;n)，s.t.\ a_i\ge a_{i-1}$ 且 $a_i\ge a_{i+1}$，将其改为 $f_i&#x3D;a_{i-1}+a_{i+1}-a_i$，剩余的不变。</p><p>这个做法代码不贴了。</p><p><strong>启示：</strong> 很多这种类似博弈两个人取数的题都可以转化成这种 DP 的状态设计，算是一个区间 DP 的套路了。</p><hr><h3 id="AT-dp-M"><a href="#AT-dp-M" class="headerlink" title="AT_dp_M"></a>AT_dp_M</h3><ul><li>前缀和优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_m">传送门</a></p><p>首先考虑一下朴素 DP，设 $f_{i,j}$ 表示进行到 $i$，已经分出去了 $j$ 块糖的方案数。那么显然 $f_{i,j}&#x3D;\sum_{k&#x3D;0}^{a_i}f_{i-1,k}$。每次转移都需要扫一遍，时间复杂度 $O(nk^2)$ 。</p><p>但是发现每一层 DP 的状态只与上一层有关，所以可以直接使用前缀和优化，时间复杂度 $O(nk)$。</p><p>代码不贴了，注意数组下标，前缀和容易 RE。</p><p><strong>启示：</strong> 当发现 DP 转移时方程只与上一层有关时，可以考虑用一些求和数据结构优化（比如前缀和）。</p><hr><h3 id="AT-dp-N"><a href="#AT-dp-N" class="headerlink" title="AT_dp_N"></a>AT_dp_N</h3><ul><li>区间 DP</li><li>前缀和优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_n">传送门</a></p><p>区间 DP 傻题，和 <a href="https://www.luogu.com.cn/problem/P1775">石子合并</a> 一模一样。</p><p>需要注意的一点是，朴素直接计算贡献是 $O(n^4)$ 的，使用前缀和优化到 $O(n^3)$。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;++k)</span><br><span class="line">      f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-O"><a href="#AT-dp-O" class="headerlink" title="AT_dp_O"></a>AT_dp_O</h3><ul><li>状压 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_o">传送门</a></p><p><del>拜谢老头。</del> 看数据范围考虑状压 DP。发现一个合法的方案一定满足每一行、每一列只选一个 $1$，所以设 $f_{i,S}$ 表示进行到第 $i$ 行，此时选点集合为 $S$，复杂度 $O(n^22^n)$ 会 T 掉。但观察可知已知 $S$ 即可确定 $i$，是 $S$ 中 $1$ 的个数，所以可以直接设为 $f_S$，复杂度 $O(n2^n)$。</p><p>Tips：popcount 用来计算二进制 $1$ 的个数。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>;S&lt;(<span class="number">1</span>&lt;&lt;n);++S)&#123;</span><br><span class="line"><span class="type">int</span> k=__builtin_popcount(S);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(S&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;a[k][j])</span><br><span class="line">f[S|(<span class="number">1</span>&lt;&lt;j)]=(f[S|(<span class="number">1</span>&lt;&lt;j)]+f[S])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-P"><a href="#AT-dp-P" class="headerlink" title="AT_dp_P"></a>AT_dp_P</h3><ul><li>树形 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_p">传送门</a></p><p><del>没有舞会的上司。</del> 树上 DP 简单题。设 $f_{u,0&#x2F;1}$ 表示当前点为 $u$，当前点是否染成黑色。那么对于 $f_{u,0}$，它的子节点染成什么颜色对其没有限制，所以 $f_{u,0}&#x3D;\prod_{v\in u}(f_{v,0}+f_{v,1})$；而对于 $f_{u,1}$，子节点不能还是黑色，所以 $f_{u,1}&#x3D;\prod_{v\in u}f_{v,1}$。</p><p>最后自底向上 dfs 即可，答案为 $f_{1,0}+f_{1,1}$，线性复杂度。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">f[u][<span class="number">0</span>]=f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line">f[u][<span class="number">0</span>]=f[u][<span class="number">0</span>]*(f[v][<span class="number">0</span>]+f[v][<span class="number">1</span>])%mod;</span><br><span class="line">f[u][<span class="number">1</span>]=f[u][<span class="number">1</span>]*f[v][<span class="number">0</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-Q"><a href="#AT-dp-Q" class="headerlink" title="AT_dp_Q"></a>AT_dp_Q</h3><ul><li>数据结构优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_q">传送门</a></p><p>最长上升子序列加权版。</p><p>发现朴素的 DP 就是 朴素的 LIS，设 $f_i$ 表示以 $i$ 为结尾的最大答案，只是把每次的贡献从 $1$ 变成 $a_i$ 了。但这样做是 $O(n^2)$ 的，考虑每次都是选择 $h_j&lt;h_i$ 的最大 $f_j$，这样可以使用数据结构优化。$f_i&#x3D;a_i+\max{f_j,1\le j&lt;i,h_j&lt;h_i}$。需要支持单点修，区间求最值，复杂度 $O(n\ logn)$。</p><p>这里使用了树状数组，因为要求的是前缀最大值，而且单点修改，树状数组比线段树更容易实现。</p><p><strong>Code:</strong></p><p>树状数组部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) c[i]=<span class="built_in">max</span>(c[i],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res=<span class="built_in">max</span>(res,c[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">ll x,a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">x=<span class="built_in">query</span>(h[i]<span class="number">-1</span>)+a;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,x);</span><br><span class="line"><span class="built_in">add</span>(h[i],x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 对于一个 DP 转移方程，如果转移复杂度很高，要求的东西只与之前的值有关，可以尝试数据结构优化。</p><hr><h3 id="AT-dp-R"><a href="#AT-dp-R" class="headerlink" title="AT_dp_R"></a>AT_dp_R</h3><ul><li>矩阵加速 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_r">传送门</a></p><p>题目要求路径长度为 $k$ 的路径数，朴素的 DP 是直接设 $f_{k,i,j}$ 表示从 $i$ 到 $j$ 路径长度为 $k$ 的方案数，然后转移<br>$$f_{k,i,j}&#x3D;\sum_{u&#x3D;1}^nf_{k-1,i,u}+f_{1,u,j}$$</p><p>发现这样转移复杂度会爆炸，因为 $k$ 是 $10^{18}$ 量级的，但是这个方程你会发现跟最短路中的 Floyd 非常像，这就是个显然的矩阵乘法形式，于是想到矩阵优化，对于每一个距离矩阵 $f_i$，$f_i&#x3D;f_{i-1}\times f_1$，那么直接快速幂即可，答案为 $f_1^{k}$ 的所有元素和。时间复杂度 $O(n^3\ logk)$，可以通过。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">ll a[N][N];</span><br><span class="line"><span class="built_in">matrix</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">&#125;a;</span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="type">const</span> matrix&amp;a,<span class="type">const</span> matrix&amp;b)&#123;</span><br><span class="line">matrix res;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;++k)</span><br><span class="line">res.a[i][j]=(res.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">ksm</span><span class="params">(matrix a,ll k)</span></span>&#123;</span><br><span class="line">matrix res;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) res.a[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">a=a*a;</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 当一个线性 DP 发现转移数量非常多（一般达到了 $10^9$ 以上的量级），可以考虑矩阵优化。</p><hr><h3 id="AT-dp-S"><a href="#AT-dp-S" class="headerlink" title="AT_dp_S"></a>AT_dp_S</h3><ul><li>数位 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_s">传送门</a></p><p>看数据范围超级大想数位 DP。考虑记录 $3$ 个状态：当前位、是否达到最高位限制、当前数各位和模 $D$ 结果，边界条件是最后模 $D$ 为 $0$ 了答案加一。</p><p>具体地，设 $f_{pos,m,limit}$ 表示当前考虑到第 $pos$ 位（倒序从最高位往后找），各个位上的和模 $D$ 为 $m$，是否顶到上界。边界条件 $f_{0,0,0&#x2F;1}&#x3D;1$，转移时<br>$$f_{pos,m,limit}&#x3D;\sum f_{pos-1,(m+i)%D,limit&amp;&amp;[i&#x3D;n]}$$</p><p>注意，$i$ 表示当前枚举的下一位，$n$ 表示下一位的最大值。</p><p><strong>警钟：</strong> 最后的答案要 -1，因为 $0$ 不算，但减一以后可能会变成负数（全为 $0$ 的情况），所以还要加 mod 再对 mod 取模。</p><p>代码用记忆化搜索实现（因为太菜了不会递推），其实 $f$ 的第三维 $limit$ 可以不用设，但为了清晰还是写了。</p><p><strong>Code:</strong></p><p>记忆化搜索部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> m,<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> (m==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(~f[pos][m][limit]) <span class="keyword">return</span> f[pos][m][limit];</span><br><span class="line"><span class="type">int</span> n=limit?a[pos]:<span class="number">9</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i) res=(res+<span class="built_in">dfs</span>(pos<span class="number">-1</span>,(m+i)%d,limit&amp;&amp;(i==n)))%mod;</span><br><span class="line"><span class="keyword">return</span> f[pos][m][limit]=res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数部分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i) a[l-i]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">cout&lt;&lt;(<span class="built_in">dfs</span>(l,<span class="number">0</span>,<span class="number">1</span>)<span class="number">-1</span>+mod)%mod;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 当计算某些数的数量，且范围很大，考虑数位 DP，记忆化搜索可以便捷实现，注意是否要考虑前导零。</p><hr><h3 id="AT-dp-T"><a href="#AT-dp-T" class="headerlink" title="AT_dp_T"></a>AT_dp_T</h3><ul><li>前缀和优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_t">传送门</a></p><p>考虑设 $f_{i,j}$ 表示确定前 $i$ 个数，其中第 $i$ 个是 $j$ 的方案数，那么初始状态 $f_{1,1}&#x3D;1$。对于转移分两种情况讨论，如果 $s_i$ 是小于号，那么 $f_{i,j}&#x3D;\sum_{k&#x3D;1}^{j-1}f_{i-1,k}$，否则 $f_{i,j}&#x3D;\sum_{k&#x3D;j}^{i-1}f_{i-1,k}$。</p><p>朴素的转移是 $O(n^3)$ 的。发现又是只与上一层状态有关，可以通过前缀和优化为 $O(n^2)$，于是可以通过此题。</p><p>注意一下大于小于号与下标对应关系 qwq。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">1</span>][<span class="number">1</span>]=s[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(ch[i]==<span class="string">&#x27;&lt;&#x27;</span>) f[i][j]=s[i<span class="number">-1</span>][j<span class="number">-1</span>]%mod;</span><br><span class="line"><span class="keyword">else</span> f[i][j]=(f[i][j]+s[i<span class="number">-1</span>][i<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">s[i][j]=(s[i][j<span class="number">-1</span>]+f[i][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=(ans+f[n][i])%mod;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 与 $M$ 题相同。</p><hr><h3 id="AT-dp-U"><a href="#AT-dp-U" class="headerlink" title="AT_dp_U"></a>AT_dp_U</h3><ul><li>状压 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_u">传送门</a></p><p>看数据范围，显然是状压。考虑设 $f_S$ 表示已选兔子集合状态为 $S$ 的答案，设 $V_T$ 表示一组中的兔子状态为 $T$ 的贡献，那么可以写出转移方程 $f_S&#x3D;\max_{T\in S}{f_T+V_{\complement_ST}}$。</p><p>那其实就做完了，先枚举集合并预处理数组 $V$，复杂度 $O(2^nn^2)$，然后枚举子集转移，复杂度 $O(3^n)$，于是做完了。</p><p><strong>Code:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);++s)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((s&gt;&gt;i)&amp;<span class="number">1</span>)&amp;&amp;((s&gt;&gt;j)&amp;<span class="number">1</span>))&#123;</span><br><span class="line">                v[s]+=a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[s]=v[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);++s)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> cs=s;cs&gt;<span class="number">0</span>;cs=(cs<span class="number">-1</span>)&amp;s)&#123;</span><br><span class="line">        f[s]=<span class="built_in">max</span>(f[s],f[cs]+v[s^cs]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 枚举子集复杂度 $O(3^n)$，数据范围在 $20$ 以内有限考虑状压 DP。</p><hr><h3 id="AT-dp-V"><a href="#AT-dp-V" class="headerlink" title="AT_dp_V"></a>AT_dp_V</h3><ul><li>树形 DP</li><li>换根 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_v">传送门</a></p><p>考虑树形 DP。设 $g_u$ 表示 $u$ 染成黑点，$u$ 的子树内的答案，转移的话可以 $g_u&#x3D;\prod_{v\in u}(g_v+1)$，表示对于每个儿子 $v$，都计算 $v$ 子树内的答案 $g_v$，以及 $v$ 染成白色，其子树全是白色的 $1$。这样总体做下来一次是 $O(n)$ 的。</p><p>但是题目要求输出每一个点为根的答案，一次 dfs 只能计算一个点为根的答案，总体复杂度 $O(n^2)$ 不能接受，所以考虑使用换根 DP，在第二次 dfs 中求出所有点的答案。</p><p>所以考虑设 $f_u$ 表示将 $u$ 染成黑色，$u$ 和其子树外的点所得的答案，那么显然对于每个点，最终的答案就是 $f_u\times g_u$。转移方程为 $f_v&#x3D;f_{u}+\frac{g_{u}}{g_v+1}+1$。这表示父亲 $u$ 的答案加上 $u$ 除 $v$ 的儿子的答案再加上白点的 $1$。时间复杂度 $O(n)$。</p><p>本来这个题已经快乐地做完了，但问题在于答案需要取模，模数不一定是质数。这就十分棘手，因为你无法直接算逆元。所以考虑对于每个点 $u$ 记一个前缀积 $pre$ 和后缀积 $suf$，在第一遍 dfs 中预处理。这样转移时除法就变成了挖去此点的前后缀积。</p><p>形式化地，$f_v&#x3D;f_u+pre_{u,i-1}\times suf_{u,i+1}+1$。其中 $i$ 表示 $v$ 是第几个儿子。代码中因为前后缀积的下标从 $0$ 开始，所以变成了 $pre_{u,i-2}\times suf_{u,i}$，本质上没有区别。</p><p><strong>Code:</strong></p><p>注意开 long long 和特殊的 $f_1&#x3D;1$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">g[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">g[u]=g[u]*(g[v]+<span class="number">1</span>)%mod;</span><br><span class="line">pre[u].<span class="built_in">push_back</span>(g[v]+<span class="number">1</span>);</span><br><span class="line">suf[u].<span class="built_in">push_back</span>(g[v]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l=pre[u].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;l;++i) pre[u][i]=<span class="number">1ll</span>*pre[u][i<span class="number">-1</span>]*pre[u][i]%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i) suf[u][i]=<span class="number">1ll</span>*suf[u][i+<span class="number">1</span>]*suf[u][i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=pre[u].<span class="built_in">size</span>(),cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(l==<span class="number">1</span>) f[v]=f[u]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">1</span>) f[v]=f[u]*suf[u][<span class="number">1</span>]%mod+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt==l) f[v]=f[u]*pre[u][cnt<span class="number">-2</span>]%mod+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> f[v]=f[u]*pre[u][cnt<span class="number">-2</span>]%mod*suf[u][cnt]%mod+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启示：</strong> 换根 DP 的套路。</p><blockquote><p>$1.$ 指定某个节点为根节点（一般为 $1$）。</p><p>$2.$ 第一次搜索完成预处理，同时得到该节点的解。</p><p>$3.$ 第二次搜索进行换根 DP，由已知节点推出相邻节点。</p></blockquote><hr><h3 id="AT-dp-W"><a href="#AT-dp-W" class="headerlink" title="AT_dp_W"></a>AT_dp_W</h3><ul><li>数据结构优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_w">传送门</a></p><p>跟 NOIP T4 有点像对吧。先用一个经典的 trick，把一段区间的贡献转化为右端点的贡献，排序后只有到右端点才计算贡献，用一个结构体存储区间信息。</p><p>设 $f_{i,j}$ 表示进行到位置 $i$，最后一个 $1$ 在位置 $j$ 的答案。考虑转移，如果 $i&#x3D;j$，也即在最后一个位置放了 $1$，那么 $f_{i,i}&#x3D;\max_{j&#x3D;1}^{i-1}f_{i-1,j}$。</p><p>否则 $i\neq j$，考虑每一个转移相对于 $i-1$ 都是加上了右端点在 $i$ 且左端点包含 $j$ 的答案。<br>$$f_{i,j}&#x3D;f_{i-1,j}+\sum_{l_k\le j,r_k&#x3D;i} a_k$$</p><p>这样朴素转移复杂度是 $O(n^2)$ 的，必须优化。考虑当  $i&#x3D;j$，查询了最值，对于 $i\neq j$，所有右端点 $i$ 的区间贡献都要累加到 DP 数组里，这是区间加的操作。于是可以使用线段树维护 DP 数组优化一下转移，这样的复杂度变成了 $O(n\ log n)$。</p><p>空间复杂度部分，可以直接压到一维。注意每次的答案要与 $0$ 取 $\max$。</p><p><strong>Code:</strong></p><p>线段树部分就不放了，纯板子，查询是查询整体最值。</p><p>代码中的 $v_i$ 表示第 $i$ 个命令。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="built_in">update</span>(<span class="number">1</span>,i,i,<span class="built_in">query</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> u:v[i]) <span class="built_in">update</span>(<span class="number">1</span>,u.l,i,u.w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-X"><a href="#AT-dp-X" class="headerlink" title="AT_dp_X"></a>AT_dp_X</h3><ul><li>背包 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_x">传送门</a></p><p>我们先考虑最优策略。对于两个物品 $i$，$j$，如果 $i$ 放到 $j$ 下面，那么 $i$ 上面除了 $j$ 以外还能放 $s_i-w_j$ 重量的物品；如果 $j$ 放到 $i$ 下面，就能放 $s_j-w_i$ 重量的物品。考虑上面能放的更多那就更优，即 $i$ 放 $j$ 下面当且仅当 $s_i-w_j&gt;s_j-w_i$，移项得 $s_i+w_i&gt;s_j+w_j$。所以我们根据 $s+w$ 排序，这样放一定最优。</p><p>接下来 01 背包即可，答案为 $\max{f_i}$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.w+a.s&lt;b.w+b.s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">20005</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i].w&gt;&gt;a[i].s&gt;&gt;a[i].v;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=a[i].s;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">f[j+a[i].w]=<span class="built_in">max</span>(f[j+a[i].w],f[j]+a[i].v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20000</span>;++i) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-Y"><a href="#AT-dp-Y" class="headerlink" title="AT_dp_Y"></a>AT_dp_Y</h3><ul><li>组合数学</li><li>DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_y">传送门</a></p><p>H 题的加强版。</p><p>考虑设 $f_{i,j}$ 表示从 $(1,1)$ 走到 $(i,j)$，不经过障碍的方案数。先考虑没有障碍的简单情况，那么方案数就是 $\large \binom{i+j-2}{i-1}$，即选择 $i-1$ 步向下，剩下的向右。那么想想有障碍的转移，发现走到一个点的方案等于上述组合数减所有其左上角障碍的 $f$。想想为什么，因为所有会经过障碍的路都在左上角的障碍的 $f$ 里面。形式化地，$f_{i,j}&#x3D;calc(i,j)-\sum_{x&lt;&#x3D;i,y&lt;&#x3D;j,(x,y)\ne(i,j)}calc(x,y)$。这里的 $calc$ 就是指带入上面的组合数公式。所以处理一下组合数，时间复杂度 $O(n^2)$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a[M];</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">a=a*a%mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll f[M],fac[N&lt;&lt;<span class="number">1</span>],inv[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2e5</span>;++i) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">inv[<span class="number">200000</span>]=<span class="built_in">ksm</span>(fac[<span class="number">200000</span>],mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2e5</span><span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i) inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;h&gt;&gt;w&gt;&gt;n;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i].fi&gt;&gt;a[i].se;</span><br><span class="line">n++;</span><br><span class="line">a[n]=<span class="built_in">make_pair</span>(h,w);</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">f[i]=<span class="built_in">C</span>(a[i].fi+a[i].se<span class="number">-2</span>,a[i].fi<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j].se&gt;a[i].se) <span class="keyword">continue</span>;</span><br><span class="line">f[i]=(f[i]-f[j]*<span class="built_in">C</span>(a[i].fi-a[j].fi+a[i].se-a[j].se,a[i].fi-a[j].fi)%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AT-dp-Z"><a href="#AT-dp-Z" class="headerlink" title="AT_dp_Z"></a>AT_dp_Z</h3><ul><li>斜率优化 DP</li></ul><p><a href="https://atcoder.jp/contests/dp/tasks/dp_z">传送门</a></p><p>a，b 题加强版。转移显然，设 $f_i$ 表示走到 $i$ 时的最小花费，那 $f_i&#x3D;\min_{1\le j&lt;i}(f_j+(h_i-h_j)^2+C)$。 </p><p>拆开式子变成 $f_i&#x3D;f_j+h_i^2+h_j^2-2\times h_i\times h_j+C$。</p><p>移项，把 $j$ 分离，$f_j+h_j^2&#x3D;f_i-h_i^2-C+2\times h_i\times h_j$。</p><p>设 $y_j&#x3D;f_j+h_j^2$，$k_i&#x3D;2\times h_i$，$x_j&#x3D;h_j$，$b_i&#x3D;f_i-h_i^2$，变成了一次函数形式，可以斜率优化。</p><p>题目要求最小值，维护下凸壳，又发现了 $y_j$ 和 $x_j$ 保证单调递增，所以使用单调队列维护，线性。</p><p>斜率优化可以左转<a href="https://jkyak.github.io/2024/03/31/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/">我的斜率优化详解</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">y</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f[i]+h[i]*h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">y</span>(i)-<span class="built_in">y</span>(j))/(h[i]-h[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;h[i];</span><br><span class="line">he=t=<span class="number">1</span>;</span><br><span class="line">q[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(he&lt;t&amp;&amp;<span class="built_in">calc</span>(q[he],q[he+<span class="number">1</span>])&lt;=<span class="number">2</span>*h[i]) he++;</span><br><span class="line"><span class="type">int</span> j=q[he];</span><br><span class="line">f[i]=f[j]+(h[i]-h[j])*(h[i]-h[j])+c;</span><br><span class="line"><span class="keyword">while</span>(he&lt;t&amp;&amp;<span class="built_in">calc</span>(q[t<span class="number">-1</span>],q[t])&gt;=<span class="built_in">calc</span>(q[t],i)) t--;</span><br><span class="line">q[++t]=i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>至此，<strong>26</strong> 个 AT_dp 已经结束，这其中几乎包含了所有比较简单的 DP 类型，获益匪浅。</p><p>完结撒花！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;闲话&quot;&gt;&lt;a href=&quot;#闲话&quot; class=&quot;headerlink&quot; title=&quot;闲话&quot;&gt;&lt;/a&gt;闲话&lt;/h2&gt;&lt;p&gt;DP 太菜了，刷 AT 经典 DP，前面的比较简单，从 J 开始吧 qwq&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;AT-dp-J&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="题解" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
</feed>
